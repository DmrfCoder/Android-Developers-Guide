{"./":{"url":"./","title":"介绍","keywords":"","body":"Android Developer Guide翻译项目，主要翻译Android Developer Guide官方文档，会不断更新。同时由于本人个人时间精力有限，欢迎大家一起参与这个项目，对于已经翻译完成的部分，如果有不妥之处，欢迎大家即使反馈。目前已翻译完成的文档有： Activities Introduction to activities(Activity介绍) The activity lifecycle(Activity的生命周期) Activity state changes(Activity的状态变化) Test your app's activities(测试你的Activity) Understand Tasks And Back Stack(理解Task和回退栈) Process and Application Lifecycle(进程和应用程序的生命周期) Parcelables and Bundles(Parcelable和Bundle) Fragment Overview(Fragment(概述) Create a Fragment(创建Fragment) Test your fragments(测试Fragment) Build a flexible UI(构建灵活的UI) Communicate with other fragments(与其他Fragment通信) Interact with other apps(与其他应用交互) OverView(概述) Sending the user to another app(将用户导航到另一个APP) Getting a result from an activity(接收另一个Activity返回的结果) Allowing other apps to start your activity(允许其他应用启动您的Activity) Handling app links(处理Android APP Link) OverView(概述) Enabling links to app content(创建指向您内容的DeepLinks) Verify app Links(验证App Links) Create App links for instant app(为Instant APPs创建App Links) Loaders(加载器) Recents Screen(最近任务界面) Multi-Window Support(多窗口支持-分屏).md) App Short Cuts（App快捷启动方式) OverView(概述) Create shortcuts（创建快捷方式） Manage shortcuts(管理快捷方式) Best practices for shortcuts(快捷方式的最佳做法) App Widgets(应用小部件) OverView(概述) Build an App Widget(构建应用程序小部件) Build an App Widget Host(构建应用程序小部件主机).md) Guide to app architecture(应用程序架构指南) Architecture Components(架构组件) OverView(概述) Adding Components to your Project(给你的项目中添加架构组件) Layouts and binding expressions(布局和绑定表达式) Work with observable data objects(使用可观察的数据对象) Generated binding classes(生成的绑定类) Intent and intent filters(Intent和Intent过滤器) OverView(概述) Common intents(通用Intent) User Interface(用户界面) Create a List with RecyclerView(使用RecyclerView创建列表) BackGround Tasks(后台任务) Service(服务) OverView(概述) Create a background service(创建后台Service) Send work requests to the background service(向后台Service发送工作请求) Bound Service(绑定Service) Android Interface Definition Language (AIDL) Broadcast Sending Operations To Multiple Threads(将操作发送到多个线程) OverView(概述) Specify the code to run on a thread(指定线程中运行的代码) Create a manager for multiple threads(为多线程创建管理者).md) Run code on a thread pool thread(在线程池中运行代码) Communicate with the UI thread(与UI线程进行通信) Best Practices Performance 进程和线程——概述 "},"Activity/Activity介绍.html":{"url":"Activity/Activity介绍.html","title":"Activity介绍","keywords":"","body":"Activity简介（介绍） 原文（英文）地址 Activity类是Android应用程序的重要组成部分，Activity的启动和组合方式是应用程序的基本组成部分。与使用main（）方法启动应用程序的编程范例不同，Android系统通过调用与其生命周期的特定阶段相对应的特定回调方法来启动Activity实例中的代码。 本文档介绍了Activity的概念，然后提供了有关如何使用它们的一些轻量级指导。有关构建应用程序的最佳实践的其他信息，请参阅 Guide to App Architecture。 Activity的概念 移动应用与桌面应用不同，用户与移动应用的交互并不总是在同一个地方开始。相反，用户打开同一个应用的目的通常是非确定性的。例如，如果您从主屏幕打开电子邮件应用程序，则可能会看到电子邮件列表。但是，如果您在使用第三方社交媒体应用程序时从该应用内的入口启动您的电子邮件应用程序，您可能会直接进入电子邮件应用程序的屏幕撰写电子邮件。 Activity类旨在促进（方便化）这种应用场景。当一个应用程序调用另一个应用程序时，调用应用程序将调用另一个应用程序中的Activity，而不是一个整体的应用程序。通过这种方式，Activity可以作为应用与用户交互的入口点。您通常需要将Activity类作为父类去实现您自己的Activity（MYActivity extends Activity）。 Activity提供应用程序绘制其UI的Window。此Window通常填充屏幕，但可能小于屏幕并浮动在其他窗口的顶部。通常，一个Activity在应用程序中实现一个Window。例如，应用程序的某个Activity可能会implement（实现）一个Preferences （首选项）screen，而另一个会implement（实现） Select Photo （选择照片）screen。 大多数应用程序包含多个页面（screens），这意味着它们通常包含多个Activity，应用程序中的一个Activity被指定为MainActivity，这是用户启动应用程序时显示的第一页面。然后，每个Activity可以启动另一个Activity以执行不同的操作。例如，电子邮件应用程序中的MainActivity可能会提供显示电子邮件收件箱的界面，从那个页面开始，MainActivity可能会启动其他Activity，去展示编写电子邮件和打开个人电子邮件的界面。 虽然在一个应用中一般会有多个Activity紧密地在一起工作，但每个Activity仅与其他Activity轻耦合（依赖性不大），一个应用程序中不同的Activity之间通常存在很小的依赖关系。实际上，Activity通常会启动属于其他应用程序的Activity。例如，浏览器应用可能会启动社交媒体应用的共享。 要在应用程序中使用Activity，您必须在应用程序的manifest文件中注册有关它们的信息，并且必须合理地管理Activity的生命周期。本文档的其余部分介绍了这些主题。 配置manifest文件 为了使您的应用能够使用Activity，您必须在manifest文件中声明Activity及其某些属性。 声明Activity 打开你应用的manifest文件，在\\…中间添加元素，比如： ... ... 对于该元素唯一必须的属性是android:name，该属性唯一确定了一个Activity的类名。同样，你也可以在manifest中为该activity添加其他属性，比如label、icon或者UI theme等。想要了解更多activity的其他属性，可以参考 the element reference documentation . 注意：当你发布了你的APP之后，你就不应该再更改你Activity的名字（name），如果你在发布APP之后更改了某个Activity的name属性，你app的某些功能可能被破坏，比如你应用的快捷启动方式（app shortcuts），有关发布APP后应该禁止更改的属性，可以参见 Things That Cannot Change 声明intent filter Intent filter是Android平台一个非常强大的功能。其可以基于显式请求和隐式请求来启动Activity。例如，显式请求可能会告诉系统“在Gmail应用中启动发送电子邮件的Activity”。相反，隐式请求会告诉系统“在任何可以执行此任务的Activity中启动发送电子邮件的界面”。当系统UI询问用户在执行任务时使用哪个应用程序时，这是一个工作中的intent filter。 您可以通过在元素中声明属性来利用此功能。该元素的定义包括元素，以及可选的元素和/或元素。这些元素组合在一起以指定您的Activity可以响应的Intent类型。例如，以下代码段显示了如何配置发送文本数据的Activity，并从其他Activity接收请求以执行此操作： 在此例中，元素指定此Activity可以发送数据。将元素声明为DEFAULT可使Activity接收启动的请求。 元素指定此Activity可以发送的数据类型。以下代码段展示了如何调用上述Activity： kotlin val sendIntent = Intent().apply { action = Intent.ACTION_SEND type = \"text/plain\" putExtra(Intent.EXTRA_TEXT, textMessage) } startActivity(sendIntent) Java // Create the text message with a string Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND); sendIntent.setType(\"text/plain\"); sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage); // Start the activity startActivity(sendIntent); 如果您想使某一个Activity只能在本应用内启动（不需要其他应用启动该Activity），则不需要任何其他intent filter。您不希望其他应用程序可见的Activity应该没有intent filter，您可以使用显式意图自行启动它们。有关Activity如何响应Intent的更多内容，请参阅Intents and Intent Filters。 声明权限 您可以使manifest中的元素（element）来控制哪些应用可以启动特定Activity。除非两个Activity在其manifest文件中具有相同的权限（permissions），否则父Activity无法启动子Activity。如果为特定Activity声明元素（element），则调用其的Activity必须具有匹配的元素(element)。 例如，加入您的应用想要通过名为SocialApp的应用中的Activity在社交媒体上分享帖子，SocialApp中的Activity本身必须定义调用它的应用必须具有的权限： 同时，为了被允许调用SocialAPP，你自己的APP必须匹配SocialAPP的manifest文件中声明的权限： 有关权限和安全性的更多信息请参考：Security and Permissions。 管理Activity的生命周期 一个Activity从创建到销毁经历和很多不同的周期，你可以使用一系列的回调方法去控制不同生命周期应该执行的逻辑代码，接下来的一节介绍这些回调方法。 onCreate（） 您必须实现此回调，该回调在系统创建Activity时触发。您的实现应初始化Activity中的基本组件：例如，您的应用程序应创建视图并将数据绑定到列表。最重要的是，您必须调用setContentView（）来定义Activity用户界面的布局（xml布局文件）。 当onCreate（）完成时，进入Created状态，下一个回调一定是onStart（）。 onStart（） 当onCreate（）执行完成后，会调用onStart（），此回调主要包含Activity最终准备到达前台并变为交互式所需执行的逻辑。 执行完onStart（）之后Activity进入Started状态，Activity对用户可见，接着会调用onResume（）方法。 onResume（） 系统在Activity开始与用户交互之前回调此方法。此时，Activity位于Activity Stack（堆栈）的顶部，并捕获（captures）所有用户输入。应用程序的大多数核心功能都是在onResume（）方法中实现的。 onResume（）之后一般会调用onPause（）方法。 onPause（） 当Activity失去焦点并进入暂停状态时，系统回调onPause（）方法。例如，当用户点击“Back（后退键）”或“Recents（最近任务）”按钮时，会出现此状态。当系统回调您的Activity的onPause（）方法时，它在意味着您的Activity仍然部分可见，但通常表示用户正在离开Activity，并且Activity很快将进入“已停止（Stopped）”或“已恢复（Resumed）”状态。 如果用户期望UI继续更新，则处于暂停状态的Activity可以继续更新UI。这种场景的Activity包括导航地图的Activity或媒体播放器播放的Activity。即使这些Activity失去焦点，用户也希望他们的UI继续更新。 您不应使用onPause（）来保存应用程序或用户数据、进行网络调用或执行数据库事务。有关保存数据内容，请参阅 Saving and restoring activity state. 一旦onPause（）完成执行，下一个回调就是onStop（）或onResume（），具体取决于进入Paused状态后发生的情况。 onStop（） 当Activity不再对用户可见时，系统会回调onStop（）。这中情况一般是因为旧Activity正在被销毁（being destroyed），新Activity正在启动（Starting），或者现有Activity正在进入恢复状态（Resumed state）并且正在覆盖已停止的Activity。在这些场景下，已经停止的Activity不再可见。 之后如果Activity返回与用户交互（比如按了最近任务键之后又点击了之前的Activity），系统调用的下一个回调是onRestart（），如果此Activity完全终止，则会回调onDestroy（）。 onRestart（） 当一个处于Stopped状态的Activity被重新启动（start）时系统会回调onRestart（）方法。onRestart（）方法会恢复之前Activity停止（stop）时保存的状态。 onRestart（）方法执行完成之后一般会调用onStart（）方法。 onDestroy（） 系统在销毁Activity之前调用此方法。 此回调是Activity的最后一个回调。通常实现onDestroy（）以确保在Activity或包含该Activity的进程被销毁时释放所有Activity占用的资源。 有关Activity生命周期及其回调的更详细的内容，请阅读 Activity的生命周期。 "},"Activity/Activity的生命周期.html":{"url":"Activity/Activity的生命周期.html","title":"Activity的生命周期","keywords":"","body":"Activity的生命周期（理解Activity的生命周期） 原文（英文）地址 当用户导航（navigates through），退出和返回您的应用时，您应用中的Activity实例会在其生命周期中的不同状态中进行转换。 Activity类提供了许多回调方法，这些回调方法允许Activity知道状态已被更改：系统正在创建（creating），停止（stopping）或恢复（resuming），或者破坏（destroying）Activity所在的进程。 在生命周期的回调方法中，您可以指定用户离开和重新进入Activity时的行为。例如，如果您正在构建流式视频播放器，则可能会在用户切换到另一个应用时暂停视频并终止网络连接。当用户返回时，您可以重新连接到网络并允许用户从同一位置观看视频。换句话说，每个回调允许您执行适合于给定状态更改的特定工作。在正确的时间做正确的工作并正确处理过渡可以使您的应用程序更加强大和高效。例如，良好地实现生命周期的回调可以帮助确保您的应用程序避免以下几种情况： 用户在使用您的应用时接到电话或切换到其他应用导致本应用崩溃。 当用户不主动使用它时，消耗宝贵的系统资源。 如果用户离开您的应用并稍后返回时丢失用户的进度。 当屏幕在横向和纵向之间旋转时，应用发生崩溃或丢失用户的进度。 本节详细说明了Activity的生命周期。首先描述了生命周期范例。接下来，解释了每个回调在执行时内部发生的逻辑，以及在你在不同的回调方法中应该实现的逻辑。然后简要介绍了Activity状态与进程被系统杀死的漏洞之间的关系。最后，它讨论了与Activity不同状态之间转换相关的一些内容。 有关处理生命周期的信息（包括有关最佳实践的指导），请参阅Handling Lifecycles with Lifecycle-Aware Components 和 Saving UI States. 。要了解如何使用与体系结构组件结合的Activity来构建强大的，生产质量的应用程序，请参阅Guide to App Architecture.。 Activity生命周期的概念 为了在Activity生命周期的各个阶段之间切换，Activity提供了6个核心的回调方法：onCreate（），onStart（），onResume（），onPause（），onStop（）和onDestroy（）。当Activity进入不同的状态时，系统会回调对应阶段的回调方法。 下图直观的画出了各个回调方法的执行逻辑： 当用户开始离开Activity时，系统调用一些方法来移除Activity。在某些情况下，这种拆除只是部分的，Activity仍然驻留在内存中（例如当用户切换到另一个应用程序时），并且仍然可以返回到前台。如果用户返回该Activity，则Activity将恢复到用户停止的位置。系统是否杀死给定进程及其中的Activity取决于当时Activity的状态。 Activity state and ejection from memory provides more information on the relationship between state and vulnerability to ejection.（这个应该如何翻译？） 根据Activity的不同的复杂程度，您可能不需要实现所有生命周期对应的回调方法。但是，了解每一个毁掉方法并掌握其使用对确保您的应用程序符合用户期望的行为非常重要。 本文档的下一部分介绍了不同状态间转换对应的不同回调的具体情况。 不同生命周期的回调 本节主要介绍有关在Activity生命周期中回调方法使用的概念和方法。 某些操作（如调用setContentView（））属于Activity生命周期方法本身。但是，实现依赖组件操作的代码应放在组件本身。要实现此目的，您必须使依赖组件生命周期可见。请参阅Handling Lifecycles with Lifecycle-Aware Components以了解如何保证您的依赖组件生命周期可见性。 这一段不理解，原文如下： Some actions, such as calling setContentView(), belong in the activity lifecycle methods themselves. However, the code implementing the actions of a dependent component should be placed in the component itself. To achieve this, you must make the dependent component lifecycle-aware. See Handling Lifecycles with Lifecycle-Aware Components to learn how to make your dependent components lifecycle-aware. onCreate（） 您必须实现此回调方法，该方法在系统首次创建Activity时触发。在Activity创建时，Activity进入创建状态（Created state）。在onCreate（）方法中，您应该执行应用程序基本的启动逻辑，该逻辑在Activity的整个生命周期中只应发生一次。例如，onCreate（）中可能会将数据绑定到列表（list），将Activity与ViewModel相关联，并实例化一些类级变量（class-scope variables）。此方法接收参数savedInstanceState，该方法的参数参数是Activity先前用于保存状态的Bundle对象。如果Activity以前从未存在过，则Bundle对象的值为null。 如果您有一个生命周期感知组件（lifecycle-aware component ）与您的Activity的生命周期相关联，它将收到ON_CREATE事件，同时将调用使用@OnLifecycleEvent注释的方法，以便您的生命周期感知组件可以执行创建状态所需的任何代码。 以下onCreate（）方法示例显示了Activity的基本设置，例如声明用户界面（在XML布局文件中定义），定义成员变量以及配置某些UI。在此示例中，通过将文件的资源ID R.layout.main_activity传递给setContentView（）来指定XML布局文件： Kotlin lateinit var textView: TextView // some transient state for the activity instance var gameState: String? = null override fun onCreate(savedInstanceState: Bundle?) { // call the super class onCreate to complete the creation of activity like // the view hierarchy super.onCreate(savedInstanceState) // recovering the instance state gameState = savedInstanceState?.getString(GAME_STATE_KEY) // set the user interface layout for this activity // the layout file is defined in the project res/layout/main_activity.xml file setContentView(R.layout.activity_main) // initialize member TextView so we can manipulate it later textView = findViewById(R.id.text_view) } // This callback is called only when there is a saved instance that is previously saved by using // onSaveInstanceState(). We restore some state in onCreate(), while we can optionally restore // other state here, possibly usable after onStart() has completed. // The savedInstanceState Bundle is same as the one used in onCreate(). override fun onRestoreInstanceState(savedInstanceState: Bundle?) { textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY) } // invoked when the activity may be temporarily destroyed, save the instance state here override fun onSaveInstanceState(outState: Bundle?) { outState?.run { putString(GAME_STATE_KEY, gameState) putString(TEXT_VIEW_KEY, textView.text.toString()) } // call superclass to save any view hierarchy super.onSaveInstanceState(outState) } Java TextView textView; // some transient state for the activity instance String gameState; @Override public void onCreate(Bundle savedInstanceState) { // call the super class onCreate to complete the creation of activity like // the view hierarchy super.onCreate(savedInstanceState); // recovering the instance state if (savedInstanceState != null) { gameState = savedInstanceState.getString(GAME_STATE_KEY); } // set the user interface layout for this activity // the layout file is defined in the project res/layout/main_activity.xml file setContentView(R.layout.main_activity); // initialize member TextView so we can manipulate it later textView = (TextView) findViewById(R.id.text_view); } // This callback is called only when there is a saved instance that is previously saved by using // onSaveInstanceState(). We restore some state in onCreate(), while we can optionally restore // other state here, possibly usable after onStart() has completed. // The savedInstanceState Bundle is same as the one used in onCreate(). @Override public void onRestoreInstanceState(Bundle savedInstanceState) { textView.setText(savedInstanceState.getString(TEXT_VIEW_KEY)); } // invoked when the activity may be temporarily destroyed, save the instance state here @Override public void onSaveInstanceState(Bundle outState) { outState.putString(GAME_STATE_KEY, gameState); outState.putString(TEXT_VIEW_KEY, textView.getText()); // call superclass to save any view hierarchy super.onSaveInstanceState(outState); } 相比于直接设置xml文件作为视图层次结构，还有一个方法是在Activity中使用代码创建新的View对象，并通过将该View对象插入到ViewGroup中来构建视图层次结构。然后，通过将根ViewGroup传递给setContentView（）来使用该布局。有关创建用户界面的更多信息，请参阅 User Interface 文档。 onCreate（）方法完成执行后Activity就不是Created状态了，Activity会进入Started状态，系统快速连续调用onStart（）和onResume（）方法。下一节将介绍onStart（）。 onStart（） 当Activity进入Started状态时，系统将调用此回调方法。 onStart（）使Activity对用户可见，同时应用程序为Activity进入前台及Activity变成可交互的做准备工作。例如，此方法是应用程序初始化维护UI的代码的位置。 当Activity进入启动状态时，任何与Activity生命周期相关的生命周期感知组件（lifecycle-aware component）都将收到ON_START事件。 onStart（）方法非常快速地完成，并且与Created状态一样，Activity不会保持驻留在Started状态。一旦此回调结束，Activity就进入Resumed状态，系统将调用onResume（）方法。 onResume（） 当Activity进入Resumed状态时，它进入前台，然后系统调用onResume（）回调方法。这是应用程序与用户交互的状态。该应用程序保持这种状态直到某些其他的事件使当前应用程序失去焦点。例如，这样的事件可能是接收电话，用户导航到另一个Activity，或者设备屏幕关闭。 当Activity进入恢复状态（Resume state）时，任何与Activity生命周期相关的生命周期感知组件都将收到ON_RESUME事件。这是生命周期组件可以启用任何需要在组件可见且在前台运行时运行的功能的位置，例如启动摄像头预览。 当发生中断事件时，Activity进入Paused状态，系统调用onPause（）回调。 如果Activity从Paused状态返回Resumed状态，则系统再次调用onResume（）方法。因此，您应该实现onResume（）来初始化在onPause（）期间释放的组件，并执行每次Activity进入Resumed状态时必须进行的任何其他初始化。 以下是在组件收到ON_RESUME事件时访问摄像头的生命周期感知组件的示例： Kotlin class CameraComponent : LifecycleObserver { ... @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) fun initializeCamera() { if (camera == null) { getCamera() } } ... } Java public class CameraComponent implements LifecycleObserver { ... @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void initializeCamera() { if (camera == null) { getCamera(); } } ... } 一旦LifecycleObserver收到ON_RESUME事件，上面的代码就会初始化相机。但是，在多窗口模式（multi-window mode）下，即使Activity处于暂停状态，您的Activity也可能完全可见。例如，当用户处于多窗口模式并点击不包含您的Activity的其他窗口时，您的Activity将移至暂停状态。如果您希望仅在应用程序在Resumed状态（在前台可见且拥有焦点）时使您的相机生效，则在上面演示的ON_RESUME事件后初始化相机。如果您想在Activity暂停（Paused状态）但是可见时（例如在多窗口模式下）保持相机处于Activity状态，则应在ON_START事件后初始化相机。但请注意，在Activity暂停时让相机处于生效状态可能会在多窗口模式下拒绝另一个已生效的应用程序（Resumed状态）对相机的访问。有时可能需要在Activity暂停（Paused）时保持相机处于生效状态，但如果这样做，实际上可能会降低整体用户体验。仔细考虑生命周期中的哪个位置更适合在多窗口环境中控制共享系统资源。要了解有关支持多窗口模式的更多信息，请参阅Multi-Window Support. 无论您选择在哪个构建事件中执行初始化操作，请确保使用相应的生命周期事件来释放资源。如果在ON_START事件之后初始化某些内容，则在ON_STOP事件之后释放或终止它。如果在ON_RESUME事件之后初始化，则在ON_PAUSE事件之后释放。 请注意，上面的代码片段将相机初始化代码放在生命周期感知组件中。您可以将此代码直接放入Activity生命周期回调中，例如onStart（）和onStop（），但不建议这样做。将此逻辑添加到独立的生命周期感知组件中，您可以跨多个Activity重用该组件，而无需重复代码。请参阅 Handling Lifecycles with Lifecycle-Aware Components 以了解如何创建生命周期感知组件。 onPause（） 系统将此方法称为用户离开您的Activity的第一个标志（尽管并不总是意味着Activity正在被销毁），它表示Activity不再在前台（尽管如果用户处于多窗口模式，它仍然可见）。 使用onPause（）方法暂停或调整Activity处于Paused状态时不应继续（或应适度继续）并且您希望很快恢复的操作。 （这句感觉翻译的不太好，原文：Use the onPause() method to pause or adjust operations that should not continue (or should continue in moderation) while the Activity is in the Paused state, and that you expect to resume shortly. ） 例如： 某些事件会中断应用程序执行，如onResume（）部分所述。这是最常见的情况。 在Android 7.0（API级别24）或更高版本中，多个应用程序以多窗口模式运行。由于只有一个应用程序（窗口）可以占有焦点，系统会暂停所有其他应用程序。 将打开一个新的半透明Activity（如对话框）。只要Activity仍然部分可见但不是焦点，它仍然暂停。 当Activity进入暂停（paused）状态时，任何与Activity生命周期相关的生命周期感知组件都将收到ON_PAUSE事件。这是生命周期组件可以停止Activity不在前台时不需要运行的功能的地方，例如停止相机预览。 您还可以使用onPause（）方法释放系统资源，处理传感器（如GPS），或者在您的Activity暂停且用户不需要时可能影响电池寿命的任何资源。但是，如上面onResume（）部分所述，如果处于多窗口模式，PausedActivity仍然可以完全可见。因此，您应该考虑使用onStop（）而不是onPause（）来完全释放或调整与UI相关的资源和操作，以更好地支持多窗口模式。 下面对On_PAUSE事件做出反应的LifecycleObserver示例是上面ON_RESUME事件示例的对应示例，释放了在收到ON_RESUME事件后初始化的摄像头： Kotlin class CameraComponent : LifecycleObserver { ... @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) fun releaseCamera() { camera?.release() camera = null } ... } java public class JavaCameraComponent implements LifecycleObserver { ... @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void releaseCamera() { if (camera != null) { camera.release(); camera = null; } } ... } 注意，上面的代码片段在LifecycleObserver收到ON_PAUSE事件释放相机资源。如前所述，请参阅 Handling Lifecycles with Lifecycle-Aware Components以了解如何创建生命周期感知组件。 onPause（）执行非常简短，并不一定要有足够的时间来执行保存操作。因此，您不应使用onPause（）来保存应用程序或用户数据，进行网络调用或执行数据库事务，因为在方法完成之前，此类工作可能无法完成。您应该在onStop（）中执行重负载的关闭操作。有关在onStop（）期间执行的合适操作的更多信息，请参阅onStop（）。有关保存数据的更多信息，请参阅Saving and restoring activity state. 完成onPause（）方法并不意味着Activity离开Paused状态。相反，Activity保持在此状态，直到Activity恢复或变得对用户完全不可见。如果Activity恢复，系统将再次调用onResume（）回调。如果Activity从Paused状态返回到Resumed状态，系统会将Activity实例驻留在内存中，在系统调用onResume（）时调用该实例。在这种情况下，您无需重新初始化在任何导致Resumed状态的回调方法期间创建的组件。如果Activity变得完全不可见，则系统调用onStop（）。 onStop（） 当您的Activity不再对用户可见时，它已进入Stopped状态，系统将调用onStop（）回调。例如，当新启动的Activity覆盖整个屏幕时，可能会发生这种情况。当Activity完成运行并且即将终止时，系统也可以调用onStop（）。 当Activity进入停止状态时，任何与Activity生命周期相关的生命周期感知组件都将收到ON_STOP事件。这是生命周期组件可以停止Activity在屏幕上不可见时不需要运行的功能的地方。 在onStop（）方法中，应用程序应释放或调整应用程序对用户不可见时不需要的资源。例如，您的应用可能会暂停动画或从细粒度位置更新切换到粗粒度位置更新。使用onStop（）而不是onPause（）可确保与UI相关的工作继续进行，即使用户在多窗口模式下查看您的Activity也是如此。 您还应该使用onStop（）执行相对CPU密集型的关闭操作。例如，如果找不到更合适的时间将信息保存到数据库，则可以在onStop（）期间执行此操作。以下示例显示onStop（）的实现，该实现将草稿注释（draft note）的内容保存到持久存储： kotlin override fun onStop() { // call the superclass method first super.onStop() // save the note's current draft, because the activity is stopping // and we want to be sure the current note progress isn't lost. val values = ContentValues().apply { put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText()) put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle()) } // do this update in background on an AsyncQueryHandler or equivalent asyncQueryHandler.startUpdate( token, // int token to correlate calls null, // cookie, not used here uri, // The URI for the note to update. values, // The map of column names and new values to apply to them. null, // No SELECT criteria are used. null // No WHERE columns are used. ) } java @Override protected void onStop() { // call the superclass method first super.onStop(); // save the note's current draft, because the activity is stopping // and we want to be sure the current note progress isn't lost. ContentValues values = new ContentValues(); values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText()); values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle()); // do this update in background on an AsyncQueryHandler or equivalent asyncQueryHandler.startUpdate ( mToken, // int token to correlate calls null, // cookie, not used here uri, // The URI for the note to update. values, // The map of column names and new values to apply to them. null, // No SELECT criteria are used. null // No WHERE columns are used. ); } 注意，上面的代码示例直接使用SQLite。您应该使用Room，这是一个提供SQLite抽象层的持久性库。要了解有关使用Room的好处以及如何在应用程序中实现Room的更多信息，请参阅 Room Persistence Library 指南。 当您的Activity进入Stopped状态时，Activity对象将保留在内存中：它维护所有状态和成员信息，但不会附加到窗口管理器。Activity恢复后，Activity会恢复此信息。您不需要重新初始化任何在导致Resumed状态发生的回调方法中创建的组件（也就是说如果某一个方法执行完成之后Activity进入了Resumed状态，则当Activity恢复时你不需要手动重新初始化该方法中初始化的组件）。系统还会跟踪布局中每个View对象的当前状态，因此，如用户在EditText小部件中输入的文本，则会保留该内容，因此您无需保存和还原它。 注意：停止Activity后，如果系统需要恢复内存，系统可能会破坏包含Activity的进程。即使系统在活动停止时销毁进程，系统仍会保留Bundle（一对键值对）中的View对象（例如EditText小部件中的文本）的状态，并在用户恢复它们时导航回Activity。有关还原用户返回的活动的详细信息，请参阅Saving and restoring activity state.。 Stopped状态之后，Activity要么返回与用户交互，要么Activity已完成运行并消失。如果Activity返回，系统将调用onRestart（）。如果Activity已完成运行，则系统调用onDestroy（）。 onDestroy（） onDestroy（）方法在Activity被系统销毁之前回调，一下场景会导致系统回调onDestroy（）： Activity正在结束（由于用户完全移除Activity或由于Activity调用完成） 由于配置更改（例如设备旋转或多窗口模式），系统暂时销毁Activity 当Activity进入销毁状态时，任何与Activity生命周期相关的生命周期感知组件都将收到ON_DESTROY事件。这是生命周期组件可以销毁在销毁Activity之前所需的任何内容的地方（释放所有资源）。 您应该使用ViewModel对象来包含Activity的相关视图数据，而不是在您的Activity中使用逻辑判断Activity被销毁的原因。如果由于配置更改而将重新创建Activity，则ViewModel不必执行任何操作，因为它将被保留并提供给下一个Activity实例。如果不重新创建Activity，则ViewModel将调用onCleared（）方法，以便在销毁之前清除所需的任何数据。您可以使用isFinishing（）方法区分这两种情况。 如果Activity正在完成（is finishing），则onDestroy（）是Activity接收到的最终生命周期回调。如果由于配置更改而调用onDestroy（），系统会立即创建新的Activity实例，然后在新配置中的新实例上调用onCreate（）。 onDestroy（）回调应该释放早期回调（例如onStop（））尚未释放的所有资源。 Activity的状态与及内存回收（ejection from memory） 系统在需要释放RAM时会终止进程，系统杀死给定进程的可能性取决于当时进程的状态。反过来，进程状态取决于进程中运行的Activity的状态。表1显示了进程状态，Activity状态和系统终止进程的可能性之间的相关性： 进程被终止的可能性 进程状态 Activity状态 小 前台（拥有或即将拥有焦点） Created，Started，Resumed 中 后台（失去焦点） Paused 大 后台（失去焦点） Stopped 大 空 Destroyed 系统永远不会直接杀死Activity以释放内存，它会杀死Activity运行的进程，不仅会破坏当前Activity，还会破坏进程中运行的所有其他Activity。要了解在系统启动的进程被销毁时如何保留和恢复Activity的UI状态，请参阅Saving and restoring activity state. 用户还可以使用“设置”下的“应用程序管理器”终止相应的应用程序。 有关一般进程的更多信息，请参阅 Processes and Threads. 有关进程生命周期如何与其中Activity状态相关联的更多信息，请参阅该页面的“ Process Lifecycle”部分。 保存和恢复瞬间UI状态 用户期望Activity的UI状态在整个配置更改期间保持不变，例如旋转或切换到多窗口模式。但是，当发生此类配置更改时，系统会默认销毁Activity，从而消除存储在Activity实例中的任何UI状态。同样，如果用户暂时从您的应用切换到其他应用，然后稍后再回到您的应用，用户同样希望UI状态保持不变。但是，当用户离开并且您的Activity停止时，系统可能会释放您的应用程序的进程。 当Activity因系统限制而被销毁时，您应该使用ViewModel，onSaveInstanceState（）和/或本地存储的组合来保留用户的瞬态UI状态。要了解有关用户期望与系统行为的更多信息，以及如何在系统启动的Activity和流程死亡中最好地保留复杂的UI状态数据，请参阅 Saving UI State. 下一节概述了实例状态（instance state）以及如何实现onSaveInstance（）方法，该方法是对Activity本身的回调。如果您的UI数据简单而轻量级，例如原始数据类型或简单对象（如String），则可以单独使用onSaveInstanceState（）来保持UI状态跨越配置更改和系统启动的进程死亡。但是，在大多数情况下，您应该使用ViewModel和onSaveInstanceState（）（如 Saving UI State中所述），因为onSaveInstanceState（）会存在序列化/反序列化成本。 实例状态（Instance state） 在某些情况下，您的Activity会因应用程序的正常行为而被销毁，例如当用户按下“返回”按钮或您的Activity通过调用finish（）方法发出自己需要被破坏信号时。当您的Activity因用户按下Back或Activity自行完成而被销毁时，系统和用户对该Activity实例的概念将永远消失。在这些情况下，用户的期望与系统的行为相匹配，您没有任何额外的工作要做。 但是，如果系统因系统约束（例如配置更改或内存压力）而破坏Activity，则虽然实际的Activity实例已消失，但系统会记住它已存在。如果用户尝试导航回Activity，系统将使用一组已保存的数据创建该Activity的新实例，这些数据描述了Activity在销毁时的状态。 系统用于恢复先前状态的已保存数据称为实例状态，是存储在Bundle对象中的键值对的集合。默认情况下，系统使用Bundle实例状态来保存Activity布局中每个View对象的信息（例如输入EditText小部件的文本值）。因此，如果您的Activity实例被销毁并重新创建，则布局的状态将恢复到之前的状态，而您无需自己编写代码。但是，您的Activity可能包含您要恢复的更多状态信息，例如跟踪用户在Activity中的进度的成员变量。 注意：为了让Android系统恢复Activity中View的状态，每个View必须具有唯一的ID，由android：id属性提供。 Bundle对象不适合保留过大的数据，因为它需要在主线程上进行序列化并消耗系统进程内存。要保留较多的数据，您应该采用组合方法来保留数据：使用持久本地存储，onSaveInstanceState（）方法和ViewModel类，如保存和恢复瞬间UI状态（上一节）中所述。 使用onSaveInstanceState（）保存简单、轻量的UI状态 当您的Activity开始停止（begin stop）时，系统会调用onSaveInstanceState（）方法，以便您的Activity可以将状态信息保存到实例状态的bundle中。此方法的默认实现会保存有关Activity视图层次结构状态的瞬态信息，例如EditText小部件中的文本或ListView小部件的滚动位置。 要保存Activity的其他实例状态信息，必须重写onSaveInstanceState（）并将键值对添加到Bundle对象，该对象在您的Activity意外销毁时保存。如果重写onSaveInstanceState（）时希望同时实现默认的保存视图层次结构的状态则必须调用超类实现。例如： kotlin override fun onSaveInstanceState(outState: Bundle?) { // Save the user's current game state outState?.run { putInt(STATE_SCORE, currentScore) putInt(STATE_LEVEL, currentLevel) } // Always call the superclass so it can save the view hierarchy state super.onSaveInstanceState(outState) } companion object { val STATE_SCORE = \"playerScore\" val STATE_LEVEL = \"playerLevel\" } java ```java static final String STATE_SCORE = \"playerScore\"; static final String STATE_LEVEL = \"playerLevel\"; // ... @Override public void onSaveInstanceState(Bundle savedInstanceState) { // Save the user's current game state savedInstanceState.putInt(STATE_SCORE, currentScore); savedInstanceState.putInt(STATE_LEVEL, currentLevel); // Always call the superclass so it can save the view hierarchy state super.onSaveInstanceState(savedInstanceState); } > 注意：当用户显式关闭Activity时或调用finish（），不会调用onSaveInstanceState（）。 要保存持久性数据（例如用户首选项或数据库的数据），您应该在Activity处于前台状态时寻找合适的时机进行保存，如果没有这样的时机，您应该在onStop（）方法中保存这些数据。 ### 使用已经保存的实例状态恢复UI状态 之前销毁Activity后重新创建Activity时，可以从系统传递给Activity的Bundle中恢复已保存的实例状态。 onCreate（）和onRestoreInstanceState（）回调方法都接收包含实例状态信息的相同Bundle。 因为无论系统是创建Activity的新实例还是重新创建前一个实例，都会调用onCreate（）方法，因此在尝试读取之前必须检查状态Bundle是否为null。如果它为null，则系统正在创建Activity的新实例，而不是恢复已销毁的先前实例。 例如，以下代码段显示了如何在onCreate（）中恢复某些状态数据： - kotlin ```kotlin override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Always call the superclass first // Check whether we're recreating a previously destroyed instance if (savedInstanceState != null) { with(savedInstanceState) { // Restore value of members from saved state currentScore = getInt(STATE_SCORE) currentLevel = getInt(STATE_LEVEL) } } else { // Probably initialize members with default values for a new instance } // ... } java @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Always call the superclass first // Check whether we're recreating a previously destroyed instance if (savedInstanceState != null) { // Restore value of members from saved state currentScore = savedInstanceState.getInt(STATE_SCORE); currentLevel = savedInstanceState.getInt(STATE_LEVEL); } else { // Probably initialize members with default values for a new instance } // ... } 您可以选择实现onRestoreInstanceState（），在该方法中恢复状态而不是在onCreate（）中，系统在onStart（）方法之后会调用该方法。仅当存在要还原的已保存状态时，系统才会调用onRestoreInstanceState（），因此您无需检查Bundle是否为null： kotlin ```kotlin override fun onRestoreInstanceState(savedInstanceState: Bundle?) { // Always call the superclass so it can restore the view hierarchy super.onRestoreInstanceState(savedInstanceState) // Restore state members from saved instance savedInstanceState?.run { currentScore = getInt(STATE_SCORE) currentLevel = getInt(STATE_LEVEL) } } - java ```java public void onRestoreInstanceState(Bundle savedInstanceState) { // Always call the superclass so it can restore the view hierarchy super.onRestoreInstanceState(savedInstanceState); // Restore state members from saved instance currentScore = savedInstanceState.getInt(STATE_SCORE); currentLevel = savedInstanceState.getInt(STATE_LEVEL); } 警告：应该始终调用onRestoreInstanceState（）的超类实现（即super.onRestireInstanceState(saveInstanceState)），以便默认实现可以恢复视图层次结构的状态。 在不同Activity之间导航 在应用程序的生命周期中，应用程序很可能会多次进入和退出Activity。例如，用户可以点击设备的“后退”按钮，或者Activity可能需要启动不同的Activity。本节介绍了实现Activity跳转所需了解的内容。这些内容名包括从其他Activity启动Activity，保存Activity状态以及恢复Activity状态。 在另一个Activity启动当前Activity Activity通常需要在某个时刻启动另一个Activity。例如，当应用程序需要从当前屏幕移动到新屏幕时，就会出现这种需求。 根据您的Activity是否希望从即将启动的新Activity返回结果，您可以使用startActivity（）或startActivityForResult（）方法启动新Activity。这两种方法都需要传入一个Intent对象。 Intent对象指定要启动的Activity，或描述您要执行的操作类型（系统为您选择适当的Activity，甚至可以来自不同的应用程序）。 Intent对象还可以携带由启动的Activity使用的少量数据。有关Intent类的更多信息，请参阅Intents and Intent Filters.。 startActivity() 如果新启动的Activity不需要返回结果，则当前Activity可以通过调用startActivity（）方法启动它。 在Activity工作在自己的应用程序中时（本应用的Activity），通常需要简单地启动已知Activity。例如，以下代码段显示了如何启动名为SignInActivity的Activity： kotlin val intent = Intent(this, SignInActivity::class.java) startActivity(intent) java Intent intent = new Intent(this, SignInActivity.class); startActivity(intent); 您的应用程序可能还希望使用Activity中的数据执行某些操作，例如发送电子邮件，短信或状态更新。在这种情况下，您的应用程序可能没有自己的Activity来执行此类操作，因此您可以利用设备上其他应用程序提供的Activity，这些Activity可以为您执行操作。这是Intent非常有价值的地方：您可以创建描述您要执行的操作的Intent，系统从另一个应用程序启动相应的Activity。如果有多个Activity可以处理意图，那么用户可以选择使用哪个Activity。例如，如果要允许用户发送电子邮件，可以创建以下Intent： kotlin val intent = Intent(Intent.ACTION_SEND).apply { putExtra(Intent.EXTRA_EMAIL, recipientArray) } startActivity(intent) java Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL, recipientArray); startActivity(intent); 添加到intent中的EXTRA_EMAIL Extra是电子邮件应发送到的电子邮件地址的字符串数组。当电子邮件应用程序响应此意图时，它会读取extra中提供的字符串数组，并将它们放在电子邮件撰写表单的“to”字段中。在这种情况下，电子邮件应用程序的Activity开始，当用户完成后，您的Activity将恢复。 startActivityForResult() 有时您希望在Activity结束时从Activity中获取返回结果。例如，您可以启动一项Activity，让用户在联系人列表中选择一个人，当它结束时，它返回被选中的人。为此，请调用startActivityForResult（Intent，int）方法，其中integer参数标识该调用。此标识符用于消除来自同一Activity的多次startActivityForResult（Intent，int）调用之间的歧义。它不是全局标识符，不存在与其他应用程序或Activity冲突的风险。结果通过onActivityResult（int，int，Intent）方法返回。 当子Activity退出时，它可以调用setResult（int）将数据返回到其父级。子Activity必须始终提供结果代码，该结果代码可以是标准结果RESULT_CANCELED，RESULT_OK或从RESULT_FIRST_USER开始的任何自定义值。此外，子Activity可以选择性地返回包含所需的任何其他数据的Intent对象。父Activity使用onActivityResult（int，int，Intent）方法以及父Activity最初提供的整数标识符来接收信息。 如果子Activity因任何原因（例如崩溃）失败，则父Activity将收到代码为RESULT_CANCELED的结果。 kotlin class MyActivity : Activity() { // ... override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean { if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) { // When the user center presses, let them pick a contact. startActivityForResult( Intent(Intent.ACTION_PICK,Uri.parse(\"content://contacts\")), PICK_CONTACT_REQUEST) return true } return false } override fun onActivityResult(requestCode: Int, resultCode: Int, intent: Intent?) { when (requestCode) { PICK_CONTACT_REQUEST -> if (resultCode == RESULT_OK) { startActivity(Intent(Intent.ACTION_VIEW, intent?.data)) } } } companion object { internal val PICK_CONTACT_REQUEST = 0 } } java public class MyActivity extends Activity { // ... static final int PICK_CONTACT_REQUEST = 0; public boolean onKeyDown(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) { // When the user center presses, let them pick a contact. startActivityForResult( new Intent(Intent.ACTION_PICK, new Uri(\"content://contacts\")), PICK_CONTACT_REQUEST); return true; } return false; } protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == PICK_CONTACT_REQUEST) { if (resultCode == RESULT_OK) { // A contact was picked. Here we will just display it // to the user. startActivity(new Intent(Intent.ACTION_VIEW, data)); } } } } 协调Activity 当一个Activity启动另一个Activity时，它们都会经历生命周期转换，第一个Activity停止运行并进入暂停或停止状态，同时创建另一个Activity。如果这些Activity共享保存到磁盘或其他地方的数据，则必须知道第一个Activity在创建第二个Activity之前未完全停止。相反，启动第二个的过程与停止第一个过程重叠。 生命周期回调的顺序是明确定义的，特别是当两个Activity在同一个进程（app）中而另一个正在启动另一个时。以下是ActivityA启动ActivityB时发生的操作顺序： A.onPause() B.onCreate(), B.onStart(), 和 B.onResume() 被顺序执行（Activity此时获得焦点） A Activity不再可见， A.onStop() 被调用 这种可预测的生命周期回调序列允许您管理从一个Activity到另一个Activity的转换信息。 "},"Activity/Activity的状态变化.html":{"url":"Activity/Activity的状态变化.html","title":"Activity的状态变化","keywords":"","body":"Activity的状态变化 原文（英文）地址 不同的事件(一些是用户触发的，一些是系统触发的)，可以导致Activity从一个状态转换到另一个状态。本节描述了发生此类转换的一些常见情况，以及如何处理这些转换。 有关Activity状态的更多信息，请参阅理解Activity的生命周期。要了解ViewModel类如何帮助您管理活动生命周期，请参阅Understand the ViewModel Class. 发生配置更改（Configuration change occurs） 有很多事件的发生会导致配置被更改，最常见的例子就比如屏幕在横屏和竖屏之间切换，还有其他的一些事件比如语言发生改变或者输入设备发生改变等也会导致配置被更改。 当配置被更改时，Activity会被销毁并且重建，原来（旧）的Activity实例将会触发onPause（）、onStop（）、onDestroy（）的调用，而新Activity实例将会被创建并且调用onCreate（）、onStart（）以及onResume（）回调方法。 结合使用ViewModels、onSaveInstanceState（）方法，以及/或本地持久化存储可以跨配置（across configuration changes.）保留Activity的UI状态。你应该根据你UI数据的复杂性、检索速度、内存的占用情况去决定如何结合这些可选的方法去实现你Activity的UI持久化。想要了解更多的信息请参阅 Saving UI States. 处理多窗口的情况 当一个app处于多窗口模式时（该模式可存在于系统版本高于等于Android7.0即ApI为24的设备上），如果配置发生改变，系统会通知当前正在运行的Activity，这样就可以执行上述配置发生改变时Activity的不同生命周期。不同于普通模式，处于多窗口模式的应用调整窗口大小后也会发生配置的更改，你可以在你的Activity中自行处理配置更改的情况，也可以允许系统销毁原有Activity后重建Activity。 关于更多的Activity在多窗口模式下的生命周期，请参阅Multi-Window Support](https://developer.android.com/guide/topics/ui/multi-window.html) 页面中的 Multi-Window Lifecycle节。 在多窗口模式下，尽管有两个app同时对用户可见，但是在同一时间用户只会关注一个前台的app而且只有该一个app占有焦点，该Activity处于Resumed状态，而其他的处于前台但是没有占有焦点的Activity处于Paused状态。 当用户从app A切换到app B，系统会调用app A中当前（前台）Activity的onPause（）方法，同时调用app B中当前（前台）Activity的onResume（）方法。每次用户切换app时都会分别调用两个app中前台Activity的onPause（）和onResume（）方法。 关于更多多窗口模式的内容，请参阅Multi-Window Support. Activity或者Dialog出现在前台 如果一个新的Activity或者Dialog出现在前台并且获取焦点，同时部分地覆盖了之前的Activity，那么那个被部分覆盖的Activity会失去焦点同时进入Paused 状态，接着系统会调用该Activity的onPause（）方法。 当被部分覆盖的Activity重新回到前台并获取到焦点时，系统会调用他的onResume（）方法。 如果一个新的Activity或者Dialog出现在前台并获取到焦点，同时完全覆盖了之前的Activity，那么系统会快速连续地调用那个被完全覆盖的Activity的onPause（）和onStop（）方法。 当之前那个被完全覆盖的Activity 的实例重新回到前台时，系统会调用该Activity的OnRestart（）、onStart（）以及onResume（）方法。 如果是之前被覆盖的Activity的新的实例从后台切换到前台，则只会调用它的onStart（）和onResume（）方法，不会调用onRestart（）。 注意：当用户按了home键后，系统所做对之前处于前台的Activity所做的操作和该Activity被完全覆盖时所做的操作一样。 用户点击了Back按键 如果一个Activity处于前台并且用户点击了Back按键，系统会调用该Activity的onPause（）、onStop（）、onDestroy（）方法，当Activity被Destroy后，该Activity也会被从回退栈中移除。 必须记住的很重要的一点是默认情况下onSateInstanceState（）方法在此种情况下不会被调用。This behavior is based on the assumption that the user tapped the Back button with no expectation of returning to the same instance of the activity. 然而，你可以重写onBackPressed（）方法去实现一些自己的需求，比如弹出“确认退出”提示框。 在你重写了onBackPressed（）方法的同时我们强烈建议你在你重写的方法体中调用super.onBackPressed()方法，否则后悔按钮可能会刺激到？（ jarring to）用户。 系统杀死了APP进程 如果系统为了处于前台的app需要清理内存，那么处于后台的app可以被杀死以释放更多的内存。想要了解更多关于系统是如何决定是否杀死一个app的，可以参阅 Activity state and ejection from memory 和 Processes and Application Lifecycle. 想要了解更多如何在系统杀死你的app的同时保存你Activity的UI状态，请参阅Saving and restoring activity state. "},"Activity/测试你的Activity.html":{"url":"Activity/测试你的Activity.html","title":"测试你的Activity","keywords":"","body":"测试你的Activity 原文（英文）地址 Activity作为应用程序与用户交互的容器，因此在发生设备级事件时测试Activity的不同行为尤为重要，比如： 其他APP（比如设备来电APP）中断了你的Activity 设备销毁并重建了你的Activity 用户将你的Activity放置到了一个新的窗口环境，比如画中画（picture-in-picture ，PIP ）或者多窗口模式。 尤为重要的一点是保证你的Activity在响应文章 Activity的生命周期 中描述的事件时依然可以表现正常。 这篇文章主要描述如何评估应用程序维护数据完整性的能力以及如何评估良好的用户体验，因为您应用程序的Activity在其生命中的不同阶段会处于不同的状态。 驱动（Drive）一个Activity的状态 测试应用程序Activity的一个关键点是将Activity置于特定的状态，请使用ActivityScenario的实例，它是AndroidX Test库的一部分。通过使用此类，您可以将Activity置于模拟本文章开头所描述的设备级事件的状态。 ActivityScenario是一个跨平台的API，您可以在本地单元测试（local unit tests ）和设备集成测试（on-device integration tests）中使用它们。假设你测试程序在运行在线程A，被测试的程序运行在线程B，无论是在真机还是虚拟机上，ActivityScenario都可以保证线程安全即可以在A线程和B线程之间同步事件。该API还特别适用于评估被测试的Activity在销毁或创建时的行为方式。 本节介绍与此API相关的常见用法。 创建一个Activity 为了创建一个运行在测试环境下的Activity，你应该添加以下代码： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEvent() { val scenario = launchActivity() } } 创建完Activity之后ActivityScenario会将Activity过渡到Resumed状态，该状态表名你的Activity正在运行且对用户可见，在这个状态下，你可以自由地使用 Espresso UI tests与你Activity上的View元素进行交互。 另外，你也可以使用ActivityScenarioRule在每一个test之前自动地调用ActivityScenario.launch，在测试结束的时候调用ActivityScenario.close。下面这个例子延时了如何定义一个规则（rule）并且获取scenario 的一个实例： @RunWith(AndroidJUnit4::class) class MyTestSuite { @get:Rule var activityScenarioRule = activityScenarioRule() @Test fun testEvent() { val scenario = activityScenarioRule.scenario } } 将Activity驱动到一个新的状态 为了将Activity转换到比如Created或者Started这类状态，你应该调用moveToState（）方法。该方法可以模拟您的Activity因为被另一个应用程序或者系统终端而被停止或暂停的情况。 下面是一个moveToState（）的使用示例： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEvent() { val scenario = launchActivity() scenario.moveToState(State.CREATED) } } 警告：如果你尝试将被测试中的Activity转换为其当前的状态（也就是Activity当前的状态时A，你又在此时调用了moveToState（A）），则ActivityScenario将会忽略此请求，而不是抛出异常。 重建Activity 如果一个设备资源不足，系统可能会销毁Activity，当用户重新进入你的Activity时将会重建Activity，为了模拟这个场景，你应该调用recreate（）： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEvent() { val scenario = launchActivity() scenario.recreate() } } ActivityScenario类会维护已经保存的Activity的实例的状态和使用@NonConfigurationInstance注释的任何对象，这些对象将加载到你正在测试的Activity的心实例中。 接收Activity的返回结果 在你运行并且完成一个Activity之后，你可以使用以下代码接收到该Activity的返回结果： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testResult() { val scenario = launchActivity() onView(withId(R.id.finish)).perform(click()) val resultCode = scenario.result.resultCode val resultData = scenario.result.resultData } } 触发Activity中的操作 ActivityScenario中的所有方法都是阻塞调用，因此API需要您在测试线程中运行他们。 为了触发你被测试Activity中的操作，使用Espresso视图匹配器与视图中的元素进行交互： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEvent() { val scenario = launchActivity() onView(withId(R.id.refresh)).perform(click()) } } 如果需要调用Activity本身的方法，你可以通过实现ActivityAction安全地达到这个目的： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEvent() { val scenario = launchActivity() scenario.onActivity { activity -> activity.handleSwipeToRefresh() } } } 注意：在测试类中，不要保留传递给onActivity（）的对象的引用。因为这些引用会消耗系统资源，并且引用本身可能是陈旧的（失效的），因为框架可以重新创建传递给回调方法的Activity。 想要了解更多关于线程如何在Android test中工作的内容，参考 Understand threads in tests. "},"Activity/理解Task和回退栈.html":{"url":"Activity/理解Task和回退栈.html","title":"理解Task和回退栈","keywords":"","body":"理解Task和回退栈 原文（英文）地址 Task是用户在执行特定任务时与之交互的所有Activity的集合。Activity按堆栈排列 （回退堆栈 ）—— 按打开Activity的顺序排列。例如，电子邮件应用可能有一个Activity来显示新消息列表，当用户选择消息时，将打开一个新Activity以查看该消息，此新Activity将添加到后台堆栈中，如果用户按下“返回”按钮，则该新Activity将完成（finished）并从堆栈中弹出。以下视频概述堆栈背后的工作原理。 当多个应用程序在多窗口模式（在Android 7.0，API级别24及更高版本中受支持）中同时运行时，系统会为每个窗口单独管理Task，每个窗口可能有多个Task。对于在Chromebook上运行的Android应用程序也是如此：系统基于每个窗口管理Task或groups of tasks（task组）。 设备主屏幕是大多数Task的起始位置，当用户触摸应用程序启动器中的图标（或主屏幕上的快捷方式）时，该应用程序的Task将进入前台，如果应用程序不存在Task（最近未使用该应用程序），则会创建一个新Task，该应用程序的“主”Activity将作为堆栈中的根Activity打开。 当当前Activity开始另一个Activity时，新Activity将被推（push）到堆栈顶部并获得焦点，之前的Activity仍在堆栈中，但已停止。当Activity停止时，系统将保留其用户界面的当前状态，当用户按下“返回”按钮时，当前Activity将从堆栈顶部弹出（Activity被销毁），之前的Activity将恢复（其UI的先前状态将恢复）。堆栈中的Activity永远不会重新排列，只能在当前Activity启动时从堆栈中推送并弹出到堆栈中，并在用户使用“返回”按钮离开时弹出。因此，回退栈是一种“后进先出”的对象结构。图一显示了这种动作，时间轴显示了Activity之间的进度以及每个时间点的当前回退栈： 图一：说明Task中每个新的Activity如何被添加到后台堆栈中以及当用户按下“返回”按钮时会销毁当前Activity并恢复之前的Activity 如果用户继续点击“返回”按键，堆栈中的Activity将会依次出栈（pop）以显示前一个Activity，知道用户返回到了主界面（或者任务栈在开始时运行的Activity）。当所有的Activity都被从堆栈中移除，该Task也就不再存在。 Task是一个内聚单元（cohesive unit），当用户开始新Task或通过Home按钮进入主屏幕时，之前的Task可以移动到“后台”。在后台，Task中的所有Activity都会停止，但Task的后台堆栈中仍然完好无损 ——当前Task在被新Task替代后就就失去了焦点，如图2所示。 图二：两个Task，Task B在前台与用户进行交互，Task A在后台等待被恢复 然后Task可以返回到“前台“，所以可以从被中断的地方继续与进行用户进行交互。例如，假设当前Task（TaskA），在TaskA堆栈中有三个Activity（在当前Activity下有两个Activity），此时用户按下Home按钮，然后从应用启动器启动新应用，显示主屏幕时，TaskA进入后台，当新应用程序启动时，系统会为该应用程序的一系列Activity启动新的Task（TaskB），在与该应用程序交互完成之后，用户再次返回Home并选择最初启动TaskA的应用程序，现在，TaskA进入前台，并且其堆栈中的所有三个Activity都是完整的，堆栈顶部的Activity将恢复。此时，用户还可以通过Back键返回主页并选择启动TaskB对应的应用程序图标（或按“Recent”按钮后从最近任务中选择TaskB对应的应用程序）切换回TaskB。这是Android上处理多Task的一个示例。 注意：可以同时在后台同时保存多个任务。但是，如果用户同时运行许多后台任务，系统可能会销毁后台Activity以回收内存，从而导致Activity状态丢失。 由于后台堆栈中的Activity永远不会重新排列，如果您的应用程序允许用户从多个Activity启动特定Activity，则会创建该Activity的新实例并将其推送到堆栈（而不是将任何先前的Activity实例调整到顶部）。因此，应用程序中的一个Activity可能会被多次实例化（甚至来自不同的Task），如图3所示。因此，如果用户使用“后退”按钮向后导航，则Activity的每个实例都按顺序显示并被打开（每个都有自己的UI状态）。但是，如果您不希望多次实例化Activity，则可以修改此行为。有关如何执行此操作将在下一节”管理Task“中讨论。 图三：一个Activity被多次实例化 总结一下Activity和Task的默认操作： 当ActivityA启动ActivityB时，ActivityA停止，但系统保留其状态（例如滚动位置和输入到表单中的文本）。如果用户在ActivityB中按下“返回”按钮，则ActivityA将恢复其状态。 当用户通过按Home键离开任务时，当前Activity将停止，其Task将进入后台。系统保留task中每个Activity的状态。如果用户稍后通过选择开始任务的启动器图标来恢复任务，则任务将到达前台并在堆栈顶部恢复Activity。 如果用户按下“返回”按钮，则会从堆栈中弹出当前Activity并将其销毁，堆栈中的之前的Activity会被恢复，当Activity被销毁时，系统不会保留Activity的状态。 Activity可以被多次实例化，甚至可以从其他Task实例化。 导航设计:有关Android导航如何在Android上运行的内容，请参阅Android Design's Navigation guide. 管理Tasks 如上所述Android管理Task和后台堆栈的方式：通过将所有Activity连续启动到同一Task和“后进先出”堆栈 ，该方式适用于大多数应用程序，你不必关于您的Activity如何与Task相关联或它们如何存在于后台堆栈中。但是，您可能有需求改变这种默认的的Task操作方式，比如也许您希望应用程序中的Activity在启动时开始新Task（而不是放在当前Task中），或者，当你开始一个Activity时，你想要复用它已有的实例（而不是在堆栈顶部创建一个新的实例），或者，您希望在用户离开Task时清除除了根Activity之外的所有Activity的回退堆栈。 您可以使用清单元素中的属性以及传递给startActivity（）的intent中的标记来设置上述操作。 在这方面，您可以使用的主要属性有： taskAffinity launchMode allowTaskReparenting clearTaskOnLaunch alwaysRetainTaskState finishOnTaskLaunch 你主要可以使用的Intent flag有： FLAG_ACTIVITY_NEW_TASK FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_SINGLE_TOP 在以下部分，您将了解如何使用这些清单属性和Intent标志来定义Activity与Task的关联方式以及它们在后台堆栈中的行为方式。 另外，会单独讨论如何在“最近”屏幕中表示和管理Task和Activity的注意事项。有关详细信息，请参阅Recents Screen 。通常，您应该允许系统在“最近”屏幕中定义您的Task和Activity的表示方式，而不需要修改此行为。 警告：大多数应用程序不应该更改Activity和Task的默认行为。如果您确定您的Activity需要修改默认的行为，请谨慎操作并确保在启动期间使用“返回”按钮以及从其他Activity和Task导航回Activity时测试Activity的可用性。请务必测试可能与用户预期行为冲突的导航行为。 指定运行模式 运行模式允许你设置一个新的Activity实例如何与当前Task建立关联，你可以通过两种方式设置不同的运行模式： 通过manifest文件 当你在manifest中注册了你的Activity，你可以设定该Activity的默认启动模式 使用Intent flags 当你调用startActivitu（）时你可以在Intent中设置flag来指定新的Activity如何与当前Task建立关联 因此，如果Activity A启动Activity B，Activity B可以在其清单中定义它应该如何与当前Task相关联，Activity A也可以请求Activity B应该如何与当前Task相关联。如果两个Activity都定义了Activity B应该如何与Task相关联，则Activity A的发起的请求（如意图中所定义）将向Activity B定义的方式妥协（即如以Activity B的清单中所定义的方式为执行标准）。 注意：manifest文件可用的某些启动模式不可用作intent的标志，同样，某些启用模式可用作intent的标志，无法在manifest中定义。 使用manifest文件 通过在manifest文件中指定元素的lanchMode属性，你可以指定该Activity与Task建立关联的方式。 launchMode属性指定了对应Activity以何种方式运行进Task中。你可以为launchMode指定以下四种启动模式： ”standard“（默认的启动模式） 默认情况下就是这个启动模式，当该Activity被启动或者一个Intent想要启动它时系统会新建一个该Activity的实例。该Activity可以被多次实例化，内一个实例可以属于不同的Task，同时一个Task也可以有多个该Activity的实例。 ”singleTop“ 如果需要导航到某个Activity而当前Task的栈顶广告存在一个该Activity的实例，那么系统会通过调用onNewIntent()方法将Intent导航到该Activity 实例而不是去创建一个新的Activity实例。处于这种启动模式的Activity可以被实例化多次，每一个实例可以属于不同的Task，并且每一个Task也可以拥有多个实例，但是仅限于回退栈的栈顶的不是该Activity的实例。 比如，一个以Activity A为栈底，栈中拥有B、C，栈顶为D的回退栈(栈中Activity实例的顺序是A-B-C-D，D是栈顶)，当一份Intent想要导航到D，如果D的启动模式是默认的\"Standard\"，那么一个新的Activity D将会被实例化，回退栈也将变为A-B-C-D-D。然而，如果D Activity的启动模式时\"singleTop\"，那么已经存在在栈顶的D Activity实例将会通过被调用onNewIntent（）收到一个Intent意图而不会新实例化一个D Activity并将其push到栈顶，因为当前栈顶是D Activity。但是如果当前的Intent的目标是B Activity，那么系统仍然会实例化一个新的B Activity，及时B Activity的启动模式时\"singleTop\"(因为B Activity此时不在栈顶)。 注意：当一个新的Activity实例被创建后，用户可以点击Back按钮去回退到他之前的Activity，但是当一个Activity实例正在处理一个新的Intent意图时，在新的Intent到达onNewIntent()之前用户无法通过按\"Back\"按键返回到之前的状态。 ”singleTask“ 系统将会创建一个新的Task和一个新的Activity实例，并将该实例放置于搞Task对应栈的栈底。但是，如果一个Activity的实例已经存在于之前的Task栈，系统会通过调用已经存在的Activity实例的onNewIntent()方法将Intent传递到该Activity 实例中而不会去创建新的Activity实例，在同一时间内，只能存在一个该Activity的实例。 注意：尽管该Activity的实例会启动在一个新的task中，但是用户按了Back按钮后依然可以返回到用户的前一个Activity。 ”singleInstance“ 与\"singleTask\"类似，但是系统不会再存在该模式下Activity 实例的Task中再防止任何其他Activity的实例，该Activity对应的实例是对应Task的唯一元素，任何该模式下Activity的实例都会在一个单独的Task中启动。 另一个例子，Android浏览器应用程序声明Web浏览器的Activity应始终在其自己的Task中打开（通过在元素中指定singleTask启动模式）。这意味着，如果您的应用发出打开Android浏览器的Intent，则其Activity不会与您的应用中的Activity放在同一Task中。相反，要么为浏览器启动新Task，要么如果浏览器已经在后台运行Task，则该Task将被拿到前台处理新Intent。 无论Activity是在新Task中启动还是在与启动它的Activity相同的Task中启动，“Back”按钮始终会将用户带到上一个Activity。但是，对于启动指定singleTask启动模式的Activity，如果后台Task中存在该Activity的实例，则会将后台的Task带到前台，此时，后台堆栈会是之前前台对应Task的堆栈。图4说明了这种情况： 图四：从当前Task启动具有\"singleTask\"启动模式的Activity，如果该Activity已经是后台Task的一部分，那么整个后台堆栈将在当前Task之上出现。 想要了解更多关于启动模式的内容，请参阅元素的文档，该文档中讨论了更多关于启动模式和其他启动属性的内容。 注意：你在manifest中通过制定launchMode属性的方法指定Activity启动模式的目的也可以通过设置启动Intent的flag标志做到，下节将具体介绍。 使用Intent flag 在启动Activity时，你可以通过设置传递给startActivity()中Intent的flag标志来达到改变该Activity与Task建立关联的方式，具体的有下面几种标志(flags)： FLAG_ACTIVITY_NEW_TASK 在一个新的Task中启动Activity。如果你当前要启动的Activity已经有实例运行在已经存在的Task中，则对应的Task将会被带到前台，并且已经存在的Activity实例的onNewIntent()方法会被调用。 这个标志的作用和上节中讨论的\"singleTask\"启动模式的作用一样。 FLAG_ACTIVITY_SINGLE_TOP 如果被启动的Activity已经有一个实例在Task对应堆栈的栈顶，则已经存在的栈顶Activity实例会被调用其onNewIntent()方法而不是重新创建新的Activity实例。 这个标志和上节中讨论的\"singleTop\"启动模式的作用一样。 FLAG_ACTIVITY_CLEAR_TOP 如果要启动的Activity已经有实例A运行在当前的Task中，则堆栈中运行在A上面的所有Activity的实例将会被销毁（destroyed）这样A就会出现在栈顶，同时其onNewIntent（）方法也将会被调用。 这个flag标志没有对应的lunchMode属性值与其对应。 FLAG_ACTIVITY_CLEAR_TOP 标志经常与FLAG_ACTIVITY_NEW_TASK`标志一起使用，当同时使用这两个标志时，可以定位到另一个Task中存在的现有Activity实例 。 注意：如果一个Activity的launchMode是\"standard\"，那么即使使用本flag，系统还是会新建Activity是实例，而不是clear top。 处理affinity affinity属性指明了Activity属于哪个Task。默认情况下，同一应用程序中的所有Activity都具有同一个affinity。因此，默认情况下，同一个应用中的所有Activity都会处于同一Task中。但是，您可以修改Activity的默认affinity属性，在不同应用中定义的Activity可以使用同一个affinity，或者可以为同一应用中的Activity分配不同的Task affinity。 您可以使用元素的taskAffinity属性修改任何Activity的affinity。 taskAffinity属性采用字符串值，该值必须与元素中声明的默认包名唯一（which must be unique from the default package name declared in the element,），因为系统使用该名称来标识应用程序的默认Task affinity。 affinity在两种情况下起作用： 启动Activity的intent包含FLAG_ACTIVITY_NEW_TASK标志。 默认情况下，新Activity将启动在调用startActivity（）的Activity的Task中，即它被push到与调用者相同的后台栈中。但是，如果传递给startActivity（）的intent包含FLAG_ACTIVITY_NEW_TASK标志，则系统会查找另一个Task以容纳新Activity。如果已存在与新Activity具有相同affinity的Task，则会将Activity启动到该Task中，如果没有，它才新建一个新Task。 如果此标志导致Activity开始在了新的Task中并且用户按下Home按钮以离开它，则必须有某种方式让用户导航回Task。某些实体（例如通知管理器）总是在外部Task中启动Activity，从不将其启动到自己的Task中，因此它们总是将FLAG_ACTIVITY_NEW_TASK置于它们传递给startActivity（）的Intent中。如果您的Activity有可能被使用此标志的外部实体调用，请注意用户有一种独立的方式来返回已启动的Task，例如使用启动图标（launcher icon），因为Task的根Activity有一个CATEGORY_LAUNCHER intent filter，请参阅下面的“启动Task”部分。 当一个Activity的allowTaskReparenting属性设置为“true”时。 在这种情况下，当与Activity具有想用affinity属性的Task到达前台时，Activity可以从它开始的Task移动到它具有affinity属性的Task。 例如，假设报告天气状况的Activity被定义为旅行应用程序的一部分，它与同一应用程序中的其他Activity（默认的应用程序关联）具有相同的affinity，并允许使用此属性re-parenting 。当您的某个Activity启动报告天气状况的Activity时，它最初属于与您的Activity相同的Task（Task A）。但是，当旅行应用程序的Task（Task B）到达前台时，天气报告者Activity将重新分配给该Task（Task B）并显示在其中。 提示：如果APK文件从用户的角度包含多个“app”，您可能希望使用taskAffinity属性为与每个“app”关联的Activity分配不同的affinity。 清除回退栈 如果用户长时间离开Task，系统将清除Task的除了根Activity之外的所有Activity。当用户再次返回Task时，仅恢复根Activity。系统以这种方式运行，因为在很长一段时间之后，用户可能已经放弃了之前正在做的事情，返回Task只是为了做新的事情。 您可以使用一些Activity属性来修改此行为： alwaysRetainTaskState 如果在Task的根Activity中将此属性设置为“true”，则不会发生刚刚描述的默认行为。即使经过很长一段时间，Task仍会保留堆栈中的所有Activity。 clearTaskOnLaunch 如果在Task的根Activity中将此属性设置为“true”，则只要用户离开Task，就会将堆栈清除为仅剩根Activity。换句话说，它与alwaysRetainTaskState相反。即使在离开Task片刻之后，用户也始终返回初始状态的Task。 finishOnTaskLaunch 此属性类似于clearTaskOnLaunch，但它在单个Activity上起作用，而不是在整个Task上起作用。它可以导致任何Activity消失，包括根Activity。当它设置为“true”时，Activity仍然只是当前会话的Task的一部分。如果用户离开然后返回Task，则它不再存在（即设置了谁，谁就被清除）。 开启一个task 你可以将某一个Activity设置为Task的入口点，方法是为其指定intent filter，其中“android.intent.action.MAIN”指定操作，“android.intent.category.LAUNCHER”指定类别，比如： ... 这种intent filter会导致Activity的icon和label显示在应用程序启动器中，从而为用户提供启动Activity的方法，并在启动后随时返回创建的Task。 第二种作用很重要：用户离开Task后，必须可以使用此Activity启动器返回该Task。因此，仅当Activity具有ACTION_MAIN和CATEGORY_LAUNCHER属性时，才能够将Activity标记为始终启动新Task的两种启动模式：“singleTask”和“singleInstance”。想象一下，例如，如果intent filter丢失会发生什么：一个intent启动一个“singleTask” Activity，启动一个新Task，并且用户花费一些时间在该Task中工作。然后用户按下主页按钮。该Task现在被调整到后台并且不可见。现在用户无法返回Task，因为它未在应用启动器中显示。 对于您不希望用户能够返回Activity的情况，请将元素的finishOnTaskLaunch设置为“true”（请参阅清除回退栈）。 有关如何在“Overview”屏幕中表示和管理Task和Activity的更多信息，请参阅 Recents Screen. 更多资源 Android Design: Navigation `` manifest element Recents Screen Multitasking the Android Way "},"Activity/进程和应用程序的生命周期.html":{"url":"Activity/进程和应用程序的生命周期.html","title":"进程和应用程序的生命周期","keywords":"","body":"进程和应用程序的生命周期 原文(英文)地址 在大多数情况下，每一个Android应用程序都是一个独立的Linux进程，这个进程在一些代码需要被运行时被创建，一直存活到该进程不再被需要且系统需要清理该进程以腾出更多的内存给其他应用程序使用。 Android应用程序一个基本的、不同一般程序的特性是一个Android应用程序的生命周期不能被该应用程序直接控制，相反的，它的生命周期由系统决定，系统根据系统知道正在运行的应用程序部分的组合，这些应用程序对用户的重要性以及系统中可用的总体内存来确定。 开发人员应该了解不同应用组件（特别是Activity、Service、BroadCastReceiver）对应用进程生命周期的影响。不正确地使用这些组件可能会导致系统杀死正在执行重要工作的应用进程。 关于进程生命周期导致bug的一个很常见的例子是BroadCastReceiver，当它在自己的onReceive()方法中接收到Intent并启动一个线程后return，一旦return，系统会认为BroadCastReceiver不再处于活动状态，因此不再需要托管该进程(除非其他应用程序组件依然处于活动状态)，系统随时可能会终止进程以回收内存，这样就会终止之前在进程中onReceive()启动的线程，会破坏该线程中原本应该执行的工作。这个文艺的解决方案通常是从BroadCastReceiver中使用一个JobService，这样系统就可以知道该进程中仍有未完成的工作。 为了确定哪些进程在内存紧张的时候应该被销毁，Android根据进程中正在运行的组件以及这些组件的状态将进程划分为不同的\"重要等级\"，按照重要程度依次有以下等级： 前台进程(foreground process) 前台进程是用户当前正在执行的操作所必需的进程。各种应用程序组件可以使其宿主进程以不同的方式被视为前台进程。如果满足以下任何条件，则认为进程处于前台： 进程中有一个用户正在关注的Activity在运行(该Activity的onResume()方法已经被调用) 进程中有一个BroadCastReceiver正在被运行(该BroadCastReceiver的onReceive()方法正在被执行) 进程中有一个Service且其某一个回调方法正在被执行(Service.onCreate(),Service.onStart(),Service.onDestroy()) 系统中只会有数量很少的这样的进程，如果内存太低甚至这些进程都不能继续运行，这些只会作为最后的进程被杀死。通常，此时，设备已达到内存分页状态，因此需要杀死这些进程以保持用户界面正常响应。 可见进程(visible process) 可见进程正在进行用户当前意识到的工作，因此杀死它会对用户体验产生明显的负面影响。符合以下条件的进程即为可见进程： 进程中有Activity对用户可见但是不在前台(对应Activity的onPause()已经被调用)。比如Activity被DIalog部分覆盖。 进程中通过Service.startForground（）启动了在前台运行的Service(这要求系统将服务视为用户可意识到的或基本上对用户可见的东西) 进程正在托管系统用于用户知道的特定功能的服务，例如动态壁纸，输入法服务等。 在系统中运行的可见进程的数量比前台进程更少，但仍然是相对受控的。这些进程被认为是非常重要的，除非为了保持所有前台进程运行，否则不会被杀死这些可见进程。 服务进程(service process) 服务进程是一个持有使用startService（）方法启动的服务的进程。虽然用户无法直接看到这些进程，但它们通常是用户关心的事情（例如后台网络数据上传或下载），因此系统将始终保持此类进程运行，除非没有足够的内存来保留所有前台进程和可见进程。 已经运行了很长时间（例如30分钟或更长时间）的Service可能会降级，以允许其进程被添加到下面描述的缓存LRU列表。这有助于避免出现内存泄漏或其他原因比如长时间运行服务占用大量RAM而导致系统无法有效使用缓存进程的情况。 缓存进程(cached process) 缓存进程是当前不需要的进程，因此当其他地方需要内存时，系统可以根据需要自由地终止缓存进程。在正常运行的系统中，这些是内存管理中涉及的唯一进程：运行良好的系统将始终具有多个缓存进程（用于在应用程序之间进行更有效的切换），并根据需要定期终止最旧的进程。只有在非常关键（且不可取）的情况下，系统才会杀死所有缓存进程，并且必须开始终止服务进程。 这些进程通常包含一个或多个当前对用户不可见的Activity实例（已调用并返回onStop（）方法）。如果他们正确地实现了他们的活动生命周期（请参阅Activity以获取更多详细信息），当系统杀死此类进程时，它不会影响用户返回该应用程序时的体验：它可以在重新创建关联Activity时恢复以前保存的状态一个新的进程。 这些进程保存在伪LRU列表（pseudo-LRU list）中，列表中的最后一个进程是第一个被回收内存的进程。在此列表上排序的确切策略是平台的实现细节，但通常它会尝试在其他类型的进程之前保留更多有用的进程（一个托管用户的主应用程序，他们看到的最后一个Activity等）。还可以应用其他用于终止进程的策略：对允许的进程数量的硬限制，对进程可以持续缓存的时间量的限制等。 总结 在决定如何对进程进行分类时，系统将根据进程中当前起作用（活动）的所有组件中找到的最重要级别做出决策。有关每个组件如何对流程的整个生命周期做出贡献的更多详细信息，请参阅Activity，Service和 BroadcastReceiver文档。每个类的文档都更详细地描述了它们如何影响其应用程序的整个生命周期。 还可以基于进程对其具有的其他依赖性来增加进程的优先级。例如，如果进程A已使用Context.BIND_AUTO_CREATE标志绑定到Service，或者正在进程B中使用ContentProvider，则进程B的分类将始终至少与进程A一样重要。 "},"Activity/Parcelable和Bundle.html":{"url":"Activity/Parcelable和Bundle.html","title":"Parcelable和Bundle","keywords":"","body":"Parcelable和Bundle 原文(英文)地址 Parcelable和Bundle对象旨在跨进程使用，例如IPC / Binder事务，具有Intent的Activity之间，以及跨配置更改存储瞬态。此文档介绍有关使用Parcelable和Bundle对象的建议和最佳实践。 注意：Parcel不是通用的序列化机制，您绝不应将任何Parcel数据存储在磁盘上或通过网络发送。 不同Activity之间发送数据 当app创建一个Intent对象以通过startActivity(android.content.Intent)去启动一个新的Activity时，app可以通过putExtra(java.lang.String,java.lang.String)传递参数给新的Activity。 以下代码演示了如何进行该操作： kotlin val intent = Intent(this, MyActivity::class.java).apply { putExtra(\"media_id\", \"a1b2c3\") // ... } startActivity(intent) java Intent intent = new Intent(this, MyActivity.class); intent.putExtra(\"media_id\", \"a1b2c3\"); // ... startActivity(intent); 系统包裹（编码，parcels）Intent的底层Bundle。然后，操作系统创建新Activity，之后解包（解码，un-parcels）Bundle，并将Intent传递给新Activity。 我们建议您使用Bundle类来传递操作系统已知的原语（primitives）对象。 Bundle类针对使用parcel的编码和解码进行了高度优化。 在某些情况下，您可能需要一种机制来跨Activity发送复合对象或复杂对象。在这种情况下，自定义类应该实现Parcelable，并提供正确的writeToParcel（android.os.Parcel，int）方法。它还必须提供一个名为CREATOR的非空字段，该字段实现Parcelable.Creator接口，其createFromParcel（）方法用于将Parcel转换回当前对象。有关更多信息，请参阅Parcelable对象的参考文档。 通过intent发送数据时，应注意将数据大小限制为几KB。发送过大数据可能导致系统抛出TransactionTooLargeException异常。 不同进程间发送数据 在进程之间发送数据和在Activity之间执行此操作类似。但是，在进程之间发送时，我们建议您不要使用自定义parcelables。如果您将自定义Parcelable对象从一个应用程序发送到另一个应用程序，则需要确保发送和接收应用程序上都存在完全相同的自定义类版本。通常，这可能是跨两个应用程序使用的公共库。如果您的应用尝试向系统发送自定义parcelable，则可能会发生错误，因为系统无法解码（unmarshal）它不知道的类。 例如，应用程序可能使用AlarmManager类设置alarm（警报），并在alarm Intent上使用自定义Parcelable。当闹钟响起时，系统会修改Intent的的Extras中的Bundle以添加重复计数。此修改可能导致系统从Extras中解析自定义的Parcelable对象。反过来，这种解析可能导致应用程序在收到修改后的alarm Intent时崩溃，因为应用程序希望接收不再存在的Extra数据。 Binder事务缓冲区具有有限的固定大小，目前是1MB，由进程正在进行的所有事务共享。由于此限制是在进程级别而不是在每个Activity级别，因此这些事务包括应用程序中的所有绑定事务，例如onSaveInstanceState，startActivity以及与系统的任何交互。超出大小限制时，将抛出TransactionTooLargeException。 对于savedInstanceState的特定情况，数据量应保持较小，因为只要用户可以导航回该Activity（即使Activity的进程被终止），系统进程就需要保持提供的数据。我们建议您将保存的状态保存在少于50k的数据中。 注意：在Android 7.0(API 24)及之后，系统会抛出TransactionTooLargeException异常，在之前版本的Android系统中，系统紧紧会在logcat打印一条警告。 "},"Activity/Fragment/Fragment概述.html":{"url":"Activity/Fragment/Fragment概述.html","title":"Fragment(概述)","keywords":"","body":"Fragment概述 原文(英文)地址 Fragment表示FragmentActivity中的行为或用户界面的一部分。您可以在单个Activity中组合多个以构建多窗格UI，并在多个Activity中重用Fragment。您可以将Fragment视为Activity的模块化部分，它具有自己的生命周期，接收自己的输入事件，并且可以在Activity运行时添加或删除（有点像“子Activity”，您可以在不同的Activity中重用）。 Fragment必须始终托管在Activity中，Fragment的生命周期直接受宿主Activity生命周期的影响。例如，当Activity暂停时，其中的所有Fragment也都会暂停，当Activity被破坏时，所有Fragment也都会被破坏。但是，当一个Activity正在运行时（它处于resumed的生命周期状态），您可以独立操作每个Fragment，例如添加或删除它们。执行此类Fragment事务时，还可以将其添加到由Activity管理的回退栈中—— Activity中的每个回退栈条目都是发生的Fragment事务的记录。回退栈允许用户通过按“返回”按钮来反转Fragment事务（向后导航）。 将Fragment添加为Activity布局的一部分时，它将位于Activity视图层次结构内的ViewGroup中，并且Fragment定义自己的视图布局。您可以通过将Activity的布局文件中的Fragment声明为元素，或者通过将其添加到现有ViewGroup，从应用程序代码中将Fragment插入到Activity布局中。 本文档描述了如何构建应用程序以使用Fragment，包括：Fragment添加到Activity的后台堆栈时如何维持其状态、在Activity中和别的Activity以及本Activity的其他Fragment通信，为Activity的应用栏做出贡献等等。 有关处理生命周期的信息，包括有关最佳实践的指导，请参阅以下资源： Handling Lifecycles with Lifecycle-Aware Components Guide to App Architecture Supporting Tablets and Handsets Fragment的设计哲学 Android在Android 3.0（API 11）中引入了Fragment，主要是为了在大屏幕（如平板电脑）上支持更加动态和灵活的UI设计。由于平板电脑的屏幕比手机屏幕大得多，因此组合和交换UI组件的空间更大。Fragment允许此类设计，而无需您管理对视图层次结构的复杂更改。通过将Activity的布局划分为Fragment，您可以在运行时修改Activity的外观，并将这些更改保留在由Activity管理的后台堆栈中。它们现在可以通过 fragment support library广泛使用。 例如，新闻应用程序可以使用一个Fragment显示左侧文章列表，另一个Fragment显示右侧文章 ——两个Fragment并排显示在一个Activity中，每个Fragment都有自己的生命周期及回调方法并处理自己的用户输入事件。因此，用户可以选择文章并在同一Activity中阅读，而不是使用一个Activity来选择文章和另一个Activity来阅读文章，如图1中的平板电脑布局所示。 图一：将由Fragment定义的两个UI模块组合成平板电脑设计的一个Activity，但是在手机上分开到两个Activity。 您应该将每个Fragment设计为模块化和可重用的Activity组件。也就是说，因为每个Fragment使用自己的生命周期回调定义自己的布局和自己的行为，所以可以在不同Activity中包含一个Fragment，因此您应该将您的Fragment设计为可重用的，并避免在一个Fragment中直接操作另一个Fragment。这一点尤其重要，因为模块化Fragment允许您根据不同屏幕大小更改Fragment的不同组合。在设计支持平板电脑和手机的应用程序时，您可以在不同的布局配置中重复使用Fragment，以根据可用的屏幕空间优化用户体验。例如，在手机上，当多个Fragment不能存在于同一Activity时，可能需要分离Fragment以提供单窗格UI。 我们还是以使用新闻应用程序为例，当在平板电脑大小级别的设备上运行时，应用程序可以在Activity A中嵌入两个Fragment。但是，在手机大小级别的屏幕上，两个Fragment都没有足够的空间，因此Activity A仅包含文章列表的片段，当用户选择文章时，它启动 Activity B，Activity B中包括要展示文章的第二个Fragment。因此，该应用程序通过重复使用不同组合的Fragment来支持平板电脑和手机，如图1所示。 有关使用不同屏幕配置的不同Fragment组合设计应用程序的详细信息，请参阅 Screen Compatibility Overview。 创建一个Fragment 图二：Fragment的生命周期（宿主Activity正在运行） 为了创建一个Fragment，你必须创建一个Fragment的子类(或者已经存在的Fragment的子类)。Fragment和Activity有类似的代码逻辑，其回调方法与Activity的回调方法类似，比如onCreate()，onStart()，onPause()，onStop()。事实上，如果你想将一个没有使用Fragment的app转化为使用Fragment的app，你也许可以简单地将你Activity毁掉方法里的代码移动到Fragment对应的回调方法中去即可。 一般来说，你至少需要实现以下生命周期对应的方法： onCreate() 创建Fragment的时候系统会调用此方法。在你的实现中你应该在此方法中初始化一些你想要在Fragment处于paused、stooped状态下需要的元素。 onCreateView() 在Fragment第一次绘制其用户界面的时候，系统会调用此方法。要绘制该Fragment的用户界面，必须在此方法中返回一个View对象，该View对象是Fragment布局的根View。如果该Fragment不提供UI，则可以返回null。 onPause() 系统将此方法称为用户离开Fragment的第一个标志(尽管不总是意味着该Fragment被Destroyed)。这通常是你应该保存在当前用户会话之外还想保存的数据(因为用户可能不再回来了) 大多数程序中的Fragment至少应该实现以上三个方法，但是你还可以使用一些其他的回调来处理Fragment生命周期的各个阶段。有关Fragment生命周期的详细介绍，请参考Handling the Fragment Lifecycle. 请注意，实现依赖组件的生命周期操作的代码应放在组件本身中，而不是直接放在Fragment回调实现中。请参阅 Handling Lifecycles with Lifecycle-Aware Components，以了解如何使您的从属组件感知生命周期。 这里再介绍几个Fragment的子类，你可能想要继承这些基类而不是直接继承Fragment： DialogFragment 显示一个悬浮的dialog。使用该类创建对话框是在Activity类中使用dialog helper的一个很好的替代方法，因为您可以将Fragment对话框合并到由Activity管理的Fragment的回退栈中，从而允许用户返回到已解散（dismissed）的Fragment。 ListFragment 显示由adapter管理的list（例如SimpleCursorAdapter），类似于ListActivity。它提供了几种管理列表视图的方法，例如onListItemClick（）回调来处理点击事件。 （请注意，显示list的首选方法是使用RecyclerView而不是ListView。在这种情况下，您需要创建一个在其布局中包含RecyclerView的Fragmrnt。请参阅 Create a List with RecyclerView 以了解更多内容。） 添加一个用户界面 Fragment通常用作Activity用户界面的一部分，为Activity提供自己的布局。 要为Fragment提供布局，必须实现onCreateView（）回调方法，当Fragment绘制其布局时，Android系统会调用该方法。您对此方法的实现必须返回一个View，它是Fragment布局的根（root view）。 注意：如果你的Fragment事ListFragment的子类，那么默认情况下你Fragment的onCreatView()返回一个ListView，所以你不再需要实现该方法。 为了从onCreateView()中返回一个View，你可以从layout resource下定义的xml文件中inflate到View。为了帮助你做这件事，onCreateView()中提供了一个LayoutInflater对象。 比如，有一个Fragment的子类需要从example_fragment.xml文件加载View： kotlin class ExampleFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { // Inflate the layout for this fragment return inflater.inflate(R.layout.example_fragment, container, false) } } java public static class ExampleFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.example_fragment, container, false); } } 注意：在上例中，R.layout.example_fragment是一个存储在应用resources资源下的名为example_fragment.xml的layout资源的引用。关于如何创建layout xml文件的更多信息，请参阅 User Interface onCreateView()中的container参数是父ViewGroup(来自Activity 的layout)，你的Fragment就插入在该ViewGroup中。saveInstanceState参数是一个Bundle对象，提供了Fragment前一个实例的数据(在 Handling the Fragment Lifecycle中更详细地讨论了如何恢复Fragment之前的状态) inflate()方法接收三个参数： 想要inflate的layout文件的id 作为父View的ViewGroup。传递container参数非常重要，该参数使得系统可以将布局参数应用于inflated布局的根视图，其所在的父视图指定。 一个布尔值，指示在inflate期间是否应将inflated的布局附加到ViewGroup（第二个参数）。 （在这种情况下，该参数的值为false，因为系统已经将inflated的布局插入到container中 - 传递true会在最终布局中创建冗余的ViewGroup） 现在你已经学会如何为创建的Fragment添加布局了，下一节介如何将Fragment添加到Activity中。 将Fragment添加到Activity中 通常，一个Fragment作为一个宿主Activity的一部分，这里有两种方法将Fragment添加到Activity中： 在activity的layout文件中声明fragment 这种情况下，你可以将fragment当做一个view一样为他指定参数，比如： 在中的android：name属性指定要在布局中实例化的Fragment类。 当系统创建此Activity布局时，它会实例化布局中指定的每个Fragment，并为每个Fragment调用onCreateView（）方法，以检索每个Fragment的布局。系统直接插入Fragment返回的View代替元素。 注意：每个Fragment都需要一个唯一的标识符，如果重新启动Activity，系统可以使用该标识符来恢复Fragment（您可以使用它来捕获Fragment以执行事务，例如删除它）。有两种方法可以为片段提供ID： android：id android：tag 使用代码将Fragment添加到已经存在的ViewGroup中 在你Activity运行的任意时刻，你都可以将Fragment添加到你Activity的布局中，你只需要指定一个ViewGroup来防止Fragment。 要在Activity进行Fragment事物操作(比如添加、删除、替换Fragment)，必须使用FragmentTransaction中的API，你可以从FragmentActivity中获取FragmentTransaction的实例，比如： kotlin val fragmentManager = supportFragmentManager val fragmentTransaction = fragmentManager.beginTransaction() java ExampleFragment fragment = new ExampleFragment(); fragmentTransaction.add(R.id.fragment_container, fragment); fragmentTransaction.commit(); add（）方法中传递的第一个参数是ViewGroup对应的id，第二个参数是被添加的Fragment对象。 当你使用FragmentTransaction作出更改后，你必须调用commit()去让你的更改生效。 管理Fragment 为了管理你Activity中的Fragment，你必须使用FragmentManager。为了得到它的实例，你应该在你的Activity中调用getSupportFragmentManager()方法。 你可以用FragmentManager做的操作包括： 获取Activity中已经存在的Fragment实例，使用findFragmentById()(对于声明在layout布局文件中的Fragment)，或者findFragmentByTag()(对于没有声明在layout布局文件中的Fragment) 从回退栈中弹出Fragment，使用popBackStack(就像用户按了Back键) 注册一个监听回退栈变化的监听器，使用addOnBackStackChangedListener() 更多的内容请参考FragmentManager类的文档。 ​ 如上一节介绍了，你也可以使用FragmentManager开启一个FragmentTransaction以执行你的事物，比如添加或者移除Fragment。 执行Fragment事物 在您的Activity中使用Fragment的一个很棒的特点是能够添加，删除，替换和执行其他操作，以响应用户交互。您为Activity提交的每组更改都称为事务，您可以使用FragmentTransaction中的API执行一项更改。您还可以将每个事务保存到由Activity管理的后台，允许用户向后导航Fragment的更改（类似于向后导航活动）。 你可以使用FragmentManager开启一个FragmentTransaction事物： kotlin val fragmentManager = supportFragmentManager val fragmentTransaction = fragmentManager.beginTransaction() java FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 每个事务都是您要同时执行的一组更改。您可以使用add（），remove（）和replace（）等方法设置要为给定事务执行的所有更改。然后，要将事务应用于Activity，必须调用commit（）。 但是，在调用commit（）之前，可能需要调用addToBackStack（），以便将事务添加到Fragment事务的回退栈中。此后回退栈由Activity管理，并允许用户通过按“Back”按钮返回到先前的Fragment状态。 比如，这里展示了如何使用一个fragment替换另一个fragment，同时保留前一个回退栈的状态： kotlin val newFragment = ExampleFragment() val transaction = supportFragmentManager.beginTransaction() transaction.replace(R.id.fragment_container, newFragment) transaction.addToBackStack(null) transaction.commit() java // Create new fragment and transaction Fragment newFragment = new ExampleFragment(); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Replace whatever is in the fragment_container view with this fragment, // and add the transaction to the back stack transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); // Commit the transaction transaction.commit(); 在这个例子中，newFragment替换当前在R.id.fragment_container ID标识的布局容器中的任何Fragment（如果有）。通过调用addToBackStack（），替换事务将保存到回退栈，因此用户可以通过按“Back”按钮来反转事务并恢复前一个Fragment。 FragmentActivity然后通过onBackPressed（）自动从回退栈中检索Fragment。 如果向事务添加多个更改（例如另一个add（）或remove（））并调用addToBackStack（），则在调用commit（）之前应用的所有更改都将作为单个事务添加到回退栈中，点击Back按钮时的效果和之前的顺序相反。 将更改添加到FragmentTransaction的顺序无关紧要，除了： 你必须在最后调用commit() 如果要将多个Fragment添加到同一容器中，则添加它们的顺序将决定它们在视图层次结构中的显示顺序。 调用commit（）不会立即执行事务。相反，它会在线程能够执行时将其安排在activity的UI线程（“主”线程）上运行。但是，如果需要，您可以从UI线程调用executePendingTransactions（）以立即执行commit（）提交的事务。除非事务是其他线程中任务的依赖项，否则通常不需要这样做。 警告：只有在Activity保存其状态（用户离开Activity时）之前，才能使用commit（）提交事务。如果在该点之后尝试提交，则抛出异常。这是因为如果需要恢复Activity，则提交后的状态可能会丢失。对于可以丢失提交的情况，请使用commitAllowingStateLoss（）。 与Activity通信 尽管Fragment是作为独立于FragmentActivity的对象实现的，并且可以在多个Activity中使用，但是Fragment的给定实例直接与托管它的Activity相关联。 具体来说，Fragment可以使用getActivity（）访问FragmentActivity实例，并轻松执行任务，例如在Activity布局中查找View: Kotlin val listView: View? = activity?.findViewById(R.id.list) java View listView = getActivity().findViewById(R.id.list); 类似的，你的Activity也可以由FragmentManager的findFragmentById()方法或者findFragmentByTag()方法获取Fragment实例，进而调用该Fragment的的方法，比如： kotlin val fragment = supportFragmentManager.findFragmentById(R.id.example_fragment) as ExampleFragment java ExampleFragment fragment = (ExampleFragment) getSupportFragmentManager().findFragmentById(R.id.example_fragment); 创建Activity的事件回调 有时你也许需要从fragment中发送数据或事件给宿主activity或者其他寄存在宿主activity中的fragment。为了发送数据，可以创建一个共享的ViewModel，如ViewModel guide中fragment之间共享数据部分所述。如果需要传播无法使用ViewModel处理的事件，则可以在Fragment内定义回调接口，并要求宿主Activity实现它。当Activity通过接口收到回调时，它可以根据需要与将数据与布局中的其他Fragment共享。 例如，如果新闻应用程序在Activity中有两个Fragment，一个用于显示文章列表（FragmentA）而另一个用于显示文章详情（FragmentB），那么FragmentA必须在选择列表项时告知Activity FragmentB应该显示的文章。在这种情况下，可以在FragmentA中声明OnArticleSelectedListener接口： kotlin public class FragmentA : ListFragment() { ... // Container Activity must implement this interface interface OnArticleSelectedListener { fun onArticleSelected(articleUri: Uri) } ... } java public static class FragmentA extends ListFragment { ... // Container Activity must implement this interface public interface OnArticleSelectedListener { public void onArticleSelected(Uri articleUri); } ... } 然后宿主Activity应该实现(implement) OnArticleSelectedListener接口并且实现onArticleSelected()以将Fragment A发送的事件通知给fragment B，为了确保宿主Activity实现了该接口，Fragment A的onAttach()方法(该方法会在系统将Fragment加入到Activity中时调用)中通过强制转化传递给onAttach()的Activity来实例化OnArticleSelectedListener的实例： kotlin public class FragmentA : ListFragment() { var listener: OnArticleSelectedListener? = null ... override fun onAttach(context: Context) { super.onAttach(context) listener = context as? OnArticleSelectedListener if (listener == null) { throw ClassCastException(\"$context must implement OnArticleSelectedListener\") } } ... } java public static class FragmentA extends ListFragment { OnArticleSelectedListener listener; ... @Override public void onAttach(Context context) { super.onAttach(context); try { listener = (OnArticleSelectedListener) context; } catch (ClassCastException e) { throw new ClassCastException(context.toString() + \" must implement OnArticleSelectedListener\"); } } ... } 如果宿主Activity没有实现该接口，则Fragment A会抛出一个ClassCastException。如果宿主Activity实现了该接口，则FragmentA就会有一个listener就会作为实现了OnArticleSelectedListener接口的Activity的引用，所以Fragment A可以通过调用在OnArticleSelectedListener中定义的方法以发送消息到宿主Activity。比如，Fragment A是ListFragment的子类，当用户点击了list的item，系统会回调Fragment A中的onListItemClick()方法，在此时可以通过回调listener的onArticleSelected()方法以将事件传递给宿主Activity： kotlin public class FragmentA : ListFragment() { var listener: OnArticleSelectedListener? = null ... override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) { // Append the clicked item's row ID with the content provider Uri val noteUri: Uri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id) // Send the event and Uri to the host activity listener?.onArticleSelected(noteUri) } ... } java public static class FragmentA extends ListFragment { OnArticleSelectedListener listener; ... @Override public void onListItemClick(ListView l, View v, int position, long id) { // Append the clicked item's row ID with the content provider Uri Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id); // Send the event and Uri to the host activity listener.onArticleSelected(noteUri); } ... } onListItemClick()中的形参id是被点击的item的缩在行的下标，宿主Activity(或者其他Fragment)可以通过它从应用的ContentProvider中获取文章详情。 关于ContentProvider的更多信息请参阅 Content Providers。 向App Bar中添加条目(items) 您的Fragment可以通过实现onCreateOptionsMenu（）将menu items提供给Activity的“ Options Menu”（以及应用程序栏）。但是，为了使此方法可以被调用，您必须在onCreate（）中调用setHasOptionsMenu（），以指示该Fragment要将item添加到Options Menu。否则，Fragment不会接收对onCreateOptionsMenu（）的调用。 然后，您从Fragment添加到“Options Menu”的任何项目都将附加到现有menu items。当选择菜单项时，Fragment还接收对onOptionsItemSelected（）的回调。 您还可以在Fragment布局中注册View，以通过调用registerForContextMenu（）来提供上下文菜单（context menu）。当用户打开上下文菜单时，Fragment将接收对onCreateContextMenu（）的调用。当用户选择一个项目（item）时，该Fragment接收对onContextItemSelected（）的调用。 注意：虽然您的Fragment会为其添加的每个菜单项添加项目选择的回调，但当用户选择菜单项时，Activity首先接收相应的回调。如果Activity的项目选择回调的实现方法不处理所选项目，则事件将传递给Fragment的回调。Options Menu 和 context menus.也是如此。 关于菜单(menu)的更多信息，请参阅 Menus 开发者手册以及 App Bar 类. 监听Fragment的生命周期 图三：activity生命周期对fragment生命周期的影响 管理Fragment的生命周期和管理Activity的生命周期类似，Fragment和Activity一样含有以下三个状态： Resumed Fragment可见（正在运行的宿主Activity中） Paused 另一个Activity正处于前台且占有焦点但是宿主Activity依然可见(没有焦点，被部分覆盖) Stopped Fragment不可见。宿主Activity被停止(stooped)或者Fragment被从Activity中移除但已经被加入到了回退栈。被停止的Fragment依然是活着的(alive)(所有状态和成员信息由系统保留)，但是，他不在对用户可见，并且如果宿主Activity被杀死(kill)，则他也会被杀死。 和Activity一样，您可以使用onSaveInstanceState（Bundle），ViewModel和持久化本地存储的组合，跨配置更改（across configuration changes ）保留Fragment的UI状态。要了解有关保留UI状态的更多信息，请参阅Saving UI States。 Activity和Fragment生命周期的最显着的差异是如何将其存储在其各自的后台堆栈中。默认情况下，Activity停止（stopped）时被置于由系统管理的Activity的后堆栈中（以便用户可以使用“Back”按钮导航回到它，如 理解Task和回退栈 中所述）。但是，只有当您在执行删除Fragment的事务时通过调用addToBackStack（）显式请求保存实例时，系统才会将Fragment放入由宿主Activity管理的后台堆栈中。 请参阅Activity生命周期和Handling Lifecycles with Lifecycle-Aware Components，以了解有关Activity生命周期和管理的更多信息。 警告：如果你需要在你的Fragment中使用Context对象，你可以调用getContext()方法。但是，仅仅当你的Fragment附加到（attached）宿主Activity之后你才可以谨慎地调用getContext()。当Fragment尚未附加到Activity中，或者其在生命周期结束的时候被Detached，getContext()hi返回null； 与Activity的生命周期进行协调 Fragment所在的宿主Activity的生命周期会直接影响Fragment的生命周期，因此Activity的每个生命周期回调都会为每个Fragment产生类似的回调。例如，当Activity收到onPause（）时，Activity中的每个Fragment都会收到onPause（）。 但是，Fragment有一些额外的生命周期回调，它们处理与Activity的唯一交互，以便执行构建和销毁Fragment的UI等操作。这些额外的回调方法是： onAttach() 当Fragment与Activity关联时调用(宿主Activity会被当做形参传入) onCreateView() 调用以创建与Fragment关联的视图层次结构。 onActivityCreated() 当Activity的onCreate() 方法返回时被调用。 onDestroyView() 当与Fragment关联的视图层次结构被移除时调用。 onDetach() 当Fragment与Activity解除关联时调用。 图3说明了Fragment生命周期的流程，因为它受宿主Activity的影响。在此图中，您可以看到Activity的每个连续状态如何确定Fragment可以接收哪些回调方法。例如，当Activity收到onCreate（）回调时，Activity中的Fragment只接收onActivityCreated（）回调。 一旦Activity达到Resumed状态，您就可以自由地向Activity添加和删除Fragment。因此，只有当Activity处于Resumed状态时，Fragment的生命周期才能独立地改变。 但是，当Activity离开Resumed状态时，Fragment再次被Activity推送到其自己的生命周期。 例子 为了将本文档中讨论的所有内容放在一起，下面是使用两个Fragment创建双窗格布局的Activity示例。下面的Activity包括一个Fragment，用于显示莎士比亚戏剧标题列表，另一个用于显示从列表中选择的播放摘要。它还演示了如何根据屏幕配置提供不同的Fragment配置。 注意：完整的源码见 sample app ，该源码展示了如何使用FragmentLayout kotlin override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.fragment_layout) } java @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.fragment_layout); } fragment_layout.xml布局文件如下： 使用此layout，系统会在Activity加载layout时实例化TitlesFragment（列出播放标题），而FrameLayout（用于显示播放摘要的Fragment）会占据屏幕右侧的空间，但是起初仍然是空的。正如您将在下面看到的那样，直到用户从列表中选择一个Fragment放入FrameLayout中。 但是，并非所有屏幕都足够宽，以便并排显示播放列表和摘要。因此，上面的布局仅用于横向屏幕配置，方法是将其保存在res / layout-land / fragment_layout.xml中。 因此，当屏幕处于纵向时，系统将应用以下布局，该布局保存在res / layout / fragment_layout.xml中： 此布局仅包含TitlesFragment。这意味着，当设备处于纵向方向时，只能看到播放标题列表。因此，当用户单击此配置中的列表项时，应用程序将启动一个新Activity以显示摘要，而不是加载第二个Fragment。 接下来，您可以看到如何在Fragment类中完成此操作。首先是TitlesFragment，它显示了莎士比亚戏剧名单。此Fragment继承了ListFragment并依赖它来处理大多数列表视图工作。 在查看此代码时，请注意当用户单击列表项时有两种可能的行为：根据两个布局中的哪一个处于生效状态，它可以创建并显示一个新Fragment以显示同一Activity中的详细信息（添加片段到FrameLayout），或者开始一个新的Activity（Fragment中的内容可以显示在该Activity中）。 kotlin class TitlesFragment : ListFragment() { private var dualPane: Boolean = false private var curCheckPosition = 0 override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // Populate list with our static array of titles. listAdapter = ArrayAdapter( activity, android.R.layout.simple_list_item_activated_1, Shakespeare.TITLES ) // Check to see if we have a frame in which to embed the details // fragment directly in the containing UI. val detailsFrame: View? = activity?.findViewById(R.id.details) dualPane = detailsFrame?.visibility == View.VISIBLE curCheckPosition = savedInstanceState?.getInt(\"curChoice\", 0) ?: 0 if (dualPane) { // In dual-pane mode, the list view highlights the selected item. listView.choiceMode = ListView.CHOICE_MODE_SINGLE // Make sure our UI is in the correct state. showDetails(curCheckPosition) } } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) outState.putInt(\"curChoice\", curCheckPosition) } override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) { showDetails(position) } /** * Helper function to show the details of a selected item, either by * displaying a fragment in-place in the current UI, or starting a * whole new activity in which it is displayed. */ private fun showDetails(index: Int) { curCheckPosition = index if (dualPane) { // We can display everything in-place with fragments, so update // the list to highlight the selected item and show the data. listView.setItemChecked(index, true) // Check what fragment is currently shown, replace if needed. var details = fragmentManager?.findFragmentById(R.id.details) as? DetailsFragment if (details?.shownIndex != index) { // Make new fragment to show this selection. details = DetailsFragment.newInstance(index) // Execute a transaction, replacing any existing fragment // with this one inside the frame. fragmentManager?.beginTransaction()?.apply { if (index == 0) { replace(R.id.details, details) } else { replace(R.id.a_item, details) } setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE) commit() } } } else { // Otherwise we need to launch a new activity to display // the dialog fragment with selected text. val intent = Intent().apply { setClass(activity, DetailsActivity::class.java) putExtra(\"index\", index) } startActivity(intent) } } } java public static class TitlesFragment extends ListFragment { boolean dualPane; int curCheckPosition = 0; @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); // Populate list with our static array of titles. setListAdapter(new ArrayAdapter(getActivity(), android.R.layout.simple_list_item_activated_1, Shakespeare.TITLES)); // Check to see if we have a frame in which to embed the details // fragment directly in the containing UI. View detailsFrame = getActivity().findViewById(R.id.details); dualPane = detailsFrame != null && detailsFrame.getVisibility() == View.VISIBLE; if (savedInstanceState != null) { // Restore last state for checked position. curCheckPosition = savedInstanceState.getInt(\"curChoice\", 0); } if (dualPane) { // In dual-pane mode, the list view highlights the selected item. getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE); // Make sure our UI is in the correct state. showDetails(curCheckPosition); } } @Override public void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); outState.putInt(\"curChoice\", curCheckPosition); } @Override public void onListItemClick(ListView l, View v, int position, long id) { showDetails(position); } /** * Helper function to show the details of a selected item, either by * displaying a fragment in-place in the current UI, or starting a * whole new activity in which it is displayed. */ void showDetails(int index) { curCheckPosition = index; if (dualPane) { // We can display everything in-place with fragments, so update // the list to highlight the selected item and show the data. getListView().setItemChecked(index, true); // Check what fragment is currently shown, replace if needed. DetailsFragment details = (DetailsFragment) getSupportFragmentManager().findFragmentById(R.id.details); if (details == null || details.getShownIndex() != index) { // Make new fragment to show this selection. details = DetailsFragment.newInstance(index); // Execute a transaction, replacing any existing fragment // with this one inside the frame. FragmentTransaction ft = getSupportFragmentManager().beginTransaction(); if (index == 0) { ft.replace(R.id.details, details); } else { ft.replace(R.id.a_item, details); } ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_FADE); ft.commit(); } } else { // Otherwise we need to launch a new activity to display // the dialog fragment with selected text. Intent intent = new Intent(); intent.setClass(getActivity(), DetailsActivity.class); intent.putExtra(\"index\", index); startActivity(intent); } } } 第二个Fragment，DetailsFragment展示了从TitlesFragment中选择的播放摘要： kotlin class DetailsFragment : Fragment() { val shownIndex: Int by lazy { arguments?.getInt(\"index\", 0) ?: 0 } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { if (container == null) { // We have different layouts, and in one of them this // fragment's containing frame doesn't exist. The fragment // may still be created from its saved state, but there is // no reason to try to create its view hierarchy because it // isn't displayed. Note this isn't needed -- we could just // run the code below, where we would create and return the // view hierarchy; it would just never be used. return null } val text = TextView(activity).apply { val padding: Int = TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_DIP, 4f, activity?.resources?.displayMetrics ).toInt() setPadding(padding, padding, padding, padding) text = Shakespeare.DIALOGUE[shownIndex] } return ScrollView(activity).apply { addView(text) } } companion object { /** * Create a new instance of DetailsFragment, initialized to * show the text at 'index'. */ fun newInstance(index: Int): DetailsFragment { val f = DetailsFragment() // Supply index input as an argument. val args = Bundle() args.putInt(\"index\", index) f.arguments = args return f } } } } java public static class DetailsFragment extends Fragment { /** * Create a new instance of DetailsFragment, initialized to * show the text at 'index'. */ public static DetailsFragment newInstance(int index) { DetailsFragment f = new DetailsFragment(); // Supply index input as an argument. Bundle args = new Bundle(); args.putInt(\"index\", index); f.setArguments(args); return f; } public int getShownIndex() { return getArguments().getInt(\"index\", 0); } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { if (container == null) { // We have different layouts, and in one of them this // fragment's containing frame doesn't exist. The fragment // may still be created from its saved state, but there is // no reason to try to create its view hierarchy because it // isn't displayed. Note this isn't needed -- we could just // run the code below, where we would create and return the // view hierarchy; it would just never be used. return null; } ScrollView scroller = new ScrollView(getActivity()); TextView text = new TextView(getActivity()); int padding = (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 4, getActivity().getResources().getDisplayMetrics()); text.setPadding(padding, padding, padding, padding); scroller.addView(text); text.setText(Shakespeare.DIALOGUE[getShownIndex()]); return scroller; } } 回想一下TitlesFragment类，如果用户单击列表项并且当前布局不包含R.id.details视图（这是DetailsFragment所在的位置），则应用程序启动DetailsActivity以显示这个item的具体内容。 这是DetailsActivity，它嵌入在DetailsFragment中以在屏幕处于纵向时显示所选的播放摘要： kotlin class DetailsActivity : FragmentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) { // If the screen is now in landscape mode, we can show the // dialog in-line with the list so we don't need this activity. finish() return } if (savedInstanceState == null) { // During initial setup, plug in the details fragment. val details = DetailsFragment().apply { arguments = intent.extras } supportFragmentManager.beginTransaction() .add(android.R.id.content, details) .commit() } } } java public static class DetailsActivity extends FragmentActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) { // If the screen is now in landscape mode, we can show the // dialog in-line with the list so we don't need this activity. finish(); return; } if (savedInstanceState == null) { // During initial setup, plug in the details fragment. DetailsFragment details = new DetailsFragment(); details.setArguments(getIntent().getExtras()); getSupportFragmentManager().beginTransaction().add(android.R.id.content, details).commit(); } } } 请注意，如果配置是横向的，则此Activity将自动finish（），以便主Activity可以接管并在TitlesFragment旁边显示DetailsFragment。如果用户在纵向上启动DetailsActivity，但随后旋转到横向（重新启动当前活动），则会发生这种情况。 更多资源 Fragment在 Sunflower这个Demo app中被广泛使用。 "},"Activity/Fragment/创建Fragment.html":{"url":"Activity/Fragment/创建Fragment.html","title":"创建Fragment","keywords":"","body":"创建一个Fragment 原文(英文)地址 您可以将Fragment视为Activity的模块化部分，它具有自己的生命周期，接收自己的输入事件，并且可以在Activity运行时添加或删除（有点像“子Activity”，您可以在不同的Activity中重用）。本文档介绍如何使用 Support Library继承Fragment类，以便您的应用程序与运行系统版本低至Android 1.6的设备保持兼容。 您应该创建一个生命周期感知组件（lifecycle-aware component），而不是在Fragment的生命周期方法中设置依赖组件（dependent components）。当Fragment在其生命周期中移动时，该组件可以监听到你Fragment生命周期过程中发生的任何改变。然后，可以在其他Fragments和Activities中重用生命周期感知组件，以避免代码重复，并减少在Fragments / Activities本身中需要进行的设置。有关更多信息，请阅读 Handling Lifecycles with Lifecycle-Aware Components. 在开始之前，您必须设置Android项目以使用Support Library.。如果您之前未使用过Support Library.，请按照 Support Library Setup将项目设置为使用v4库。您也可以在Activity中包含app bar，而不是使用与Android 2.1（API级别7）兼容的v7 appcompat库，还包括Fragment API。 有关实现Fragment的更多信息，请参阅Fragment。您还可以通过浏览相关的sample app了解更多信息。 创建一个Fragment类 为了创建一个Fragment，你应该继承Fragment类，重写其生命周期的回调方法，这和你使用Activity的方法类似。 你应该在onCreateView()中创建你Fragment的layout，事实上这是保证Fragment可以运行的基本回调方法，例如下面是一个指定Layout的示例代码： import android.os.Bundle; import android.support.v4.app.Fragment; import android.view.LayoutInflater; import android.view.ViewGroup; public class ArticleFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Inflate the layout for this fragment return inflater.inflate(R.layout.article_view, container, false); } } 就像Activity一样，Fragment应该实现其他生命周期回调，这样就可以允许您管理Fragment的状态（当该Fragment被添加到Activity或被从Activity中移除的时候，或者在Activity生命周期变化的时候）。例如，当调用activity的onPause（）方法时，Activity中的任何Fragment也会接收对onPause（）的调用。 有关Fragment生命周期和回调方法的更多信息，请参阅Fragment。 使用XML文件将Fragment添加到Activity 虽然Fragment是可重用的，模块化UI组件，但Fragment类的每个实例都必须与父FragmentActivity相关联。您可以通过定义Activity布局XML文件中的Fragment来实现此关联。 注意：FragmentActivity是支持库（ Support Library ）中提供的一个特殊Activity，用于处理早于API 11的系统版本上的Fragment。如果您支持的最低系统版本是API级别11或更高级别，则可以使用常规Activity。 下面是一个示例布局文件，当设备屏幕被视为“大”（由目录名中的大限定符指定）时，它会向Activity添加两个Fragment。 res/layout-large/news_articles.xml： 提示：关于更多如何根据屏幕不同大小创建布局文件的内容，请参阅 Supporting Different Screen Sizes. 然后将该layout文件应用在你的Activity中： import android.os.Bundle; import android.support.v4.app.FragmentActivity; public class MainActivity extends FragmentActivity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.news_articles); } } 如果你在使用 v7 appcompat library, 你的Activity应该继承自 AppCompatActivity,它是 FragmentActivity`的子类. 了解更多的信息请参考 Adding the App Bar。 注意：通过在布局XML文件中定义Fragment将Fragment添加到Activity布局时，无法在运行时删除Fragment。如果您计划在用户交互期间替换Fragment，则必须在Activity首次启动时将Fragment添加到Activity中，如构建灵活的UI中所示。 "},"Activity/Fragment/测试Fragment.html":{"url":"Activity/Fragment/测试Fragment.html","title":"测试Fragment","keywords":"","body":"测试Fragment 原文(英文)地址 Fragment在您的应用程序中充当可重用容器，允许您在各种Activity和布局配置中呈现相同的用户界面布局。鉴于这些Fragment的多功能性，测试它们提供一致且资源有效的体验非常重要： 您的Fragment外观应该在布局配置中保持一致，包括支持更大屏幕尺寸或横向设备方向的配置。 除非Fragment对用户可见，否则不要创建Fragment的视图层次结构。 本文档描述了如何在测试Fragment时使用框架提供的API。 驱动Fragment的状态 为了帮助设置执行这些测试的条件，AndroidX提供了一个FragmentScenario库来创建Fragment并更改其状态。 注意：要成功运行包含FragmentScenario对象的测试，请在测试线程中运行API的方法。要了解有关Android测试中如何使用不同线程的更多信息，请参阅Understand threads in tests. 配置测试工件位置 为了使用FragmentScenario，在应用程序的测试APK中定义Fragment测试工件，如以下代码片段所示： dependencies { // ... debugImplementation 'androidx.fragment:fragment-testing:1.1.0-alpha01' } 创建Fragment FragmentScenario包含用于启动以下类型的Fragment的方法： 该方法还支持以下类型的Fragment： 图形Fragment（Graphical），包含用户界面。要启动此类型的Fragment，请调用launchFragmentInContainer（）。 FragmentScenario将Fragment附加到Activity的根视图控制器。This containing activity is otherwise empty. 非图形Fragment（Non-graphical）（有时称为无头Fragment- headless fragments），用于存储或执行对多个Activity中包含的信息的短期处理（ short-term processing ）。要启动此类型的Fragment，请调用launchFragment（）。 FragmentScenario将这种类型的Fragment附加到一个完全空的Activity，一个没有根视图的Activity。 在启动其中一个Fragment类型后，FragmentScenario将测试中的Fragment驱动到RESUMED状态。此状态表示Fragment正在运行。如果您正在测试图形Fragment，那么用户也可以看到它，因此您可以使用Espresso UI tests评估有关其UI元素的信息。 以下代码段显示了如何启动每种类型的Fragment： 图形Fragment @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEventFragment() { // The \"state\" and \"factory\" arguments are optional. val fragmentArgs = Bundle().apply { putInt(\"selectedListItem\", 0) } val factory = MyFragmentFactory() val scenario = launchFragmentInContainer( fragmentArgs, factory) onView(withId(R.id.text)).check(matches(withText(\"Hello World!\"))) } } 非图形Fragment @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEventFragment() { // The \"state\" and \"factory\" arguments are optional. val fragmentArgs = Bundle().apply { putInt(\"numElements\", 0) } val factory = MyFragmentFactory() val scenario = launchFragment(fragmentArgs, factory) } } 重建Fragment 如果设备的资源不足，系统可能会销毁宿主Activity，当用户重新返回app时需要你的app重建Fragment，为了模拟这个场景，调用recreate()： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEventFragment() { val scenario = launchFragmentInContainer() scenario.recreate() } } 当FragmentScenario类重新创建被测试的Fragment时，Fragment将返回到重新创建之前所处的生命周期状态。 驱动Fragment到新的状态 在您的应用程序的UI测试中，通常只需启动并重新创建测试中的Fragment即可。但是，在细粒度单元测试中，您还可以评估Fragment在从一个生命周期状态转换到另一个生命周期状态时的行为。 要将Fragment驱动到不同的生命周期状态，请调用moveToState（）。此方法支持以下状态作为参数：CREATED，STARTED，RESUMED和DESTROYED。此操作模拟包含您Fragment的宿主Activity因为它被另一个应用程序或系统操作中断而更改其状态的情况。 注意：如果将Fragment转换为DESTROYED状态，则无法将Fragment驱动到其他状态，也无法将Fragment附加到其他Activity。 moveToState（）的示例用法显示在以下代码段中： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEventFragment() { val scenario = launchFragmentInContainer() scenario.moveToState(State.CREATED) } } 警告：如果您尝试将测试中的Fragment转换为其当前状态，FragmentScenario会将此请求视为无操作，而不是抛出异常。特别注意，API允许您连续多次将片段转换为DESTROYED状态。 触发Fragment的行为 要在测试中的Fragment中触发某个行为，请使用Espresso视图匹配器与视图中的元素进行交互： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEventFragment() { val scenario = launchFragmentInContainer() onView(withId(R.id.refresh)) .perform(click()) } } 如果需要在Fragment本身上调用方法，例如响应选项菜单中的选择，则可以通过实现FragmentAction安全地执行此操作： @RunWith(AndroidJUnit4::class) class MyTestSuite { @Test fun testEventFragment() { val scenario = launchFragmentInContainer() scenario.onFragment(fragment -> fragment.onOptionsItemSelected(clickedItem) { // Update fragment's state based on selected item. } } } } 注意：在测试类中，不要保留传递给onFragment（）的对象的引用。这些引用消耗系统资源，并且引用本身可能是陈旧的，因为框架可以重新创建传递给回调方法的片段。 "},"Activity/Fragment/构建灵活的UI.html":{"url":"Activity/Fragment/构建灵活的UI.html","title":"构建灵活的UI","keywords":"","body":"构建灵活的UI 原文(英文)地址 在设计应用程序以支持各种屏幕尺寸时，您可以在不同的布局配置中重复使用Fragment，以根据可用的屏幕空间优化用户体验。 例如，在手机设备上，一次只显示一个Fragment用于单窗格用户界面可能是合适的。相反，您可能希望在具有更宽屏幕尺寸的平板电脑上并排设置Fragment，以向用户显示更多信息。 图一：两个Fragment，以不同的配置显示，用于不同屏幕尺寸的相同Activity。在大屏幕上，两个Fragment并排放置，但在手机设备上，一次只能放入一个Fragment，因此Fragment必须在用户导航时互相替换。 FragmentManager提供的方法允许你在Activity运行时添加、移除、替换Fragment以创造动态的体验。 关于Fragment的更多实现信息请参阅一下资源： Fragment Supporting Tablets and Handsets 在Activity运行时添加Fragment 相比于上一个文档创建Fragment中所述的在布局文件中定义Activity的Fragment，您可以在Activity运行时期间向Activity添加Fragment。如果您计划在Activity期间更改Fragment，则必须采用此种方法（在Activity运行时期间向Activity添加Fragment）。 要执行诸如添加或删除Fragment之类的事务，必须使用FragmentManager创建FragmentTransaction，它提供API以添加，删除，替换和执行其他Fragment事务。 如果您的Activity允许删除和替换Fragment，则应在Activity的onCreate（）方法中将初始Fragment添加到Activity中。 处理Fragment时的一个重要规则 （特别是在运行时添加Fragment时）： 您的Activity布局必须包含一个容器视图，您可以在其中插入Fragment。 以下布局是上一个文档中显示的布局的替代方案，一次只显示一个Fragment。为了将一个Fragment替换为另一个Fragment，Activity的布局包括一个空的FrameLayout，它充当Fragment容器。 请注意，文件名与上一课中的布局文件相同，但布局目录没有\"large\"限定符，因此当设备屏幕小于\"大(large)\"时，将使用此布局，因为屏幕不适合同时放置两个Fragment。 res/layout/news_articles.xml: 在您的Activity中，调用getSupportFragmentManager（）以使用Support Library APIs获取FragmentManager。然后调用beginTransaction（）创建FragmentTransaction并调用add（）来添加Fragment。 您可以使用相同的FragmentTransaction为Activity执行多个Fragment事务，准备好进行更改后，必须调用commit（）。 例如，以下是如何将Fragment添加到先前的布局： import android.os.Bundle; import android.support.v4.app.FragmentActivity; public class MainActivity extends FragmentActivity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.news_articles); // Check that the activity is using the layout version with // the fragment_container FrameLayout if (findViewById(R.id.fragment_container) != null) { // However, if we're being restored from a previous state, // then we don't need to do anything and should return or else // we could end up with overlapping fragments. if (savedInstanceState != null) { return; } // Create a new Fragment to be placed in the activity layout HeadlinesFragment firstFragment = new HeadlinesFragment(); // In case this activity was started with special instructions from an // Intent, pass the Intent's extras to the fragment as arguments firstFragment.setArguments(getIntent().getExtras()); // Add the fragment to the 'fragment_container' FrameLayout getSupportFragmentManager().beginTransaction() .add(R.id.fragment_container, firstFragment).commit(); } } } 因为Fragment已在运行时添加到FrameLayout容器中(而不是使用元素在Activity的布局中定义它) ，则该Activity可以删除Fragment并将其替换为另一个Fragment。 用另一个Fragment替换当前Fragment 替换Fragment的过程类似于添加Fragment，但需要使用replace（）方法而不是add（）。 请记住，当您执行Fragment事务（例如替换或删除Fragment事务）时，通常允许用户向后导航并“撤消”更改。要允许用户在Fragment事务中向后导航，必须在提交FragmentTransaction之前调用addToBackStack（）。 注意：删除或替换Fragment并将事务添加到后台堆栈时，被移除的Fragment将会Stopped而不是Destroyed。如果用户导航回还原Fragment，则会重新启动。如果不将事务添加到后台堆栈，则在删除或替换时Destroy该Fragment。 用另一个Fragment替换一个Fragment的示例： // Create fragment and give it an argument specifying the article it should show ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Replace whatever is in the fragment_container view with this fragment, // and add the transaction to the back stack so the user can navigate back transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); // Commit the transaction transaction.commit(); addToBackStack（）方法采用可选的字符串参数，该参数指定事务的唯一名称。除非您计划使用FragmentManager.BackStackEntry API执行高级Fragment操作，否则不需要该名称。 注意：ragment add replace 区别 replace 先删除容器中的内容，再添加 add直接添加，可以配合hide适用 "},"Activity/Fragment/与其他Fragment通信.html":{"url":"Activity/Fragment/与其他Fragment通信.html","title":"与其他Fragment通信","keywords":"","body":"与其他Fragment通信 原文(英文)地址 为了重用Fragment UI组件，您应该将每个组件构建为一个完全独立的模块化组件，以定义自己的布局和行为。一旦定义了这些可重用的Fragment，就可以将它们与Activity关联，并将它们与应用程序逻辑相连接，以实现整个复合UI。 通常，您会希望一个Fragment与另一个Fragment进行通信，例如根据用户事件更改内容。所有Fragment-to-Fragment通信都应该通过共享的ViewModel或通过关联的Activity完成。两个Fragment永远不应该直接通信。 Fragment之间通信的推荐方法是创建共享的ViewModel对象。两个Fragment都可以通过其宿主Activity访问ViewModel。 Fragments可以更新ViewModel中的数据，如果使用LiveData公开数据，只要从ViewModel观察LiveData，新状态就会被推送到另一个Fragment。要了解如何实现此类通信，请阅读ViewModel guide.中的“在Fragment之间共享数据”部分。 如果您无法使用共享ViewModel在Fragments之间进行通信，则可以使用接口手动实现通信流。然而，这最终需要更多的工作来实现，并且不容易在其他Fragment中重用。 定义接口 要允许Fragment与其宿主Activity进行通信，您可以在Fragment类中定义接口并在Activity中实现它。 Fragment在其onAttach（）生命周期方法中捕获（attach）接口实现，然后可以调用Interface方法以与Activity通信。 以下是Fragment to Activity通信的示例： HeadlinesFragment public class HeadlinesFragment extends ListFragment { OnHeadlineSelectedListener callback; public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener callback) { this.callback = callback; } // This interface can be implemented by the Activity, parent Fragment, // or a separate test implementation. public interface OnHeadlineSelectedListener { public void onArticleSelected(int position); } // ... } MainActivity public static class MainActivity extends Activity implements HeadlinesFragment.OnHeadlineSelectedListener{ // ... @Override public void onAttachFragment(Fragment fragment) { if (fragment instanceof HeadlinesFragment) { HeadlinesFragment headlinesFragment = (HeadlinesFragment) fragment; headlinesFragment.setOnHeadlineSelectedListener(this); } } } 现在，Fragment可以通过使用OnHeadlineSelectedListener接口的mCallback实例调用onArticleSelected（）方法（或接口中的其他方法）来向Activity传递消息。 例如，当用户单击列表项时，将调用Fragment中的以下方法。该Fragment使用回调接口将事件传递给父Activity。 @Override public void onListItemClick(ListView l, View v, int position, long id) { // Send the event to the host activity callback.onArticleSelected(position); } 实现接口 为了从Fragment接收事件回调，托管它的Activity必须实现Fragment类中定义的接口。 例如，以下Activity实现了上面示例中的接口: public static class MainActivity extends Activity implements HeadlinesFragment.OnHeadlineSelectedListener{ ... public void onArticleSelected(int position) { // The user selected the headline of an article from the HeadlinesFragment // Do something here to display that article } } 发送Message到其他Fragment 宿主Activity可以通过使用findFragmentById（）捕获Fragment实例，然后直接调用Fragment的public方法来将消息传递给Fragment。 例如，假设上面显示的Activity可能包含另一个Fragment，该Fragment用于显示由上述回调方法返回的数据指定的项目。在这种情况下，Activity可以将回调方法中收到的信息传递给将显示该项目的另一个Fragment： public static class MainActivity extends Activity implements HeadlinesFragment.OnHeadlineSelectedListener{ ... public void onArticleSelected(int position) { // The user selected the headline of an article from the HeadlinesFragment // Do something here to display that article ArticleFragment articleFrag = (ArticleFragment) getSupportFragmentManager().findFragmentById(R.id.article_fragment); if (articleFrag != null) { // If article frag is available, we're in two-pane layout... // Call a method in the ArticleFragment to update its content articleFrag.updateArticleView(position); } else { // Otherwise, we're in the one-pane layout and must swap frags... // Create fragment and give it an argument for the selected article ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); // Replace whatever is in the fragment_container view with this fragment, // and add the transaction to the back stack so the user can navigate back transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); // Commit the transaction transaction.commit(); } } } 关于更多Fragment的实现，请参阅Fragment,你也可以在 relevant sample app中了解更多信息。 "},"Activity/Interacting-With-Other-Apps/与其他APP交互——概述.html":{"url":"Activity/Interacting-With-Other-Apps/与其他APP交互——概述.html","title":"概述","keywords":"","body":"与其他APP交互——概述 原文(英文)地址 Android应用通常有几项Activity。每个Activity都显示一个用户界面，允许用户执行特定任务（例如查看地图或拍照）。要将用户从一个Activity带到另一个Activity，您的应用必须使用Intent来定义应用的“意图”以执行某些操作。使用startActivity（）等方法将Intent传递给系统时，系统会使用Intent来识别并启动相应的app组件。使用意图甚至允许您的应用启动包含在单独应用中的Activity。 Intent可以是显式的，以便启动特定组件（特定的Activity实例），也可以是隐式的，以启动任何可以处理预期操作的组件（例如“捕获照片”）。 本文档向您展示如何使用Intent与其他应用程序执行一些基本交互，例如启动另一个应用程序，从该应用程序接收结果，以及让您的应用程序能够响应来自其他应用程序的Intent。 主要内容 将用户导航到另一个APP 介绍如何使用隐式Intent启动其他应用程序(APP) 接收另一个Activity的返回结果 介绍如何启动另一个Activity并接收其返回的结果 允许其他APP启动你的Activity 介绍如何通过声明应用程序接受的隐式意图的intent filter让你的App中的Activity可以被其他APP启动 关于本文档的额外参考信息，请参阅: Sharing Simple Data Sharing Files Integrating Application with Intents (blog post) Intents and Intent Filters "},"Activity/Interacting-With-Other-Apps/与其他APP交互——将用户导航到另一个APP.html":{"url":"Activity/Interacting-With-Other-Apps/与其他APP交互——将用户导航到另一个APP.html","title":"将用户导航到另一个APP","keywords":"","body":"与其他APP交互——将用户导航到另一个APP 原文(英文)地址 Android最重要的功能之一是应用程序能够根据其想要执行的“操作”将用户导航到另一个应用程序。例如，如果您的应用具有您希望在地图上显示的商家的地址，则您不必在应用中构建显示地图的Activity，您可以使用Intent创建查看地址的请求，然后Android系统会启动一个能够在地图上显示地址的应用程序。 您必须使用Intent在您自己的应用程序中的Activity之间导航。通常使用显式Intent来执行此操作，该Intent定义了要启动的组件的确切类名。但是，如果要让特定的应用程序执行操作（例如“查看地图”），则必须使用隐式意图。 本文档向您展示如何为特定操作创建隐式Intent，以及如何使用它来启动在另一个应用程序中执行操作的Activity。另请参阅此处嵌入的视频，以了解为什么运行时对隐式Intent的检查很重要。 创建一个隐式Intent 隐式Intent不会声明要启动的组件的类名，而是声明要执行的操作。该声明指明了您要执行的操作，例如查看，编辑，发送或获取某些内容。Intent通常还包括与操作关联的数据，例如您要查看的地址或您要发送的电子邮件。根据您要创建的Intent，数据可能是Uri，其他几种数据类型之一，intent也可能根本不需要数据。 如果您的数据是Uri，那么可以使用一个简单的Intent（）构造函数来定义操作和数据。 例如，以下是如何使用Uri数据创建发起电话呼叫的Intent以指定电话号码： kotlin val callIntent: Intent = Uri.parse(\"tel:5551234\").let { number -> Intent(Intent.ACTION_DIAL, number) } java Uri number = Uri.parse(\"tel:5551234\"); Intent callIntent = new Intent(Intent.ACTION_DIAL, number); 当你的app通过startActivity()调用此Intent时，Phone app将会向传入的电话号码拨打电话。 这里是一些其他的Intent及其指定的动作和数据： 查看地图 kotlin // Map point based on address val mapIntent: Intent = Uri.parse( \"geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California\" ).let { location -> // Or map point based on latitude/longitude // Uri location = Uri.parse(\"geo:37.422219,-122.08364?z=14\"); // z param is zoom level Intent(Intent.ACTION_VIEW, location) } java // Map point based on address Uri location = Uri.parse(\"geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California\"); // Or map point based on latitude/longitude // Uri location = Uri.parse(\"geo:37.422219,-122.08364?z=14\"); // z param is zoom level Intent mapIntent = new Intent(Intent.ACTION_VIEW, location); 查看网页 kotlin val webIntent: Intent = Uri.parse(\"http://www.android.com\").let { webpage -> Intent(Intent.ACTION_VIEW, webpage) } java Uri webpage = Uri.parse(\"http://www.android.com\"); Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage); 其他类型的隐式Intent需要提供不同数据类型的“Extra”数据，例如字符串。您可以使用各种putExtra（）方法添加一个或多个额外数据。 默认情况下，系统根据包含的Uri数据确定intent所需的相应MIME类型。如果您没有在Intent中包含Uri，则通常应使用setType（）来指定与Intent关联的数据类型。设置MIME类型进一步指定应该接收Intent的活动类型。 以下是一些添加额外数据以指定所需操作的Intent： 发送带有附件的邮件 kotlin Intent(Intent.ACTION_SEND).apply { // The intent does not have a URI, so declare the \"text/plain\" MIME type type = HTTP.PLAIN_TEXT_TYPE putExtra(Intent.EXTRA_EMAIL, arrayOf(\"jon@example.com\")) // recipients putExtra(Intent.EXTRA_SUBJECT, \"Email subject\") putExtra(Intent.EXTRA_TEXT, \"Email message text\") putExtra(Intent.EXTRA_STREAM, Uri.parse(\"content://path/to/email/attachment\")) // You can also attach multiple items by passing an ArrayList of Uris } java Intent emailIntent = new Intent(Intent.ACTION_SEND); // The intent does not have a URI, so declare the \"text/plain\" MIME type emailIntent.setType(HTTP.PLAIN_TEXT_TYPE); emailIntent.putExtra(Intent.EXTRA_EMAIL, new String[] {\"jon@example.com\"}); // recipients emailIntent.putExtra(Intent.EXTRA_SUBJECT, \"Email subject\"); emailIntent.putExtra(Intent.EXTRA_TEXT, \"Email message text\"); emailIntent.putExtra(Intent.EXTRA_STREAM, Uri.parse(\"content://path/to/email/attachment\")); // You can also attach multiple items by passing an ArrayList of Uris 创建一个日历事件 kotlin Intent(Intent.ACTION_INSERT, Events.CONTENT_URI).apply { val beginTime: Calendar = Calendar.getInstance().apply { set(2012, 0, 19, 7, 30) } val endTime = Calendar.getInstance().apply { set(2012, 0, 19, 10, 30) } putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, beginTime.timeInMillis) putExtra(CalendarContract.EXTRA_EVENT_END_TIME, endTime.timeInMillis) putExtra(Events.TITLE, \"Ninja class\") putExtra(Events.EVENT_LOCATION, \"Secret dojo\") } java Intent calendarIntent = new Intent(Intent.ACTION_INSERT, Events.CONTENT_URI); Calendar beginTime = Calendar.getInstance(); beginTime.set(2012, 0, 19, 7, 30); Calendar endTime = Calendar.getInstance(); endTime.set(2012, 0, 19, 10, 30); calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, beginTime.getTimeInMillis()); calendarIntent.putExtra(CalendarContract.EXTRA_EVENT_END_TIME, endTime.getTimeInMillis()); calendarIntent.putExtra(Events.TITLE, \"Ninja class\"); calendarIntent.putExtra(Events.EVENT_LOCATION, \"Secret dojo\"); 注意：此Intent只支持API14及更高的平台 注意：尽可能具体地定义Intent是非常重要的。例如，如果要使用ACTION_VIEW Intent显示图像，则应指定MIME类型image / *。这可以防止可以“view”其他类型数据（如地图应用程序）的应用程序被Intent触发。 验证是否有APP可以接收Intent 虽然Android平台保证某些Intent将解析为内置应用程序之一（例如电话，电子邮件或日历应用程序），但您应始终在调用Intent之前包含验证步骤。 警告：如果您调用intent并且设备上没有可以处理Intent的应用程序，则您的应用程序将崩溃。 要验证是否有可以响应Intent的活动，请调用queryIntentActivities（）以获取能够处理您的Intent的活动列表。如果返回的List不为空，则可以安全地使用intent。例如： kotlin val activities: List = packageManager.queryIntentActivities( intent, PackageManager.MATCH_DEFAULT_ONLY ) val isIntentSafe: Boolean = activities.isNotEmpty() java PackageManager packageManager = getPackageManager(); List activities = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY); boolean isIntentSafe = activities.size() > 0; 如果isIntentSafe为true，则至少有一个app可以相应该Intent，如果为false，则没有app可以相应该Intent。 注意：您应该在Activity首次启动时执行此检查，以防你需要在用户尝试使用该功能之前禁用使用Intent的功能。如果您知道可以处理意图的特定应用，您还可以给提供用户下载应用的链接（请参阅如何 link to your product on Google Play）。 使用Intent启动Activity 图一：当有多个app可以相应Intent时的选择框 当你创建完成Intent并且设置好Extra信息之后，请调用startActivity()以将该Intent发送到系统。如果系统有不知一个Activity可以处理该Intent，系统会显示一个dialog以供用户选择一个最终被使用的app，如图一。如果只有一个activity可以响应Intent，则系统会直接启动它。 这里是一个稍微复杂的例子，展示了如何创建一个展示地图的Intent，首先验证是否有应用可以响应，然后启动它： kotlin // Build the intent val location = Uri.parse(\"geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California\") val mapIntent = Intent(Intent.ACTION_VIEW, location) // Verify it resolves val activities: List = packageManager.queryIntentActivities(mapIntent, 0) val isIntentSafe: Boolean = activities.isNotEmpty() // Start an activity if it's safe if (isIntentSafe) { startActivity(mapIntent) } java // Build the intent Uri location = Uri.parse(\"geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California\"); Intent mapIntent = new Intent(Intent.ACTION_VIEW, location); // Verify it resolves PackageManager packageManager = getPackageManager(); List activities = packageManager.queryIntentActivities(mapIntent, 0); boolean isIntentSafe = activities.size() > 0; // Start an activity if it's safe if (isIntentSafe) { startActivity(mapIntent); } 展示Activity的选择界面 图二：一个选择对话框 请注意，当您通过将Intent传递给startActivity（）并且有多个应用程序可以响应intent时，用户可以选择默认使用哪个应用程序（通过选择对话框底部的复选框，见图1）。这在用户通常希望每次都使用相同应用去执行的动作时很好，例如当打开网页（用户可能只使用一个网络浏览器）或拍照时（用户可能更喜欢一个相机）。 但是，如果要执行的操作可以由多个应用程序处理，并且用户可能每次都更喜欢不同的应用程序——例如“分享”操作，用户可能拥有多个应用程序，通过这些应用程序可以分享项目，这时您应该明确显示一个选择器对话框，如图2所示。选择器对话框强制用户每次选择用于操作的应用程序（用户无法为操作选择默认应用程序）。 要显示选择器，请使用createChooser（）创建一个Intent并将其传递给startActivity（）。例如： kotlin val intent = Intent(Intent.ACTION_SEND) ... // Always use string resources for UI text. // This says something like \"Share this photo with\" val title = resources.getString(R.string.chooser_title) // Create intent to show chooser val chooser = Intent.createChooser(intent, title) // Verify the intent will resolve to at least one activity if (intent.resolveActivity(packageManager) != null) { startActivity(chooser) } java Intent intent = new Intent(Intent.ACTION_SEND); ... // Always use string resources for UI text. // This says something like \"Share this photo with\" String title = getResources().getString(R.string.chooser_title); // Create intent to show chooser Intent chooser = Intent.createChooser(intent, title); // Verify the intent will resolve to at least one activity if (intent.resolveActivity(getPackageManager()) != null) { startActivity(chooser); } 这将显示一个对话框，其中包含可以响应传递给createChooser（）方法的Intent的应用程序列表，并使用提供的文本作为对话框标题。 "},"Activity/Interacting-With-Other-Apps/与其他APP交互——接收另一个Activity返回的结果.html":{"url":"Activity/Interacting-With-Other-Apps/与其他APP交互——接收另一个Activity返回的结果.html","title":"接收另一个Activity返回的结果","keywords":"","body":"与其他APP交互——接收另一个Activity返回的结果 原文(英文)地址 启动另一项Activity不一定是单向的，您还可以启动另一项Activity并收到其返回的结果，要接收结果，请调用startActivityForResult（）（而不是startActivity（））。 例如，您的应用可以启动相机应用并接收拍摄的照片。或者，您可以启动People应用程序，以便用户选择联系人，您将收到联系人详细信息。 当然，响应的Activity必须设计为可返回结果的，它将结果作为另一个Intent对象发送，您的Activity在onActivityResult（）回调中接收它。 注意：调用startActivityForResult（）时可以使用显式或隐式Intent。在启动您自己的某个Activity以接收结果时，您应该使用显示的Intent来确保您收到预期的结果。 启动Activity 启动需要接收返回值得Activity时使用的Intent对象没有什么特别之处，但是您需要将一个整数参数传递给startActivityForResult（）方法。 整数参数是标识您的请求的“请求代码”，当您收到返回结果Intent时，回调会提供相同的请求代码，以便您的应用程序可以正确识别结果并确定如何处理它。 例如，以下是启动允许用户选择联系人的Activity： kotlin const val PICK_CONTACT_REQUEST = 1 // The request code ... private fun pickContact() { Intent(Intent.ACTION_PICK, Uri.parse(\"content://contacts\")).also { pickContactIntent -> pickContactIntent.type = Phone.CONTENT_TYPE // Show user only contacts w/ phone numbers startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST) } } java static final int PICK_CONTACT_REQUEST = 1; // The request code ... private void pickContact() { Intent pickContactIntent = new Intent(Intent.ACTION_PICK, Uri.parse(\"content://contacts\")); pickContactIntent.setType(Phone.CONTENT_TYPE); // Show user only contacts w/ phone numbers startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST); } 接收返回的结果 当用户完成第二个Activity并返回时，系统会调用您第一个Activity的onActivityResult（）方法。此方法包括三个参数： 您传递给startActivityForResult（）的请求代码。 由第二个Activity指定的结果代码。如果操作成功，则为RESULT_OK;如果用户由于某种原因退出或操作失败，则为RESULT_CANCELED。 包含结果数据的Intent。 例如，以下是如何处理“选择联系人”Intent的结果： kotlin override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) { // Check which request we're responding to if (requestCode == PICK_CONTACT_REQUEST) { // Make sure the request was successful if (resultCode == Activity.RESULT_OK) { // The user picked a contact. // The Intent's data Uri identifies which contact was selected. // Do something with the contact here (bigger example below) } } } java @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { // Check which request we're responding to if (requestCode == PICK_CONTACT_REQUEST) { // Make sure the request was successful if (resultCode == RESULT_OK) { // The user picked a contact. // The Intent's data Uri identifies which contact was selected. // Do something with the contact here (bigger example below) } } } 在此示例中，Android的Contacts或People应用程序返回的结果Intent提供了一个内容Uri，用于标识用户选择的联系人。 为了成功处理结果，您必须了解Intent的结果格式。当返回结果的Activity是您自己的Activity之一时，这样做很容易。 Android平台附带的应用程序提供了自己的API，您可以依赖这些API来获取特定的结果数据。例如，People应用程序始终返回带有标识所选联系人的内容URI的结果，而Camera应用程序在“data”extra中返回一个 Bitmap（请参阅 Capturing Photos）。 菜单一：发送返回数据的方法 主要是通过setResult()方法。 //数据是使用Intent返回 Intent intent = new Intent(); //把返回数据存入Intent intent.putExtra(\"result\", \"My name is linjiqin\"); //设置返回数据 OtherActivity.this.setResult(RESULT_OK, intent); 彩蛋二：读取联系人数据 上面展示了如何从People应用程序获取结果的代码，但是没有详细介绍如何从结果中实际读取数据，因为它需要有关ContentProvider的更多理论。但是，如果您感到好奇，可以使用以下代码查看如何查询结果数据以获取所选联系人的电话号码： kotlin override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) { // Check which request it is that we're responding to if (requestCode == PICK_CONTACT_REQUEST) { // Make sure the request was successful if (resultCode == Activity.RESULT_OK) { // We only need the NUMBER column, because there will be only one row in the result val projection: Array = arrayOf(Phone.NUMBER) // Get the URI that points to the selected contact data.data?.also { contactUri -> // Perform the query on the contact to get the NUMBER column // We don't need a selection or sort order (there's only one result for this URI) // CAUTION: The query() method should be called from a separate thread to avoid // blocking your app's UI thread. (For simplicity of the sample, this code doesn't // do that.) // Consider using CursorLoader to perform the query. contentResolver.query(contactUri, projection, null, null, null)?.apply { moveToFirst() // Retrieve the phone number from the NUMBER column val column: Int = getColumnIndex(Phone.NUMBER) val number: String? = getString(column) // Do something with the phone number... } } } } } java @Override protected void onActivityResult(int requestCode, int resultCode, Intent resultIntent) { // Check which request it is that we're responding to if (requestCode == PICK_CONTACT_REQUEST) { // Make sure the request was successful if (resultCode == RESULT_OK) { // Get the URI that points to the selected contact Uri contactUri = resultIntent.getData(); // We only need the NUMBER column, because there will be only one row in the result String[] projection = {Phone.NUMBER}; // Perform the query on the contact to get the NUMBER column // We don't need a selection or sort order (there's only one result for the given URI) // CAUTION: The query() method should be called from a separate thread to avoid blocking // your app's UI thread. (For simplicity of the sample, this code doesn't do that.) // Consider using CursorLoader to perform the query. Cursor cursor = getContentResolver() .query(contactUri, projection, null, null, null); cursor.moveToFirst(); // Retrieve the phone number from the NUMBER column int column = cursor.getColumnIndex(Phone.NUMBER); String number = cursor.getString(column); // Do something with the phone number... } } } 注意：在Android 2.3（API级别9）之前，对联系人ContentProvider执行查询（如上所示）需要您的应用程序声明READ_CONTACTS权限（请参阅 Security and Permissions）。但是，从Android 2.3开始，Contacts / People应用程序授予您的应用程序临时权限，以便在返回结果时从联系人提供程序中读取数据。临时权限仅适用于请求的特定联系人，因此除非您声明READ_CONTACTS权限，否则无法查询intent的Uri指定的联系人之外的联系人。 关于更多与本文档有关的内容，请参考： Sharing Simple Data Sharing Files "},"Activity/Interacting-With-Other-Apps/与其他APP交互——允许其他应用启动您的Activity.html":{"url":"Activity/Interacting-With-Other-Apps/与其他APP交互——允许其他应用启动您的Activity.html","title":"允许其他应用启动您的Activity","keywords":"","body":"与其他APP交互——允许其他应用启动您的 Activity 原文(英文)地址 如果另一个应用想要通过您的应用执行某些操作，您的应用应准备好响应来自其他应用的操作请求。 例如，如果您构建一款可与用户的好友分享消息或照片的社交应用，您最关注的是支持 ACTION_SEND Intent 以便用户可以从另一应用发起“分享”操作并且启动您的应用执行该操作。 要允许其他应用启动您的 Activity，您需要在清单文件中为对应的 元素添加一个 元素。 当您的应用安装在设备上时，系统会识别您的 Intent filter 并添加信息至所有已安装应用支持的 Intent 内部目录。当应用通过隐含 Intent 调用 startActivity() 或 startActivityForResult() 时，系统会找到可以响应该 Intent 的 Activity。 添加 Intent filter 为了正确定义您 Activity 可处理的 Intent，您添加的每个 Intent filter在操作类型和 Activity 接受的数据方面应尽可能具体。 如果 Activity 具有满足以下 Intent 对象条件的 Intent filter，系统可能向 Activity 发送给定的 Intent： 操作 一个描述要执行操作的字符串。通常是一个平台（platform-defined）定义的值，比如 ACTION_SEND 或 ACTION_VIEW。使用元素在您的 Intent finlter中指定此值。您在此元素中指定的值必须是操作的完整字符串名称，而不是 API 常量（请参阅以下示例）。 数据 与 Intent 关联的数据的一条描述。用元素在您的 Intent filter中指定此内容。使用此元素中的一个或多个属性，您可以单独指定 MIME 类型(MIME type）、URI 前缀（URI prefix）、URI 架构（URI scheme）或这些的组合，以及其他表名所接受数据类型的项。 注意：如果您无需声明关于数据的具体信息 Uri（比如，您的 Activity 处理其他类型的“额外”数据而不是 URI 时），您应只指定 android:mimeType 属性声明您的 Activity 处理的数据类型，比如 text/plain 或 image/jpeg。 类别 提供另外一种表征处理 Intent 的 Activity 的方法，通常与用户手势或 Activity 启动的位置有关。 系统支持多种不同的类别，但大多数都很少使用。 但是，所有隐含 Intent 默认使用 CATEGORY_DEFAULT 进行定义。用元素在您的 Intent filter中指定此内容。 在您的 Intent filter中，您可以通过声明嵌套在元素中的具有相应 XML 元素的各项，来声明您的 Activity 接受的条件。 例如，此处有一个 Activity 与在数据类型为文本或图像时处理 ACTION_SEND Intent 的 Intent filter： 每个传入的 Intent 仅指定一项操作和一个数据类型，但可以在每个 中声明 ,,元素的多个实例。 如果任何两对操作和数据的行为相斥，您应创建单独的 Intent filter指定与哪种数据类型配对时哪些操作可接受。 比如，假定您的 Activity 同时处理 ACTION_SEND 和 ACTION_SENDTO Intent 的文本和图像。在这种情况下，您必须为两个操作定义两种不同的 Intent filter，因为 ACTION_SENDTO Intent 必须使用数据 Uri 指定使用 send 或 sendto URI 架构的收件人地址。例如： 注意：为了接收隐式 Intent，您必须在 Intent filter中包含 CATEGORY_DEFAULT 类别。方法 startActivity() 和startActivityForResult() 将按照已声明 CATEGORY_DEFAULT 类别的方式处理所有 Intent。如果您不在 Intent filter中声明它，则没有隐含 Intent 分解为您的 Activity。 如需了解有关发送和接收 ACTION_SEND 执行社交共享行为的 Intent 的详细信息，请参阅有关Receiving simple data from other apps的文档。 处理您的 Activity 中的 Intent 为了决定在您的 Activity 执行哪种操作，您可读取用于启动 Activity 的 Intent。 当您的 Activity 启动时，调用 getIntent() 检索启动 Activity 的 Intent。您可以在 Activity 生命周期的任何时间执行此操作，但您通常应在早期回调时（比如，onCreate() 或 onStart()）执行。 例如： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // Get the intent that started this activity Intent intent = getIntent(); Uri data = intent.getData(); // Figure out what to do based on the intent type if (intent.getType().indexOf(\"image/\") != -1) { // Handle intents with image data ... } else if (intent.getType().equals(\"text/plain\")) { // Handle intents with text ... } } 返回结果 如果您想要向调用您的 Activity 的 Activity 返回结果，只需调用 setResult() 指定结果代码和结果 Intent。当您的操作完成且用户应返回原来的 Activity 时，调用 finish() 关闭（和销毁）您的 Activity。 例如： // Create intent to deliver some kind of result data Intent result = new Intent(\"com.example.RESULT_ACTION\", Uri.parse(\"content://result_uri\")); setResult(Activity.RESULT_OK, result); finish(); 您必须始终为结果指定结束代码。通常，它是 RESULT_OK 或 RESULT_CANCELED。您之后可以根据需要为 Intent 提供额外的数据。 注意：默认情况下，结果设置为 RESULT_CANCELED。因此，如果用户在完成操作动作或设置结果之前按了返回按钮，原始 Activity 会收到“已取消”的结果。 如果您只需返回指示若干结果选项之一的整数，您可以将结果代码设置为大于 0 的任何值。如果您使用结果代码传递整数，且无需包括 Intent，则可调用 setResult() 且仅传递结果代码。例如： setResult(RESULT_COLOR_RED); finish(); 在这种情况下，只有几个可能的结果，因此结果代码是一个本地定义的整数（大于 0）。 当您向自己应用中的 Activity 返回结果时，这将非常有效，因为接收结果的 Activity 可引用公共常数来确定结果代码的值。 注意：无需检查您的 Activity 是使用 startActivity() 还是 startActivityForResult() 启动的。如果启动您 Activity 的 Intent 可能需要结果，只需调用 setResult()。如果原始 Activity 已调用 startActivityForResult()，则系统将向其传递您提供给 setResult() 的结果；否则，会忽略结果。 "},"Activity/Handling-Android-App-Links/概述.html":{"url":"Activity/Handling-Android-App-Links/概述.html","title":"概述","keywords":"","body":"处理Android APP Links——概述 遵循设备链接的用户有一个目标：获取他们想要查看的内容。作为开发人员，您可以设置Android App Links，以便用户直接在应用中访问链接的特定内容，从而绕过应用选择对话框，也称为消除歧义对话框。由于Android App Links利用HTTP网址和与网站的关联，因此未安装应用的用户可直接访问您网站上的内容。 Deep Linking和Android App Links 在深入了解如何实现之前，了解您可以在Android应用中创建的不同类型的链接非常重要：Deep Linking（Deep linking）和Android App Links（App Links）。 Deep Linking是将用户直接带到App中特定内容的URLs。在Android中，您可以通过添加Intent filter并从传入的Intent中提取数据来设置Deep Linking，从而将用户导向正确的Activity。 但是，如果用户设备上安装的其他应用程序可以处理相同的Intent，则用户可能无法直接访问您的应用程序。例如，单击来自银行的电子邮件中的URL可能会导致出现一个对话框，询问用户是使用浏览器还是银行自己的应用程序来打开链接。 Android 6.0（API级别23）及更高版本上的Android App Links允许应用程序将自己指定为给定类型链接的默认处理程序。如果用户不希望应用程序成为默认处理程序，则他们可以从其设备的系统设置中覆盖此行为。 Android App Links具有以下优势： 安全且具体：Android App Links使用链接到您的网站域的HTTP URL，因此没有其他应用可以使用您的链接。 Android App Links的一个要求是您通过我们的网站关联方法（website association methods）验证您域名的所有权。 无缝的用户体验：由于Android App Links对您网站和应用中的相同内容使用单个HTTP URL，因此未安装该应用的用户只需访问您的网站而不是应用 - 没有404，没有错误。 Android Instant Apps支持：使用Android Instant Apps，您的用户无需安装即可运行您的Android应用。要为您的Android应用添加即时应用支持，请设置Android App Links并访问g.co/InstantApps.。 通过Google搜索吸引用户：用户可以通过在移动浏览器， Google Search app，Android屏幕搜索或Google智能助理中点击Google中的网址，直接在应用中打开特定内容。 添加Android App Links 创建Android App Links的一般步骤如下： 创建应用中特定内容的Deep Links：在您的manifest文件中，为您的网站的URI（website URIs）创建Intent filter，并配置您的应用以使用Intent中的data将用户导航到您应用中的正确内容。在 创建指向您内容的Deep Links中了解更多信息。 添加深层链接验证：配置您的应用以请求验证应用链接。然后，在您的网站上发布数字资产链接JSON文件，以通过 Google Search Console验证所有权。在 Verify App Links.中了解更多信息 作为上述链接文档的替代方案， Android App Links Assistant是Android Studio中的一个工具，可指导您完成创建Android App Links所需的每个步骤。 有关其他信息，请参阅以下资源： Add Android App Links in Android Studio Creating a Statement List "},"Activity/Handling-Android-App-Links/创建指向您内容的Deep-Links.html":{"url":"Activity/Handling-Android-App-Links/创建指向您内容的Deep-Links.html","title":"创建指向您内容的DeepLinks","keywords":"","body":"处理Android APP Links——创建指向您内容的Deep Links 原文(英文)地址 当单击链接或编程请求调用Web URI Intent时，Android系统将按顺序尝试以下每个操作，直到请求成功为止： 打开用户首选的可以处理URI的应用程序（如果已指定）。 打开唯一可以处理URI的可用应用程序。 允许用户从对话框中选择应用程序。 请按照以下步骤创建和测试指向您的内容的链接。您还可以使用Android Studio中的 App Links Assistant 添加Android App Links。 为传入的链接添加Intent filter 要创建一个导向你app内容的链接，你需要在你的manifest中添加intent filter并且设置如下三个属性： 指定ACTION_VIEW Intent操作，以便可以从Google搜索访问Intent filter 添加一个或多个标记，每个标记代表一种解析为Activity的URI格式。标记必须至少包含android：scheme属性。 您可以添加更多属性以进一步优化Activity接受的URI类型。例如，您可能有多个Activity接受类似的URI，但这些Activity仅根据路径名称而有所不同。在这种情况下，使用android：path属性或其pathPattern或pathPrefix变体来区分系统应为不同的URI路径打开哪个Activity。 包括BROWSABLE category。为了从Web浏览器访问intent filter而需要它。没有它，单击浏览器中的链接无法解析为您的应用程序。 还包括DEFAULT category。这允许您的应用响应隐式Intent。如果没有这个，只有在intent指定您的应用程序组件名称时才能启动Activity。 以下XML代码段显示了如何在manifest中为Deep Links指定intent filter。“example://gizmos”` 和“http://www.example.com/gizmos”这两个URI均会指向次Activity： 请注意，两个intent filter仅因元素而不同。虽然可以在同一个过滤器中包含多个元素，但是当您打算声明唯一的URL（例如scheme和host的特定组合）时，创建单独的过滤器非常重要，因为实际上在同一个Intent filter下的多个元素会合并在一起，以考虑其组合属性的所有变体。例如，请考虑以下代码： ... 看起来该Intent filter仅仅会支持 https://www.example.com 和app://open.my.app，但是实际上他还另外支持这两个：app://www.example.com 和 https://open.my.app.(也就是说会被组合) 从传入的Intent中读取数据 一旦系统通过Intent filter启动您的Activity，您就可以使用Intent提供的数据来确定您需要呈现的内容。调用getData（）和getAction（）方法来取出与传入的Intent关联的数据和操作。您可以在Activity的生命周期中随时调用这些方法，但通常应该在早期回调期间执行此操作，例如onCreate（）或onStart（）。 这里展示了如何从Intent中取到数据： kotlin override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.main) val action: String? = intent?.action val data: Uri? = intent?.data } java @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Intent intent = getIntent(); String action = intent.getAction(); Uri data = intent.getData(); } 请遵循以下最佳做法以改善用户体验： deep link应该将用户直接带到内容（content），而无需任何提示、插页式页面，或者登录。即使用户之前从未打开过该应用程序也要确保用户可以直接查看应用程序内容。可以在后续交互时或从Launcher打开应用程序时提示用户。这与网站第一次免费体验的原则相同。 遵守“Navigation with Back and Up”中所述的设计指南，以便您的应用在用户通过Deep link进入应用后满足用户向后导航的期望。 测试你的Deep Links 您可以将 Android Debug Bridge 与activity manager（am）工具结合起来测试您为Deep Links指定的intent filter 的URI是否解析为正确的app Activity。您可以对设备或模拟器运行adb命令。 使用adb测试 Intent filter URI的一般语法是： $ adb shell am start -W -a android.intent.action.VIEW -d 例如，以下命令尝试查看与指定URI关联的目标应用程序的Activity。 $ adb shell am start -W -a android.intent.action.VIEW -d \"example://gizmos\" com.example.android 您在上面设置的manifest和Intent处理程序定义了您的应用程序和网站之间的连接以及如何处理传入链接。但是，为了让系统将您的应用视为一组URI的默认处理程序，您还必须请求系统验证此连接。下一节将介绍如何实施此验证。 想了解更多关于Intent和app links的内容，请参考： Intents and Intent Filters Allow Other Apps to Start Your Activity Add Android App Links with Android Studio "},"Activity/Handling-Android-App-Links/验证App-Links.html":{"url":"Activity/Handling-Android-App-Links/验证App-Links.html","title":"验证App Links","keywords":"","body":"处理Android APP Links——验证App Links 原文(英文)地址 Android APP Links是一种特殊类型的Deep Links，可让您的website URLs立即在Android应用中打开相应的内容（无需用户选择应用）。 要将Android APP Links添加到您的应用程序，请定义使用HTTP URL打开应用程序内容的Intent filter（如创建指向您内容的DeepLinks中所述），并验证您是否是应用程序和网站URL的拥有者（如本文档中所述）。如果系统成功验证您拥有URL，系统会自动将这些URL Intent路由到您的应用程序。 要验证您的应用和网站的所有权，需要执行以下步骤： 在您的manifest中请求自动应用链接验证。这向Android系统发出信号，表明它应该验证您的应用是否属于您的Intent filter中使用的URL域。 通过在以下地址托管数字资产链接JSON文件来声明您的网站与您的Intent filter之间的关系： https://domain.name/.well-known/assetlinks.json 你可以在以下资源中找到相关信息： Supporting URLs and App Indexing in Android Studio Creating a Statement List Deep Links和app Links的不同 Deep Links接是一种Intent filter，允许用户直接在Android应用中输入特定Activity。单击其中一个链接可能会打开一个消歧对话框，允许用户选择可以处理给定URL的多个应用程序（包括您的应用程序）中的一个。例如，图1显示了用户单击地图链接后的消歧对话框，询问是否在地图或Chrome中打开链接。 图一：消歧对话框 Android App Link是基于您的网站网址的Deep Links，该网址已经过验证，你拥有所有权。因此，如果已安装，则单击其中一个会立即打开您的应用程序，不显示消歧对话框。虽然用户可能稍后改变他们处理这些链接的偏好。 下表描述了更具体的差别。 Deep Links App Links Intent URL scheme http, https,或者自定义的 scheme http 或者 https Intent action 任何 action 需要 android.intent.action.VIEW Intent category 任何 category 需要 android.intent.category.BROWSABLEand android.intent.category.DEFAULT Link verification None 需要使用HTTPS在您的网站上提供的数字资产链接（Digital Asset Links）文件 User experience(用户体验) 可以显示消歧对话框，供用户选择打开链接的应用程序 没有对话框：您的应用将打开您的网站链接进行处理 Compatibility(兼容性) 所有Android 版本 Android 6.0 及以上 请求app links验证 要为您的应用启用链接处理验证，请在应用manifest文件中包含android.intent.action.VIEW intent action和android.intent.category.BROWSABLEintent category，如以下清单代码段所示： 当您的任何一个Intent filter上都存在android：autoVerify =“true”时，在Android 6.0及更高版本的设备上安装您的应用会导致系统尝试验证与您应用的任何Intent filter中的网址相关联的所有host。验证涉及以下内容： 系统检查所有Intent filter，包括： 动作(Action)：android.intent.action.VIEW 分类(Category)：android.intent.category.BROWSABLE和android.intent.category.DEFAULT 数据方案(Data scheme)：http或https 对于上述Intent filter中找到的每个唯一主机名，Android会在https：//hostname/.well-known/assetlinks.json上查询相应的数字资产链接文件网站。 仅当系统为manifest中的所有host找到匹配的数字资产链接文件时，它才会将您的应用程序建立为指定URL模式的默认处理程序。 支持多个主机（host）的app links 系统必须能够针对托管在所有相应Web域上的数字资产链接文件验证应用程序的URL intent过滤器数据元素中指定的每个host。如果任何验证失败，则应用程序不会被验证为应用程序的意Intent filter中定义的任何URL的默认处理程序。然后，系统默认使用其标准行为来解析Intent，如创建指向您内容的DeepLinks中所述。 比如，如果在https://www.example.com/.well-known/assetlinks.json 和 https://www.example.net/.well-known/assetlinks.json中均没有发现一个名为assetlinks.json的文件，则该intent filter的app将会验证失败： 请记住，同一Intent filter中的所有元素将组合在一起，以考虑其组合属性的所有变体。例如，上面的第一个intent过滤器包含一个只声明HTTPS方案的元素。但它与其他元素结合使用，因此intent过滤器同时支持http://www.example.com和https://www.example.com。因此，当您要定义URI方案和域的特定组合时，必须创建单独的intent filter。 创建支持多个子域（subdomains）的App links 数字资产链接协议将Intent filter中的子域视为唯一的独立主机。因此，如果您的intent filter列出了具有不同子域的多个主机，则必须将assetlinks.json发布在每个域上才有效 。例如，以下Intent filter包括www.example.com并且 mobile.example.com作为已接受的Intent URL主机。所以有效的 assetlinks.json必须同时发布在https://www.example.com/.well-known/assetlinks.json和https://mobile.example.com/.well-known/assetlinks.json。 或者，如果使用通配符（例如*.example.com）声明主机名，则assetlinks.json必须在根主机名（example.com）处被发布。例如，具有以下intent filter的应用程序将通过对example.com任何子名称（例如foo.example.com）的验证(只要该assetlinks.json文件在https://example.com/.well- known/assetlinks.json上被发布)： 声明网站关联(website associations) 一个数字资产链接 JSON文件必须在你的网站上公布，以指示与网站关联的Android应用并验证应用的URL Intent。JSON文件使用以下字段来标识关联的应用程序： package_name：在应用程序的build.gradle`文件中声明的 application ID sha256_cert_fingerprints：应用程序签名证书的SHA256指纹。您可以使用以下命令通过Java keytool生成指纹： $ keytool -list -v -keystore my-release-key.keystore ​ 此字段支持多个指纹，可用于支持应用程序的不同版本，例如调试和生产版本。 以下示例assetlinks.json文件授予com.exampleAndroid应用程序的链接开放权限 ： [{ \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.example\", \"sha256_cert_fingerprints\": [\"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"] } }] 将网站与多个App关联 网站可以在同一assetlinks.json 文件中声明与多个应用的关联。以下文件列表显示了一个声明文件的示例，该文件声明与两个应用程序的关联，并驻留在https://www.example.com/.well-known/assetlinks.json： [{ \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.example.puppies.app\", \"sha256_cert_fingerprints\": [\"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"] } }, { \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.example.monkeys.app\", \"sha256_cert_fingerprints\": [\"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"] } }] 不同的应用程序可以处理同一Web主机下的不同资源的链接。例如，app1可以声明一个intent过滤器https://example.com/articles，app2可以声明一个intent过滤器https://example.com/videos。 注意：与域（domain）关联的多个应用程序可能使用相同或不同的证书进行签名。 将多个网站与单个app进行关联 多个网站可以在各自的assetlinks.json文件中声明与同一应用程序的关联。以下文件列表显示了如何使用app1声明example.com和example.net的关联的示例。第一个list显示了example.com与app1的关联： https://www.example.com/.well-known/assetlinks.json: [{ \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.mycompany.app1\", \"sha256_cert_fingerprints\": [\"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"] } }] 下一个list显示了example.net与app1的关联。只是托管这些文件的位置不同（.com和.net）： https://www.example.net/.well-known/assetlinks.json: [{ \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.mycompany.app1\", \"sha256_cert_fingerprints\": [\"14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5\"] } }] 发布JSON验证文件 您必须在以下位置发布JSON验证文件： https：// domain.name /.well-known/assetlinks.json 确保以下内容： 该assetlinks.json文件以 application/json格式提供。 无论您的应用程序的Intent filter是否将HTTPS声明为数据方案，都必须可以通过HTTPS连接访问assetlinks.json文件。 该assetlinks.json文件必须可以访问，不需要任何重定向（没有301或302重定向），并且可以通过机器人访问（您robots.txt必须允许抓取 /.well-known/assetlinks.json）。 如果您的应用链接支持多个主机域，则必须在每个域上发布assetlinks.json文件。请参阅 支持多个主机（host）的app links。 不要在manifest文件中使用dev / test URL发布可能无法访问的应用程序（例如任何只能通过VPN访问的应用程序）。在这种情况下，解决方法是configure build variants以为开发构建生成不同的清单文件。 测试App links 在实现App links功能时，您应该测试链接功能，以确保系统可以将您的应用与您的网站相关联，并按照您的预期处理URL请求。 要测试现有语句文件，可以使用 Statement List Generator and Tester工具。 确定要验证的主机列表 测试时，您应确认系统应为您的应用验证的关联主机列表。列出其对应的intent filter，包含以下属性和元素的所有URL： android:scheme值为http或https android:host 具有域URL模式 android.intent.action.VIEW category元素 android.intent.category.BROWSABLE category元素 使用此列表检查每个命名主机和子域上是否提供了数字资产链接JSON文件。 确认数字资产链接文件 对于每个网站，使用Digital Asset Links API确认数字资产链接JSON文件已正确托管和定义： https://digitalassetlinks.googleapis.com/v1/statements:list? source.web.site=https://domain.name:optional_port& relation=delegate_permission/common.handle_all_urls 测试一个URL Intent 确认要与您的应用关联的网站列表，并确认托管的JSON文件有效后，请在您的设备上安装该应用。等待至少20秒以完成异步验证过程。使用以下命令检查系统是否验证了您的应用程序并设置了正确的链接处理策略（policies）： adb shell am start -a android.intent.action.VIEW \\ -c android.intent.category.BROWSABLE \\ -d \"http://domain.name:optional_port\" 检查链接策略 作为测试过程的一部分，您可以检查当前系统设置以进行链接处理。使用以下命令获取所连接设备上所有应用程序的现有链接处理策略列表： adb shell dumpsys package domain-preferred-apps 或者也可以通过以下命令达到同样的目的： adb shell dumpsys包d 注意：确保在安装应用程序后至少等待20秒，以便系统完成验证过程。 该命令返回设备上定义的每个用户或配置文件的列表，前面带有以下格式的标头： App linkages for user 0: 在此header之后，输出使用以下格式列出该用户的链接处理设置： Package: com.android.vending Domains: play.google.com market.android.com Status: always : 200000002 此列表指出哪些应用与该用户的哪些域相关联： Package - 根据其清单中声明的包名称标识应用程序。 Domains - 使用空格作为分隔符，显示此应用处理其Web链接的主机的完整列表。 Status - 显示此应用的当前链接处理设置。已通过验证且其清单包含的应用程序android:autoVerify=\"true\"显示状态为always。此状态后的十六进制数与Android系统的用户应用程序链接首选项记录相关。该值不表示验证是否成功。 注意：如果用户在验证完成之前更改了应用的应用链接设置，即使验证失败，您也可能会看到成功验证的误报。但是，如果用户明确启用应用程序以打开支持的链接而不询问，则此验证失败无关紧要。这是因为用户首选项优先于编程验证（或缺少编程验证）。因此，该链接直接进入您的应用程序，而不显示对话框，就像验证成功一样。 测试示例 要使应用链接验证成功，系统必须能够使用您在应用的Intent filter中指定的所有网站验证您的应用，并且该网站符合应用链接的条件。以下示例显示了定义了多个应用程序链接的清单配置： 平台尝试从以上清单验证的主机列表是： www.example.com mobile.example.com www.example2.com account.example.com 平台不会尝试从上面的清单验证的主机列表是： map.example.com (it does not have android.intent.category.BROWSABLE) market://example.com (it does not have either an “http” or “https” scheme) 要了解有关语句列表的更多信息，请参阅Creating a Statement List. "},"Activity/Handling-Android-App-Links/为Instant-APPs创建App-Links.html":{"url":"Activity/Handling-Android-App-Links/为Instant-APPs创建App-Links.html","title":"为Instant APPs创建App Links","keywords":"","body":"处理Android APP Links——为Instant APPs创建App Links 原文(英文)地址 Android Instant APP是您的应用程序的小版本（small version），无需安装即可运行。用户只需点击网址即可启动您的应用，而不是安装APK。因此，所有Instant APP都需要通过使用Android App Links声明的URL进行访问。本页介绍了如何为 Android Instant Apps使用Android App Links。 注意：如果您没有Instant APP，那么您不需要阅读本指南,您应该通过阅读 创建指向您内容的Deep Links 来为您的可安装应用程序创建应用程序链接。 App link概述 首先，这里是您应该了解的app links.的摘要： 当您为应用中的Activity创建一个intent filter，允许用户使用URL链接直接跳转到应用中的特定屏幕时，这称为“Deep Link”。但是，其他应用程序可以声明类似的URL Intent filter，因此系统可能会询问用户打开哪个应用程序。要创建这些Deep Link，请阅读 创建指向您内容的Deep Links 。 当您在与应用程序的HTTP Deep Link对应的网站上发布assetlinks.json文件时，您就可以验证您的应用是否是这些URL的真正所有者。因此，您已将Deep Link转换为Android App Link，这可确保您的应用在用户点击此类网址时立即打开。要创建App Link，请阅读 验证App Links。 因此，Android App Links只是您的网站经过验证的HTTP深层链接，因此用户无需选择要打开的应用程序。有关更具体的说明，请参阅深层链接和应用链接之间的差异。 但是，在这两种情况下，用户必须已安装您的应用程序。如果用户单击您的某个网站链接并且他们没有安装您的应用程序（并且没有其他应用程序处理该URL Intent），则会在Web浏览器中打开该URL。因此，创建Instant Apps可解决此问题 ，它允许用户通过简单地单击URL来打开您的应用程序，即使他们没有安装您的应用程序。 当最终用户对您的应用执行Google搜索时，Google搜索会显示带有“即时”徽章的网址。 Instant App的App Link有何不同 如果你已经阅读了 创建指向您内容的Deep Links 和 验证App Links，那么你已经完成了使app link与你的Instant App一起工作所需的大部分工作。使用Instant App的App link时，还有一些额外的规定： 在您的Instant App中用作App link的所有Intent filter必须同时支持HTTP和HTTPS。例如： 请注意，您不需要在第二个元素中包含host，因为在每个元素中，每个属性的所有组合都被视为有效（因此此intent过滤器也会解析https：/ /www.example.com）。 每个网站域(domain)只能声明一个Instant app。 （这与为可安装应用程序创建App link时不同，后者允许您将网站与多个应用程序相关联。） 创建App link时的其他提醒 您的Instant App中的所有HTTP URL Intent filter都应包含在您的可安装应用中。这很重要，因为一旦用户安装完整的应用程序，点击URL应始终打开已安装的应用程序，而不是Instant App 您必须在即时和可安装应用程序中的至少一个intent过滤器中设置autoVerify =“true”。 （了解 enable automatic verification。） 您必须为每个域（domain）使用HTTPS协议（以及App link支持的子域）发布一个assetlinks.json。（请参阅 验证App Links中支持多个主机（host）的app links部分）。 assetlinks.json文件必须是有效的JSON，无需重定向即可提供，并且可供机器人访问（您的robots.txt必须允许抓取/.well-known/assetlinks.json）。 建议不要在intent filter的host属性中使用通配符。 （了解 验证App Links中创建支持多个子域（subdomains）的App links部分） 应使用单独的intent filter声明自定义host/scheme URL。 确保您的App Link网址占据关键字词的热门搜索结果。 "},"Activity/加载器.html":{"url":"Activity/加载器.html","title":"加载器","keywords":"","body":"加载器 原文(英文)地址 从Android P（API 28）开始，已经弃用了Loader。在Activity和Fragment的生命周期中处理加载数据的推荐做法是使用ViewModels和LiveData的组合。 ViewModels可以承受像Loaders这样的配置更改，但具有更少的样板（boilerplate）。 LiveData提供了一种生命周期感知的加载数据的方法，您可以在多个ViewModel中重复使用。您还可以使用MediatorLiveData组合LiveData，并且可以使用任何可观察的查询（例如来自Room数据库的查询）来观察对数据的更改。 ViewModels和LiveData也可用于无法访问LoaderManager,的情况，例如Service中。配合使用这两者可以轻松访问应用程序所需的数据，而无需处理UI生命周期。要了解有关LiveData的更多信息，请参阅 LiveData guide，了解有关ViewModel的更多信息，请参阅ViewModel guide。 Loader API允许您从Content provider或其他数据源加载数据，以便在FragmentActivity或Fragment中显示。如果您不理解为什么需要Loader API来执行这个看似微不足道的操作，那么首先要考虑一些不使用加载器时可能遇到的问题： 如果直接在Activity或Fragment中获取数据，则由于在UI线程执行可能较慢的查询，您的用户将不能及时得到响应。 如果您从另一个线程（可能使用AsyncTask）获取数据，那么您负责通过各种Activity或Fragment生命周期事件（例如onDestroy（）和配置更改）来管理线程和UI线程。 装载器解决了这些问题，并包含其他优点，例如： 加载程序在不同的线程上运行，以防止janky或无响应的UI。 加载程序通过在事件发生时提供回调方法来简化线程管理。 加载程序会持久存储并在配置更改中缓存结果，以防止重复查询。 加载程序可以实现观察器来监视基础数据源的更改。例如，CursorLoader自动注册ContentObserver以在数据更改时触发重新加载。 Loader API摘要 在应用程序中使用加载器时可能涉及多个类和接口。它们总结在此表中： 类/接口 描述 LoaderManager 与FragmentActivity或Fragment关联的抽象类，用于管理一个或多个Loader实例。每个Activity或Fragment只有一个LoaderManager，但LoaderManager可以管理多个加载器。要获取LoaderManager，请从Activity或Fragment中调用getSupportLoaderManager（）。要从加载器开始加载数据，请调用initLoader（)restartLoader（）。系统自动确定具有相同整数ID的加载器是否已存在，并将创建新加载器或重用现有加载器。 LoaderManager.LoaderCallbacks 此接口包含在加载器事件发生时调用的回调方法。该接口定义了三种回调方法：onCreateLoader（int，Bundle）：当系统需要创建新的加载器时调用。您的代码应该创建一个Loader对象并将其返回给系统。onLoadFinished（Loader ，D）： 在加载程序完成加载数据时调用。通常，您的代码应该向用户显示数据。onLoaderReset（Loader ） ：在重置先前创建的加载器时（当您调用destroyLoader（int）时或者当Activity或Fragment被销毁时调用，从而使其数据不可用。您的代码应删除它具有的任何引用）加载器的数据。此接口通常由您的Activity或Fragment实现，并在您调用initLoader（）或restartLoader（）时进行注册。 Loader 加载程序执行数据加载。这个类是抽象的，并且作为所有加载器的基类。您可以直接将Loader子类化，也可以使用以下内置子类之一来简化实现：AsyncTaskLoader :一个抽象加载器，它提供AsyncTask以在单独的线程上执行加载操作。CursorLoader ：AsyncTaskLoader的具体子类，用于从ContentProvider异步加载数据。它查询ContentResolver并返回一个Cursor。 以下内容会向您介绍如何在您的应用中使用这些类和接口。 在应用中使用加载器 本节介绍如何在Android应用程序中使用加载器。使用加载器的应用程序通常包括以下内容： FragmentActivity或Fragment。 LoaderManager的一个实例。 用于加载ContentProvider支持的数据的CursorLoader。或者，您可以实现自己的Loader或AsyncTaskLoader子类来从其他来源加载数据。 LoaderManager.LoaderCallbacks的实现。您可以在此处创建新的加载器并管理对现有加载器的引用。 一种显示加载程序数据的方法，例如SimpleCursorAdapter。 使用CursorLoader时的数据源，如ContentProvider。 开启一个Loader 在一个FragmentActivity或者Fragment中的LoaderManager可以管理一个或多个Loader实例，在一个Activity或Fragment中只能有一个LoadManager。 你可以在Activity的onCreate()方法或者Fragment的onCreateView()方法中初始化Loader，就像下面这样： kotlin supportLoaderManager.initLoader(0, null, this) java // Prepare the loader. Either re-connect with an existing one, // or start a new one. getSupportLoaderManager().initLoader(0, null, this); initLoader()有以下几个参数： 一个唯一的ID，在这个例子中ID是0 在构造时提供给加载器的可选参数，在这里是null 一个LoaderManag.LoaderCallbacks的实现，LoaderManager调用他来报告加载器事件。在这个例子中，本地类实现了LoaderManager.LoaderCallbacks接口，因此它将本身作为参数传递进去。 initLoader（）方法确保加载器初始化并处于活动状态。它有两种可能的结果： 如果ID指定的加载器已存在，则重用最后创建的加载器。 如果ID指定的加载器不存在，initLoader（）将触发LoaderManager.LoaderCallbacks中的onCreateLoader（）。这是您实例化并返回新加载器的代码。有关更多讨论，请参阅onCreateLoader一节。 在任何一种情况下，给定的LoaderManager.LoaderCallbacks实现都与加载器相关联，并在加载器状态改变时被调用。如果在调用时initLoader（）时调用者处于该Loader的启动状态，并且请求的加载器已经存在并且已生成其数据，则系统立即调用onLoadFinished（）（在initLoader（）期间），因此您必须为此做好准备发生。有关此回调的更多讨论，请参阅onLoadFinished 请注意，initLoader（）方法返回已创建的Loader，但您无需捕获对它的引用。 LoaderManager自动管理Loader的生命周期。 LoaderManager会在必要时启动和停止加载，并维护加载器及其相关内容的状态。这意味着，您很少直接与加载器交互。您一般应该使用LoaderManager.LoaderCallbacks中的方法在特定事件发生时干预加载过程。有关此主题的更多讨论，请参阅 Using the LoaderManager Callbacks.。 重启加载器 当您像如上所述使用initLoader（）时，它将使用具有指定ID的现有加载器（如果有），如果没有，它会创建一个。但有时您想要丢弃旧数据并重新开始。 要丢弃旧数据，请使用restartLoader（）。例如，当用户的查询更改时，这个SearchView.OnQueryTextListener的实现会重新启动加载程序。需要重新启动加载程序，以便它可以使用修订的搜索过滤器来执行新查询： kotlin fun onQueryTextChanged(newText: String?): Boolean { // Called when the action bar search text has changed. Update // the search filter, and restart the loader to do a new query // with this filter. curFilter = if (newText?.isNotEmpty() == true) newText else null supportLoaderManager.restartLoader(0, null, this) return true } java public boolean onQueryTextChanged(String newText) { // Called when the action bar search text has changed. Update // the search filter, and restart the loader to do a new query // with this filter. curFilter = !TextUtils.isEmpty(newText) ? newText : null; getSupportLoaderManager().restartLoader(0, null, this); return true; } 使用LoaderManager回调 LoaderManager.LoaderCallbacks是一个回调接口，允许客户端与LoaderManager交互。 Loader，特别是CursorLoader，应该在停止后保留其数据。这允许应用程序将数据保存在Activity或Fragment的onStop（）和onStart（）方法中，这样当用户返回应用程序时，他们不必等待数据重新加载。您可以使用LoaderManager.LoaderCallbacks方法知道何时创建新的加载器，并告知应用程序何时停止使用加载器的数据。 LoaderManager.LoaderCallbacks包括以下方法： onCreateLoader（） - 实例化并返回给定ID的新Loader。 onLoadFinished（） - 在先前创建的加载器完成其加载时调用。 onLoaderReset（） - 在重置先前创建的加载器时调用，从而使其数据不可用。 以下各节将更详细地介绍这些方法。 onCreateLoader() 当您尝试访问加载程序时（例如，通过initLoader（）），它会检查ID指定的加载程序是否存在。如果没有，则触发LoaderManager.LoaderCallbacks的onCreateLoader（）方法，这是您创建新加载器的位置。通常这是一个CursorLoader，但您可以实现自己的Loader子类。 在此示例中，onCreateLoader（）回调方法创建CursorLoader。您必须使用其构造函数方法构建CursorLoader，构建时需要提供ContentProvider查询时所需的完整信息。具体来说，它需要： uri - 要检索的内容的URI。 projection - 要返回的列的列表。传递null将返回所有列，这是低效的。 selection - 一个过滤器，声明要返回哪些行，格式化为SQL WHERE子句（不包括WHERE本身）。传递null将返回给定URI的所有行。 selectionArgs - 您可以在选择中包含？s，它将被selectionArgs中的值替换，按它们在选择中出现的顺序。这些值将绑定为字符串。 sortOrder - 如何对行进行排序，格式化为SQL ORDER BY子句（不包括ORDER BY本身）。传递null将使用默认排序顺序，该顺序可能是无序的。 比如： kotlin // If non-null, this is the current filter the user has provided. private var curFilter: String? = null ... override fun onCreateLoader(id: Int, args: Bundle?): Loader { // This is called when a new Loader needs to be created. This // sample only has one Loader, so we don't care about the ID. // First, pick the base URI to use depending on whether we are // currently filtering. val baseUri: Uri = if (curFilter != null) { Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_URI, Uri.encode(curFilter)) } else { ContactsContract.Contacts.CONTENT_URI } // Now create and return a CursorLoader that will take care of // creating a Cursor for the data being displayed. val select: String = \"((${Contacts.DISPLAY_NAME} NOTNULL) AND (\" + \"${Contacts.HAS_PHONE_NUMBER}=1) AND (\" + \"${Contacts.DISPLAY_NAME} != ''))\" return (activity as? Context)?.let { context -> CursorLoader( context, baseUri, CONTACTS_SUMMARY_PROJECTION, select, null, \"${Contacts.DISPLAY_NAME} COLLATE LOCALIZED ASC\" ) } ?: throw Exception(\"Activity cannot be null\") } java // If non-null, this is the current filter the user has provided. String curFilter; ... public Loader onCreateLoader(int id, Bundle args) { // This is called when a new Loader needs to be created. This // sample only has one Loader, so we don't care about the ID. // First, pick the base URI to use depending on whether we are // currently filtering. Uri baseUri; if (curFilter != null) { baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI, Uri.encode(curFilter)); } else { baseUri = Contacts.CONTENT_URI; } // Now create and return a CursorLoader that will take care of // creating a Cursor for the data being displayed. String select = \"((\" + Contacts.DISPLAY_NAME + \" NOTNULL) AND (\" + Contacts.HAS_PHONE_NUMBER + \"=1) AND (\" + Contacts.DISPLAY_NAME + \" != '' ))\"; return new CursorLoader(getActivity(), baseUri, CONTACTS_SUMMARY_PROJECTION, select, null, Contacts.DISPLAY_NAME + \" COLLATE LOCALIZED ASC\"); } onLoadFinished() 当先前创建的加载器完成其加载时，将调用此方法。保证在释放为此加载器提供的最后一个数据之前调用此方法。此时你应该移除旧数据的所有使用（因为它将很快发布（release）），但不应该自己发布数据，因为它的加载器拥有它并将处理它。 一旦知道应用程序不再使用它，加载程序就会释放数据。例如，如果数据是来自CursorLoader的游标（Cursor），则不应自行调用close（）。如果游标放在CursorAdapter中，则应使用swapCursor（）方法，以便旧的Cursor不被关闭。例如： kotlin private lateinit var adapter: SimpleCursorAdapter ... override fun onLoadFinished(loader: Loader, data: Cursor?) { // Swap the new cursor in. (The framework will take care of closing the // old cursor once we return.) adapter.swapCursor(data) } java // This is the Adapter being used to display the list's data. SimpleCursorAdapter adapter; ... public void onLoadFinished(Loader loader, Cursor data) { // Swap the new cursor in. (The framework will take care of closing the // old cursor once we return.) adapter.swapCursor(data); } onLoaderReset() 当重置先前创建的加载器时调用此方法，从而使其数据不可用。此回调可让您找出数据即将发布的时间，以便您可以删除对它的引用。 此实现使用null值调用swapCursor（）： kotlin private lateinit var adapter: SimpleCursorAdapter ... override fun onLoaderReset(loader: Loader) { // This is called when the last Cursor provided to onLoadFinished() // above is about to be closed. We need to make sure we are no // longer using it. adapter.swapCursor(null) } java // This is the Adapter being used to display the list's data. SimpleCursorAdapter adapter; ... public void onLoaderReset(Loader loader) { // This is called when the last Cursor provided to onLoadFinished() // above is about to be closed. We need to make sure we are no // longer using it. adapter.swapCursor(null); } 例子 作为示例，这里是Fragmrnt的完整实现，其显示包含针对联系人Content provider的查询结果的ListView。它使用CursorLoader来管理provider上的查询。 对于访问用户联系人的应用程序，如此示例所示，其manifest必须包含权限READ_CONTACTS： kotlin ```kotlin private val CONTACTS_SUMMARY_PROJECTION: Array = arrayOf( Contacts._ID, Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS, Contacts.CONTACT_PRESENCE, Contacts.PHOTO_ID, Contacts.LOOKUP_KEY ) class CursorLoaderListFragment : ListFragment(), SearchView.OnQueryTextListener, LoaderManager.LoaderCallbacks { // This is the Adapter being used to display the list's data. private lateinit var mAdapter: SimpleCursorAdapter // If non-null, this is the current filter the user has provided. private var curFilter: String? = null override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // Give some text to display if there is no data. In a real // application this would come from a resource. setEmptyText(\"No phone numbers\") // We have a menu item to show in action bar. setHasOptionsMenu(true) // Create an empty adapter we will use to display the loaded data. mAdapter = SimpleCursorAdapter(activity, android.R.layout.simple_list_item_2, null, arrayOf(Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS), intArrayOf(android.R.id.text1, android.R.id.text2), 0 ) listAdapter = mAdapter // Prepare the loader. Either re-connect with an existing one, // or start a new one. loaderManager.initLoader(0, null, this) } override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) { // Place an action bar item for searching. menu.add(\"Search\").apply { setIcon(android.R.drawable.ic_menu_search) setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM) actionView = SearchView(activity).apply { setOnQueryTextListener(this@CursorLoaderListFragment) } } } override fun onQueryTextChange(newText: String?): Boolean { // Called when the action bar search text has changed. Update // the search filter, and restart the loader to do a new query // with this filter. curFilter = if (newText?.isNotEmpty() == true) newText else null loaderManager.restartLoader(0, null, this) return true } override fun onQueryTextSubmit(query: String): Boolean { // Don't care about this. return true } override fun onListItemClick(l: ListView, v: View, position: Int, id: Long) { // Insert desired behavior here. Log.i(\"FragmentComplexList\", \"Item clicked: $id\") } override fun onCreateLoader(id: Int, args: Bundle?): Loader { // This is called when a new Loader needs to be created. This // sample only has one Loader, so we don't care about the ID. // First, pick the base URI to use depending on whether we are // currently filtering. val baseUri: Uri = if (curFilter != null) { Uri.withAppendedPath(Contacts.CONTENT_URI, Uri.encode(curFilter)) } else { Contacts.CONTENT_URI } // Now create and return a CursorLoader that will take care of // creating a Cursor for the data being displayed. val select: String = \"((${Contacts.DISPLAY_NAME} NOTNULL) AND (\" + \"${Contacts.HAS_PHONE_NUMBER}=1) AND (\" + \"${Contacts.DISPLAY_NAME} != ''))\" return (activity as? Context)?.let { context -> CursorLoader( context, baseUri, CONTACTS_SUMMARY_PROJECTION, select, null, \"${Contacts.DISPLAY_NAME} COLLATE LOCALIZED ASC\" ) } ?: throw Exception(\"Activity cannot be null\") } override fun onLoadFinished(loader: Loader, data: Cursor) { // Swap the new cursor in. (The framework will take care of closing the // old cursor once we return.) mAdapter.swapCursor(data) } override fun onLoaderReset(loader: Loader) { // This is called when the last Cursor provided to onLoadFinished() // above is about to be closed. We need to make sure we are no // longer using it. mAdapter.swapCursor(null) } } - java ```java public static class CursorLoaderListFragment extends ListFragment implements OnQueryTextListener, LoaderManager.LoaderCallbacks { // This is the Adapter being used to display the list's data. SimpleCursorAdapter mAdapter; // If non-null, this is the current filter the user has provided. String curFilter; @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); // Give some text to display if there is no data. In a real // application this would come from a resource. setEmptyText(\"No phone numbers\"); // We have a menu item to show in action bar. setHasOptionsMenu(true); // Create an empty adapter we will use to display the loaded data. mAdapter = new SimpleCursorAdapter(getActivity(), android.R.layout.simple_list_item_2, null, new String[] { Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS }, new int[] { android.R.id.text1, android.R.id.text2 }, 0); setListAdapter(mAdapter); // Prepare the loader. Either re-connect with an existing one, // or start a new one. getLoaderManager().initLoader(0, null, this); } @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) { // Place an action bar item for searching. MenuItem item = menu.add(\"Search\"); item.setIcon(android.R.drawable.ic_menu_search); item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM); SearchView sv = new SearchView(getActivity()); sv.setOnQueryTextListener(this); item.setActionView(sv); } public boolean onQueryTextChange(String newText) { // Called when the action bar search text has changed. Update // the search filter, and restart the loader to do a new query // with this filter. curFilter = !TextUtils.isEmpty(newText) ? newText : null; getLoaderManager().restartLoader(0, null, this); return true; } @Override public boolean onQueryTextSubmit(String query) { // Don't care about this. return true; } @Override public void onListItemClick(ListView l, View v, int position, long id) { // Insert desired behavior here. Log.i(\"FragmentComplexList\", \"Item clicked: \" + id); } // These are the Contacts rows that we will retrieve. static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] { Contacts._ID, Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS, Contacts.CONTACT_PRESENCE, Contacts.PHOTO_ID, Contacts.LOOKUP_KEY, }; public Loader onCreateLoader(int id, Bundle args) { // This is called when a new Loader needs to be created. This // sample only has one Loader, so we don't care about the ID. // First, pick the base URI to use depending on whether we are // currently filtering. Uri baseUri; if (curFilter != null) { baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI, Uri.encode(curFilter)); } else { baseUri = Contacts.CONTENT_URI; } // Now create and return a CursorLoader that will take care of // creating a Cursor for the data being displayed. String select = \"((\" + Contacts.DISPLAY_NAME + \" NOTNULL) AND (\" + Contacts.HAS_PHONE_NUMBER + \"=1) AND (\" + Contacts.DISPLAY_NAME + \" != '' ))\"; return new CursorLoader(getActivity(), baseUri, CONTACTS_SUMMARY_PROJECTION, select, null, Contacts.DISPLAY_NAME + \" COLLATE LOCALIZED ASC\"); } public void onLoadFinished(Loader loader, Cursor data) { // Swap the new cursor in. (The framework will take care of closing the // old cursor once we return.) mAdapter.swapCursor(data); } public void onLoaderReset(Loader loader) { // This is called when the last Cursor provided to onLoadFinished() // above is about to be closed. We need to make sure we are no // longer using it. mAdapter.swapCursor(null); } } 更多例子 以下示例说明了如何使用加载器： LoaderCursor - 上面例子的完整版代码段。 Retrieving a List of Contacts - 使用CursorLoader从联系人provider检索数据的示例。 LoaderThrottle- 如何使用限制来减少content provider程序在数据更改时执行的查询数量的示例。 AsyncTaskLoader - 使用AsyncTaskLoader从包管理器加载当前安装的应用程序的示例。 "},"Activity/最近任务界面.html":{"url":"Activity/最近任务界面.html","title":"最近任务界面","keywords":"","body":"最近任务界面 原文(英文)地址 “Recents”屏幕（screen）（也称为“OverView”屏幕，最近的任务列表或最近的应用程序）是一个系统级UI，列出最近访问的活动（Activity）和任务（task）。用户可以浏览列表并选择要恢复的任务，或者用户可以通过将其移除来从列表中删除任务。 Android 5.0（API级别21）引入了 document-centric模型，其中包含在不同文档（document）的同一Activity的多个实例可能在“最近”屏幕中显示为任务。例如，Google云端硬盘可能会为多个Google文档中的每个文档执行任务。每个文档在“最近”屏幕中均显示为任务。 图一：“Recents”屏幕显示三个Google云端硬盘文档，每个文档都表示为单独的任务。 另一个常见示例是当用户使用他们的浏览器时，他们点击分享---> Gmail。将显示Gmail应用程序的“编辑”屏幕。此时点按“最近”按钮会显示Chrome和Gmail分别作为单独的任务运行。在较低版本的Android中，所有Activity都显示为单个任务，使“后退”按钮成为唯一的导航方式。图2显示了与平台的较低版本相比，最高安卓屏幕在Android 5.0及更高版本中的外观。 Android 5.0及更高版本的左侧屏幕上的图像，右侧的图像显示了它在Android的较低版本中的显示方式。 图二：\"最近\"屏幕在Android5.0及以上(左)和Android5.0以上（右）的区别 通常，您应该允许系统在“最近”屏幕中定义您的任务和活动的表示方式，而不需要修改此行为。但是，您的应用可以确定活动在“最近”屏幕中的显示方式和时间。 ActivityManager.AppTask类允许您管理任务，Intent类的Activity标志允许您指定何时在“最近”屏幕中添加或删除活动。此外，允许您在manifest中通过设置的属性来达到此目的。 向最近屏幕添加任务 使用Intent类的flag添加任务可以更好地控制document在“最近”屏幕中何时以及如何打开或重新打开。使用属性时，您可以选择始终在新任务中打开document或重用document的现有任务。 使用Intent flag添加task 为Activity创建新document时，可以调用startActivity（）方法，并向其传递启动Activity的Intent。要插入逻辑中断（logical break）以便系统将您的Activity视为“最近”屏幕中的新任务，请在启动Activity的Intent的addFlags（）方法中传递FLAG_ACTIVITY_NEW_DOCUMENT标志。 注意：FLAG_ACTIVITY_NEW_DOCUMENT标志替换了FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET标志，该标志自Android 5.0（API级别21）起不推荐使用。 如果在创建新document时设置FLAG_ACTIVITY_MULTIPLE_TASK标志，则系统始终以目标活动为根创建新任务。此设置允许在多个任务中打开同一文档。以下代码演示了Main Activity如何执行此操作： kotlin fun createNewDocument(view: View) { val newDocumentIntent = newDocumentIntent() if (useMultipleTasks) { newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK) } startActivity(newDocumentIntent) } private fun newDocumentIntent(): Intent = Intent(this, NewDocumentActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT or android.content.Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, documentCounter++) } java DocumentCentricActivity.java public void createNewDocument(View view) { final Intent newDocumentIntent = newDocumentIntent(); if (useMultipleTasks) { newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK); } startActivity(newDocumentIntent); } private Intent newDocumentIntent() { boolean useMultipleTasks = checkbox.isChecked(); final Intent newDocumentIntent = new Intent(this, NewDocumentActivity.class); newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT); newDocumentIntent.putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, documentCounter++); return newDocumentIntent; } } 注意：使用FLAG_ACTIVITY_NEW_DOCUMENT标志启动的Activity必须在manifest中设置android：launchMode =“standard”属性值（默认值）。 当main activity启动新activity时，系统会在现有任务中搜索一个与Intent component name和Intent data 匹配的task。如果未找到task，或者intent包含FLAG_ACTIVITY_MULTIPLE_TASK标志，则将创建一个以Activity为根的新任务。如果找到一个，它会将该任务带到前面并将新Intent传递给onNewIntent（）。新Activity获取Intent并在“最近”屏幕中创建新document，如以下示例所示： kotlin override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_new_document) documentCount = intent .getIntExtra(DocumentCentricActivity.KEY_EXTRA_NEW_DOCUMENT_COUNTER, 0) documentCounterTextView = findViewById(R.id.hello_new_document_text_view) setDocumentCounterText(R.string.hello_new_document_counter) } override fun onNewIntent(newIntent: Intent) { super.onNewIntent(newIntent) /* If FLAG_ACTIVITY_MULTIPLE_TASK has not been used, this Activity will be reused. */ setDocumentCounterText(R.string.reusing_document_counter) } java NewDocumentActivity.java @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_new_document); documentCount = getIntent() .getIntExtra(DocumentCentricActivity.KEY_EXTRA_NEW_DOCUMENT_COUNTER, 0); documentCounterTextView = (TextView) findViewById( R.id.hello_new_document_text_view); setDocumentCounterText(R.string.hello_new_document_counter); } @Override protected void onNewIntent(Intent intent) { super.onNewIntent(intent); /* If FLAG_ACTIVITY_MULTIPLE_TASK has not been used, this activity is reused to create a new document. */ setDocumentCounterText(R.string.reusing_document_counter); } 通过设置Activity attribute添加task Activity还可以在其清单中指定它始终通过使用的android：documentLaunchMode属性启动到新任务。此属性有四个值，当用户使用应用程序打开document时，这些值会产生以下效果： “intoExisting” Activity重用该文档的现有task。这与设置FLAG_ACTIVITY_NEW_DOCUMENT标志而不设置FLAG_ACTIVITY_MULTIPLE_TASK标志相同，如上面使用Intent标志添加任务中所述。 “always” 即使document已经打开，activity也会为document创建新任务。使用此值与设置FLAG_ACTIVITY_NEW_DOCUMENT和FLAG_ACTIVITY_MULTIPLE_TASK标志相同。 “none” Activity不会为document创建新任务。 “最近”窗口按默认情况处理activity：它显示应用程序的单个任务，该任务从用户上次调用的任何activity中恢复。 “never” Activity不会为document创建新任务。设置此值将覆盖FLAG_ACTIVITY_NEW_DOCUMENT和FLAG_ACTIVITY_MULTIPLE_TASK标志的行为，如果在intent中设置了其中任何一个，并且“最近”屏幕显示应用程序的单个任务，该任务将从用户上次调用的任何activity中恢复。 注意：对于非none以外的值，永远不必使用launchMode =“standard”定义activity。如果未指定此属性，则使用documentLaunchMode =“none”。 移除task 默认情况下，documen task在其activity完成时会自动从“最近”屏幕中删除。您可以使用ActivityManager.AppTask类，使用Intent标志或使用属性覆盖此行为。 您始终可以通过将的android：excludeFromRecents属性设置为true从“最近”屏幕中排除任务。 您可以通过将的android：maxRecents属性设置为整数值来设置应用程序可以包含在“最近”窗口中的最大任务数。默认值为16.达到最大任务数时，将从“最近”屏幕中删除最近最少使用的任务。 android：maxRecents最大值为50（低内存设备上为25）;小于1的值无效。 使用AppTask类移除task 在“最近”窗口中创建新任务的Activity中，您可以通过调用finishAndRemoveTask（）方法指定何时删除任务并finish与其关联的所有Activity。 kotlin fun onRemoveFromOverview(view: View) { // It is good pratice to remove a document from the overview stack if not needed anymore. finishAndRemoveTask() } java public void onRemoveFromRecents(View view) { // The document is no longer needed; remove its task. finishAndRemoveTask(); } 注意：使用finishAndRemoveTask（）方法会覆盖FLAG_ACTIVITY_RETAIN_IN_RECENTS标记的使用，如下所述。 保留已完成的task 如果你想在最近任务中保留一个即使他的activity已经finishedtask，应该在启动activity的Intent的addFlags（）方法中传递FLAG_ACTIVITY_RETAIN_IN_RECENTS标志。 kotlin private fun newDocumentIntent() = Intent(this, NewDocumentActivity::class.java).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT or android.content.Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, getAndIncrement()) } java private Intent newDocumentIntent() { final Intent newDocumentIntent = new Intent(this, NewDocumentActivity.class); newDocumentIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | android.content.Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS); newDocumentIntent.putExtra(KEY_EXTRA_NEW_DOCUMENT_COUNTER, getAndIncrement()); return newDocumentIntent; } 要达到相同的效果，请将属性android：autoRemoveFromRecents设置为false。document activity的默认值为true，常规activity的默认值为false。使用此属性会覆盖之前讨论的FLAG_ACTIVITY_RETAIN_IN_RECENTS标志。 其他的示例代码 要下载有关以document centric的示例应用，请参见 Android DocumentCentricRecents Sample 和 Android DocumentCentricRelinquishIdentity Sample. "},"Activity/AppShortCuts/概述.html":{"url":"Activity/AppShortCuts/概述.html","title":"概述","keywords":"","body":"概述 原文(英文)地址 作为开发人员，您可以定义快捷方式以在应用中执行特定操作。这些快捷方式可以显示在支持的启动器中，帮助用户快速启动应用中的常见的或推荐的任务。 本文档教您如何创建和管理应用程序快捷方式。此外，您将学习一些可以改善快捷方式效果的最佳实践。 快捷方式的类型 每个快捷方式引用一个或多个Intent，当用户选择快捷方式时，每个Intent都会在应用中启动特定操作。您为应用创建的快捷方式类型取决于应用的关键用例。下面是几个您可以表示为快捷方式的示例操作包括： 在电子邮件应用中撰写新电子邮件。 将用户导航到地图应用中的特定位置。 在通信应用中向朋友发送消息。 在媒体应用中播放电视节目的下一集。 在游戏应用中加载最后一个保存点。 注意：只有处理Intent.ACTION_MAIN操作和Intent.CATEGORY_LAUNCHER类别的Main Activity 才能有快捷方式。如果应用程序有多个main activity，则需要为每个Activity定义一组快捷方式。 您可以为您的应用发布以下类型的快捷方式： 静态快捷方式：在打包到APK或应用程序包中的资源文件中定义。 动态快捷方式：只有在运行时，您的应用才能发布，更新和删除。 如果用户授予权限，则可以在运行时将固定快捷方式添加到受支持的启动器。 注意：用户还可以通过将应用程序的静态和动态快捷方式复制到启动器上来创建固定快捷方式。 快捷方式的限制 虽然您可以一次为应用程序发布最多五个快捷方式（静态和动态快捷方式一共最多5个），但大多数启动器只能显示四个。 但是，用户为你的应用程序创建的快捷方式的数量没有限制。即使您的应用无法删除固定的快捷方式，它仍然可以禁用它们。 注意：虽然其他应用无法访问快捷方式中的元数据（metadata），但启动器本身可以访问此数据。因此，这些元数据应隐藏敏感的用户信息。 要开始为您的应用创建快捷方式，请参阅以下页面： 创建快捷方式 管理快捷方式 快捷方式的最佳做法 有关可以在快捷方式上执行的操作的更多详细信息，请参阅ShortcutManager API。 "},"Activity/AppShortCuts/创建快捷方式.html":{"url":"Activity/AppShortCuts/创建快捷方式.html","title":"创建快捷方式","keywords":"","body":"创建快捷方式 快捷方式可帮助用户快速访问部分应用，从而为用户提供特定类型的内容(content)。 如何使用快捷方式传递内容取决于您的用例以及快捷方式的上下文是由应用驱动的还是由用户驱动的。虽然静态快捷方式的上下文不会改变而动态快捷方式的上下文会不断变化，但两种快捷方式的上下文都是由您的应用程序驱动的。如果用户选择他们希望您的应用向他们传递内容的方式，例如使用固定的快捷方式，则上下文由用户定义。以下列举了每种快捷方式类型的一些用例： 静态快捷方式 最适合在用户与应用程序交互的整个生命周期内使用一致结构链接到内容的应用程序。由于大多数启动程序 一次only display four shortcuts(仅仅只能显示4个快捷方式) ，因此静态快捷方式对于常见Activity非常有用。例如，如果用户想要以特定方式查看他们的日历或电子邮件，则使用静态快捷方式可确保他们执行日常任务的体验是一致的。 动态快捷方式 用于对上下文敏感的应用中的操作。例如，如果您构建的游戏允许用户在启动时从当前级别（level）开始，则需要经常更新快捷方式。使用动态快捷方式允许每次用户清除级别（level）时更新快捷方式。 固定快捷方式 用于特定的用户驱动操作。例如，用户可能希望将特定网站固定到启动器。这是有益的，因为它允许用户执行自定义操作，例如一步导航到网站，比使用浏览器的默认实例更快。 创建静态快捷方式 静态快捷方式提供了应用程序中通用操作的链接，这些操作应在应用程序当前版本的生命周期内保持一致。静态快捷方式的典型例子包括查看已发送的消息、设置警报以及显示当天用户的锻炼活动。 要创建静态快捷方式，请完成以下步骤： 在应用程序的清单文件（AndroidManifest.xml）中，查找其Intent filter的操作（action）设置为android.intent.action.MAIN和类别（category）设置为android.intent.category.LAUNCHER的Activity。 向此Activity 添加一个元素，该元素引用定义应用程序快捷方式的资源文件： 创建一个新的资源文件：res/xml/shortcuts.xml。 在此新资源文件中，添加一个根元素，其中包含元素列表。每个 元素都包含有关静态快捷方式的信息，包括其图标，描述标签以及它在应用程序中启动的intent： 自定义属性值 以下包含静态快捷方式中不同属性的说明。您必须为android:shortcutId和 android:shortcutShortLabel提供属性值。所有其他值都是可选的。 android:shortcutId 一个字符串，表示ShortcutManager对象对其执行操作时的快捷方式。 注意：您不能将此属性的值设置为资源字符串，例如@string/foo。 android:shortcutShortLabel 描述快捷方式意图（purpose）的简明短语（short description）。如果可能，将快捷方式的“short description”的长度限制为10个字符。有关更多信息，请参阅setShortLabel()) 注意：此属性的值必须是资源字符串，例如 @string/shortcut_short_label。 android:shortcutLongLabel 描述快捷方式意图（purpose）的扩展短语（long description）。如果有足够的空间，启动器会显示此值而不是android:shortcutShortLabel。如果可能，将快捷方式的“long description”的长度限制为25个字符。有关更多信息，请参阅 setLongLabel()) 注意：此属性的值必须是资源字符串，例如 @string/shortcut_long_label。 android:shortcutDisabledMessage 当用户尝试启动已禁用的快捷方式时，支持的启动程序中显示的消息。该消息应向用户解释为什么现在禁用该快捷方式。如果android:enabled是true的，则此属性的值无效 注意：此属性的值必须是资源字符串，例如 @string/shortcut_disabled_message。 android:enabled 确定用户是否可以从支持的启动器与快捷方式进行交互。默认值android:enabled是true。如果将其设置为false，则还应设置一个android:shortcutDisabledMessage解释禁用快捷方式的原因。如果您认为不需要提供此类消息，则最简单的方法是从XML文件中完全删除该快捷方式。 android:icon 启动器在显示用户快捷方式时使用 的 bitmap 或者adaptive icon。此值可以是图像的路径，也可以是包含图像的资源文件。应该尽可能使用自适应图标以提高性能和一致性。 注意：快捷方式图标不能包含tints. 配置内部元素 列出应用程序的静态快捷方式的XML文件支持每个元素中的以下元素 。您**必须为您定义的每个静态快捷方式包含一个intent内部元素。 intent 用户选择快捷方式时系统启动的操作。此意图必须为android:action属性提供值。 注意：此intent元素不能包含字符串资源。您可以为单个快捷方式提供多个intent。有关详细信息，请参 Manage multiple intents and activities, Using intents和TaskStackBuilder类 categories 为应用程序快捷方式执行的操作类型提供分组，例如创建新的聊天消息。有关支持的快捷方式类别的列表，请参阅ShortcutInfo类。 创建动态快捷方式 动态快捷方式提供指向应用内特定的上下文相关操作的链接。这些操作可能会在您的应用使用之间发生变化，甚至在您的应用运行时也会发生变化。动态快捷方式的典型例子包括呼叫特定人员，导航到特定位置，以及从用户的最后保存点加载游戏。 ShortcutManager API允许你完成动态快捷键下面的操作： 发布：使用 setDynamicShortcuts())重新定义动态快捷方式的完整列表，或者使用addDynamicShortcuts()) 以增加动态快捷方式的现有列表。 更新：使用updateShortcuts())方法。 删除：使用removeDynamicShortcuts())删除一组动态快捷方式 或使用removeAllDynamicShortcuts())删除所有动态快捷方式。 有关在快捷方式上执行操作的更多信息，请阅读 管理快捷方式和 ShortcutManager参考。 以下代码段中显示了创建动态快捷方式并将其与您的应用相关联的示例： 注：在ShortcutManager的实例中必须使用带有参数ShortcutManager.class的Context.getSystemService（Class）或带有Context.SHORTCUT_SERVICE参数的Context.getSystemService（String）获取ShortcutManager类的实例。 kotlin val shortcutManager = getSystemService(ShortcutManager::class.java) val shortcut = ShortcutInfo.Builder(context, \"id1\") .setShortLabel(\"Website\") .setLongLabel(\"Open the website\") .setIcon(Icon.createWithResource(context, R.drawable.icon_website)) .setIntent(Intent(Intent.ACTION_VIEW, Uri.parse(\"https://www.mysite.example.com/\"))) .build() shortcutManager!!.dynamicShortcuts = Arrays.asList(shortcut) java ShortcutManager shortcutManager = getSystemService(ShortcutManager.class); ShortcutInfo shortcut = new ShortcutInfo.Builder(context, \"id1\") .setShortLabel(\"Website\") .setLongLabel(\"Open the website\") .setIcon(Icon.createWithResource(context, R.drawable.icon_website)) .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://www.mysite.example.com/\"))) .build(); shortcutManager.setDynamicShortcuts(Arrays.asList(shortcut)); 创建固定快捷方式 图1：应用程序快捷方式和固定快捷方式的外观 在Android 8.0（API级别26）及更高版本上，您可以创建固定快捷方式。与静态和动态快捷方式不同，固定快捷方式在支持的启动器中显示为单独的图标。图1展示了这两种类型的快捷方式之间的区别。 注意：当您尝试将快捷方式固定到支持的启动器上时，用户会收到一个确认对话框，询问他们是否可以固定快捷方式。如果用户不允许固定快捷方式，则启动器会取消该请求。 要使用您的应用固定支持的启动器的快捷方式，请完成以下一系列步骤： 使用isRequestPinShortcutSupported())来验证设备的默认启动器是否支持应用程序固定快捷方式。 根据快捷方式是否已存在，以两种方式之一创建ShortcutInfo对象： 如果快捷方式已存在，创建一个仅包含现有快捷方式ID的 ShortcutInfo对象。系统自动查找并固定与快捷方式相关的所有其他信息。 如果要固定新的快捷方式，请创建一个包含新快捷方式ID、一个intent、一个short label的的ShortcutInfo对象 注意：由于系统会自动对固定快捷方式执行 备份和还原(backup and restore)，因此这些快捷方式的ID应包含稳定的(stable)常量字符串或服务器端标识符，而不是本地生成的标识符，这些标识符在其他设备上可能没有意义。 尝试通过调用requestPinShortcut())将快捷方式固定到设备的启动器。在此过程中，您可以传入PendingIntent对象，该对象仅在快捷方式成功固定时通知您的应用。 注意：如果用户不允许将快捷方式固定到启动器，则您的应用程序不会收到回调。 固定快捷方式后，您的应用可以使用updateShortcuts())方法更新其内容 。有关更多信息，请阅读 管理快捷方式中的更新快捷方式部分。 以下代码段演示了如何创建固定的快捷方式： 注：必须使用带有参数ShortcutManager.class的Context.getSystemService（Class）或带有Context.SHORTCUT_SERVICE参数的Context.getSystemService（String）获取ShortcutManager类的实例。 kotlin val shortcutManager = getSystemService(ShortcutManager::class.java) if (shortcutManager!!.isRequestPinShortcutSupported) { // Assumes there's already a shortcut with the ID \"my-shortcut\". // The shortcut must be enabled. val pinShortcutInfo = ShortcutInfo.Builder(context, \"my-shortcut\").build() // Create the PendingIntent object only if your app needs to be notified // that the user allowed the shortcut to be pinned. Note that, if the // pinning operation fails, your app isn't notified. We assume here that the // app has implemented a method called createShortcutResultIntent() that // returns a broadcast intent. val pinnedShortcutCallbackIntent = shortcutManager.createShortcutResultIntent(pinShortcutInfo) // Configure the intent so that your app's broadcast receiver gets // the callback successfully.For details, see PendingIntent.getBroadcast(). val successCallback = PendingIntent.getBroadcast(context, /* request code */ 0, pinnedShortcutCallbackIntent, /* flags */ 0) shortcutManager.requestPinShortcut(pinShortcutInfo, successCallback.intentSender) } java ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class); if (shortcutManager.isRequestPinShortcutSupported()) { // Assumes there's already a shortcut with the ID \"my-shortcut\". // The shortcut must be enabled. ShortcutInfo pinShortcutInfo = new ShortcutInfo.Builder(context, \"my-shortcut\").build(); // Create the PendingIntent object only if your app needs to be notified // that the user allowed the shortcut to be pinned. Note that, if the // pinning operation fails, your app isn't notified. We assume here that the // app has implemented a method called createShortcutResultIntent() that // returns a broadcast intent. Intent pinnedShortcutCallbackIntent = shortcutManager.createShortcutResultIntent(pinShortcutInfo); // Configure the intent so that your app's broadcast receiver gets // the callback successfully.For details, see PendingIntent.getBroadcast(). PendingIntent successCallback = PendingIntent.getBroadcast(context, /* request code */ 0, pinnedShortcutCallbackIntent, /* flags */ 0); shortcutManager.requestPinShortcut(pinShortcutInfo, successCallback.getIntentSender()); } 注意：另请参阅support library APIs、 isRequestPinShortcutSupported())和requestPinShortcut())，它们适用于Android 7.1（API级别25）及更低版本。support library 回退到已弃用的EXTRA_SHORTCUT_INTENT extra以尝试固定进程。 创建自定义快捷方式的Activity *图2:自定义应用程序快捷方式dialog Activity的示例 您还可以创建专门的Activity以帮助用户创建快捷方式，完成自定义选项（custom options）和确认按钮（confirmation button）。图2显示了Gmail应用中此类Activity的示例。 在应用程序的清单文件中，将ACTION_CREATE_SHORTCUT添加到Activity的元素中。当用户尝试创建快捷方式时，此声明将设置以下行为： 系统启动您应用的特定Activity。 用户设置快捷方式的选项。 用户选择确认按钮。 您的应用使用createShortcutResultIntent（）方法创建快捷方式。此方法返回一个Intent，您的应用程序使用setResult（）返回到先前执行的Activity。 您的应用程序调用finish（）以创建自定义快捷方式的Activity。 同样，您的应用可以提示用户在安装后或第一次启动应用时将固定快捷方式添加到主屏幕。此方法很有效，因为它可以帮助您的用户在其日常工作流程中创建快捷方式。 测试快捷方式 要测试应用的快捷方式，请在具有支持快捷方式的启动器的设备上安装您的应用。然后，执行以下操作： 长按您应用的启动器图标，即可查看您为应用定义的快捷方式。 点击并拖动快捷方式将其固定到设备的启动器。 "},"Activity/AppShortCuts/管理快捷方式.html":{"url":"Activity/AppShortCuts/管理快捷方式.html","title":"管理快捷方式","keywords":"","body":"管理快捷方式 原文(英文)地址 创建快捷方式后，您可能需要在应用的生命周期内管理它们。例如，您可能希望通过确定用户使用快捷方式完成特定操作的频率来优化您的应用。在另一种情况下，您可能决定禁用固定快捷方式，以防止您的应用执行过时或丢失的操作。本文档介绍了这些管理快捷方式的方法，还有几种其他常用的管理快捷方式的方法。 快捷方式行为(behavior) 以下部分包含有关快捷方式行为的常见内容，包括可见性（visibility），显示顺序（display order）和排名（ranks）。 快捷方式可见性 重要安全说明：所有快捷方式信息都存储在凭据加密存储( credential encrypted storage)中，因此您的应用在解锁设备之前无法访问用户的快捷方式。 当用户执行特定手势时，静态快捷方式和动态快捷方式将显示在受支持的启动器中。在当前支持的启动器上，手势是长按应用程序的启动器图标，但实际手势可能与其他启动器应用程序不同。 LauncherApps类为启动器应用程序提供API以访问快捷方式。 由于固定的快捷方式出现在启动器本身中，因此它们始终可见。仅在以下情况下，才会从启动器中删除固定的快捷方式： 用户将其删除。 与快捷方式关联的应用程序已卸载。 用户通过通过 设置>应用和通知，然后选择应用，然后按存储>清除存储来清除应用的数据。 快捷方式的显示顺序 当一个启动器展示app的快捷方式时，他们应该按照以下顺序进行展示： 1：静态快捷方式：isDeclaredInManifest()方法返回True的快捷方式 2：动态快捷方式：ShortcutInfo.isDynamic()方法返回true的快捷方式 对于每一种类型的快捷方式(静态和动态)，快捷方式按照ShortcutInfo.getRank()获得的Ranks（排名）信息来进行排序。 对于每一个快捷方式，Ranks是一个非负的、顺序（sqquential）的整数，你可以通过调用updateShortcuts(List))、addDynamicShortcuts(List)),或者setDynamicShortcuts(List))方法去更新快捷方式的排名。 注意：每一种类型的快捷方式(静态和动态)，Ranks是会自动自动调整的。比如，有三个动态快捷方式，其ranks值分别是0，1，2，添加另一个ranks值为1的动态快捷方式之后就需要当前第二个位置的动态快捷方式就应该被代替。结构，第三和第四个快捷方式移动到快捷方式列表的底部，其排名分别变为2和3。 管理多个intent和activity 如果你想要当用户点击你应用的快捷方式时执行多个动作，你可以配置连续触发多个activity，你可以通过分配多个intent，从一个activity启动另一个activity，或者通过设置intent flag来完成此操作，具体取决于快捷方式的类型。 分配多个intent 当你使用ShortcutInfo.Builder创建快捷方式时，你可以使用setIntents())而不是setIntent())。通过调用setIntents()，当用户选择快捷方式时，您可以在应用程序中启动多个Activity，将列表中的除了最后一个Activity之外的所有activity放在回退栈（back stack）中。 如果用户想要点击设备的后腿按钮，他会看到另一个activity而不是直接返回设备的启动器界面。 注意：当用户点击了一个快捷方式然后点击后退按钮之后，你的app会启动从资源文件中列出的列表的倒数第二个Intent对应的activity。重复按下后退按钮后，系统将会继续按照此逻辑启动后面的activity（如果有的话，直到用户清除快捷方式创建的回退栈。当用户下一次按下后退按钮时，系统将会导航回启动器。 从另一个activity启动本activity 静态快捷方式不能有自定义的Intent flag。第一个静态类型快捷方式的Intent flag始终是 Intent.FLAG_ACTIVITY_NEW)和Intent.TASK FLAG_ACTIVITY_CLEAR_TASK.这意味着，当应用程序已在运行时，启动静态快捷方式时，应用程序中的所有现有Activity都将被销毁。如果不希望出现这种情况，可以使用trampoline(蹦床？) Activity，或者Activity.onCreate（Bundle）中启动另一个不可见的Activity，然后调用Activity.finish（）： 在AndroidManifest.xml文件中，trampoline Activity应该包含属性赋值android：taskAffinity =“”。 在快捷方式的资源文件中，静态快捷方式中的Intent应引用trampoline Activity。 有关trampoline Activity的更多信息，请阅读Activity的生命周期)中从另一个Activity启动一个Activity部分。 设置Intent flag 动态快捷方式可以设置任意Intent flag。您最好指定Intent.FLAG_ACTIVITY_CLEAR_TASK以及其他flag。否则，如果您在应用程序运行时尝试启动其他Task，则可能不会显示目标Activity。 要了解有关Task和Intent flag的更多信息，请阅读理解Task和回退栈。 更新快捷方式 每一个应用程序启动器图标都可以最多包含getMaxShortcutCountPerActivity())个（静态的和/或动态的）快捷方式。但是，应用程序可以创建的固定快捷方式的数量没有限制。 对于固定动态快捷方式，即使发布者将其作为动态快捷方式删除，固定的快捷方式仍然可见并且可以启动。这允许应用程序具有多于getMaxShortcutCountPerActivity（）个数量的快捷方式。 举个例子，比如getMaxShortcutCountPerActivity()返回了4： 一个社交类app创建了4个动态快捷方式，表示4个最常用的会话(c1，c2，c3，c4) 用户固定了这4个快捷方式 之后，用户又开启了3个新的会话(c5，c6和c7)，所以发布商应用程序重新发布其动态快捷方式。新的动态快捷键列表是：c4，c5，c6，c7。 该应用程序必须删除c1，c2和c3，因为它无法显示四个以上的动态快捷方式。但是，c1，c2和c3仍然是用户可以访问和启动的固定快捷方式。 用户现在可以访问总共七个链接到发布者应用中的Activity的快捷方式。这是因为总数包括最大快捷方式数和三个固定的快捷方式。 该应用程序可以使用updateShortcuts（List）更新任何现有的七个快捷方式。例如，您可以在聊天对象的的头像发生更改时更新这组快捷方式。 addDynamicShortcuts（List）和setDynamicShortcuts（List）方法也可用于更新具有相同ID的现有快捷方式。但是，它们不能用于更新非动态快捷方式和固定快捷方式，因为这两种方法会尝试将给定的快捷方式列表转换为动态快捷方式。 要详细了解应用程序快捷方式指南（包括更新快捷方式），请参阅 Best practices. 处理系统局部设置更改 app应该在收到Intent.ACTION_LOCALE_CHANGD广播时更新动态快捷方式和固定快捷方式，因为该广播标志着系统局部设置已更改。 跟踪（Track）快捷方式用法 要确定什么情况应该出现静态快捷方式、什么情况应该出现动态快捷方式，启动器会检查快捷方式的历史激活记录。通过调用reportShortcutUsed（）方法并在发生以下任一事件时向其传递快捷方式的ID，您可以跟踪用户何时在应用程序中完成特定操作： 用户选择具有给定ID的快捷方式。 在应用程序内，用户手动完成与同一快捷方式对应的操作。 禁用快捷方式 由于您的应用及应用的用户可以将快捷方式固定到设备的启动器，因此这些固定的快捷方式可能会引导用户执行应用中已过期或不再存在的操作。要管理这种情况，您可以通过调用disableShortcuts（）来禁用您不希望用户选择的快捷方式，该操作会从静态和动态快捷方式列表中删除指定的快捷方式，并禁用这些快捷方式的任何被固定的副本。您还可以使用此方法的重载版本，该方法接受CharSequence作为自定义错误消息。当用户尝试启动任何禁用的快捷方式时，将显示该错误消息。 注意：如果在更新应用程序时删除了您应用程序的某些静态快捷方式，系统会自动禁用这些快捷方式。 限速(rate limiting) 使用setDynamicShortcuts（），addDynamicShortcuts（）或updateShortcuts（）方法时，请记住，您可能只能在一个没有任何前台Service或者前台Activity的后台APP中调用这些方法特定次。调用这些方法被调用次数的限制称为速率限制（rate limiting）。此功能用于防止ShortcutManager过度消耗设备资源。 当速率限制处于生效状态时，isRateLimitingActive（）将返回true。但是，在某些事件期间会重置速率限制，因此即使是后台应用程序也可以调用ShortcutManager的方法，直到再次达到速率限制。这些事件包括以下内容： 一个应用程序来到前台。 系统局部设置发生更改。 用户在一个通知（notification）中执行内联回复（inline reply）操作。 如果在开发或测试期间遇到速率限制，您可以从设备的设置中选择开发人员选项>重置ShortcutManager速率限制，或者您可以在adb中输入以下命令： $ adb shell cmd shortcut reset-throttling [ --user your-user-id ] 备份和还原 通过在应用程序的清单文件中包含android：allowBackup =“true”属性，您可以允许用户在更改设备时对应用程序执行备份和还原操作。如果您允许备份和还原，请记住以下有关应用程序快捷方式的要点： 静态快捷方式会自动重新发布，但只有在用户在新设备上重新安装应用程序后才能重新发布。 不会备份动态快捷方式，因此您必须在应用中包含特定逻辑，以便在用户在新设备上打开您的应用时重新发布它们。 固定快捷方式会自动恢复到设备的启动器，但系统不会备份与固定快捷方式关联的图标。因此，您应该在应用中保存固定快捷方式的图像，以便在新设备上轻松恢复它们。 以下代码段显示了如何更好地恢复应用的动态快捷方式，以及如何检查应用的固定快捷方式是否已保留： kotlin class MyMainActivity : Activity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val shortcutManager = getSystemService(ShortcutManager::class.java) if (shortcutManager!!.dynamicShortcuts.size == 0) { // Application restored. Need to re-publish dynamic shortcuts. if (shortcutManager.pinnedShortcuts.size > 0) { // Pinned shortcuts have been restored. Use // updateShortcuts() to make sure they contain // up-to-date information. } } } // ... } java public class MainActivity extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ShortcutManager shortcutManager = getSystemService(ShortcutManager.class); if (shortcutManager.getDynamicShortcuts().size() == 0) { // Application restored. Need to re-publish dynamic shortcuts. if (shortcutManager.getPinnedShortcuts().size() > 0) { // Pinned shortcuts have been restored. Use // updateShortcuts() to make sure they contain // up-to-date information. } } } // ... } 其他资源 Android AppShortcuts示例项目展示了本文档讨论的技术点的一些实现。 "},"Activity/AppShortCuts/快捷方式的最佳做法.html":{"url":"Activity/AppShortCuts/快捷方式的最佳做法.html","title":"快捷方式的最佳做法","keywords":"","body":"快捷方式的最佳做法 当你涉及并且创建爱你你的应用程序的快捷方式时，请遵循以下原则： 遵循涉及原则 为了保证你app的快捷方式在视觉上和系统的app的快捷方式保持一致，请遵循 App Shortcuts Design Guidelines. 仅发布四个不同的快捷方式 虽然API目前支持在任何给定时间为您的应用程序组合最多五个静态和动态快捷方式，但我们建议您仅发布四个不同的快捷方式，以改善其在启动器中的视觉外观。 限制快捷方式描述长度 菜单中的空间有限，在启动器中显示应用程序的快捷方式。如果可能，将快捷方式的“简短描述”的长度限制为10个字符，并将“长描述”的长度限制为25个字符。 有关静态快捷方式标签的详细信息，请参阅自定义属性值。对于动态和固定快捷方式，请阅读setLongLabel())和setShortLabel())的参考文档。 维护快捷方式和操作使用的历史记录 对于您创建的每个快捷方式，请考虑用户可以在应用程序中直接完成相同任务的不同方式。请记住在每种情况下调用reportShortcutUsed（），以便启动器程序保持用户执行快捷方式表示的操作的频率的准确历史记录。 仅在保留其含义时更新快捷方式 更改动态和固定快捷方式时，仅在保留其含义的前提下使用updateShortcuts（）更新快捷方式的信息。否则，您应该根据您要重新创建的快捷方式的类型使用以下方法之一： 动态快捷方式：addDynamicShortcuts（）或setDynamicShortcuts（）。 固定快捷方式：requestPinShortcut（）。 例如，如果您创建了导航到超市的快捷方式，则在超市名称发生变化但位置保持不变的情况下更新快捷方式是合适的。但是，如果用户开始在不同的超市位置购物，则最好创建新的快捷方式。 启动应用时，请检查动态快捷方式 当用户将数据恢复到新设备时，不会保留动态快捷方式。因此，我们建议您每次启动应用程序时检查getDynamicShortcuts（）返回的对象数，并根据需要重新发布动态快捷方式，如“备份和还原”中的代码段所示。 "},"Activity/AppWidgets/App小部件概述.html":{"url":"Activity/AppWidgets/App小部件概述.html","title":"概述","keywords":"","body":"App小部件概述 小部件是主屏幕定制的重要方面。您可以将它们想象为用户可以直接在主屏幕上访问的应用程序中最重要的数据和功能的“一目了然的”视图。用户可以在其主屏幕面板上移动小部件，如果支持，还可以调整它们的大小以根据用户的偏好定制小部件中的信息。 此文档介绍了您可能要创建的不同类型的小部件以及要遵循的一些设计原则。要开始构建应用小部件，请阅读构建应用小部件。 小部件类型 在开始规划小部件时，请考虑您尝试构建的小部件的类型。小部件通常有以下类别： 信息小部件 信息小部件通常显示一些对用户很重要的关键信息，并跟踪信息随时间的变化情况。信息小部件的好例子是天气小部件，时钟小部件或体育比分跟踪器。触摸信息窗口小部件通常会启动关联的应用程序并打开窗口小部件信息的详细视图。 集合（Collection）小部件 顾名思义，集合小部件专门用于显示相同类型的众多元素，例如来自图库应用程序的图片集合，来自新闻应用程序的文章集合或来自通信应用程序的电子邮件/消息集合。集合小部件通常关注两个用例：浏览集合、将集合的元素打开到其详细视图以供使用。集合小部件可以垂直滚动。 Listview 小部件 GridView小部件 控制小部件 控制小部件的主要目的是显示用户可以直接从主屏幕触发的常用功能，而无需先打开应用程序，它们被视为应用程序的远程控制。控件小部件的典型示例是音乐应用小部件，其允许用户在音乐应用之外播放，暂停或跳过音乐曲目。 与控件小部件的交互是否会延伸到关联的详细信息视图取决于控制小部件是否生成数据集。 混合小部件 虽然所有小部件倾向于倾向于上述三种类型中的一种，但实际上许多小部件是组合不同类型的元素的混合小部件。 出于规划小部件窗口的目的，将窗口小部件围绕其中一个基本类型居中，并根据需要添加其他类型的元素。 音乐播放器小部件主要是控件小部件，但也使用户了解当前正在播放的音轨。它基本上将控件小部件与信息小部件类型的元素组合在了一起。 小部件限制 尽管小部件可以被当做\"迷你app\"，但是在你开始设计你的小部件之前，还是需要了解一些重要的小部件限制： 手势 由于小部件位于主屏幕上，因此它们必须与已经建立主屏幕上的导航共存。与全屏应用程序相比，这限制了窗口小部件中可支持的手势。例如虽然某些应用程序可以支持用户横向滑动以在不同屏幕之间切换，但是该手势已经在主屏幕上应用以便在主屏幕之间导航，所以就不能应用在小部件上。 唯一可用于小部件的手势是： 触摸 垂直滑动 元素 鉴于上述交互方式的限制，依赖于受限制的手势的一些UI构建块（ UI building blocks）也不可用于窗口小部件。有关支持的构建块的完整列表以及有关布局限制的更多信息，请参阅构建应用程序小部件中创建应用程序布局部分。 设计原则 小部件内容 窗口小部件是一种可以通过\"宣传\"您app中有趣的内容和新内容来很好的吸引用户到你的app的方式。 就像报纸头版上的teasers一样，小部件应该整合并集中应用程序的信息，然后在应用程序中提供更丰富的细节。或者换句话说：小部件是“小吃”信息，而应用程序是“用餐”。作为底线，始终确保您的应用程序更显示详细信息，而不是窗口小部件已显示的信息。 小部件导航 除了单纯的信息内容，您还应该考虑通过提供应用程序常用区域的导航链接来完善您的小部件产品。这使用户可以更快地完成工作，并将应用程序的功能范围扩展到主屏幕。 适用存在于小部件中的典型导航链接有： 生成功能：这些功能允许用户为应用创建新内容，例如创建新文档或新消息。 在顶层打开应用程序：点击信息元素通常会将用户导航到较低级别的详细信息界面。提供对应用程序顶层的访问可提高导航的灵活性，还可以替换用于从主屏幕导航到应用程序的专用应用程序的快捷方式。使应用程序图标作为可用的还可以为您的窗口小部件提供清晰的标识，以防您显示的数据不明确。 resize小部件 长按之后松开可以将可调整大小的小部件设置为调整大小模式。用户可以使用拖动手柄（就是上图上的四个点）或小部件角来设置所需的大小。 调整大小允许用户在主面板放置网格的约束内调整窗口小部件的高度和/或宽度。您可以决定您的窗口小部件是否可以自由调整大小，或者是否受限于水平或垂直大小更改。如果您小部件本身是固定大小的，则不必支持调整大小。 允许用户调整窗口小部件的大小具有重要的好处： 他们可以微调他们想要在每个小部件上看到多少信息。 它们可以更好地影响其主页面板上的小部件和快捷方式的布局。 规划窗口小部件的调整大小策略取决于您正在创建的窗口小部件的类型。列表或基于网格的集合小部件通常很简单，因为调整小部件的大小只会扩展或收缩垂直滚动区域。无论窗口小部件的大小如何，用户仍可以将所有信息元素滚动到视图中。但是，信息小部件需要更多的手动规划，因为它们不可滚动且所有内容必须适应给定大小。您必须动态调整窗口小部件的内容和布局，使其达到用户通过调整大小操作定义的大小。 在这个简单的示例中，用户可以分4个步骤水平调整天气小部件的大小，并在小部件大小增长时在当前位置显示更丰富的天气的信息。 对于每个小部件大小，确定应该显示的应用程序信息量。对于较小的尺寸，请将更关注于必要的信息，然后在窗口小部件水平和垂直增长时添加更多信息。 考虑布局 根据您目标设备的放置网格（ placement grid）的尺寸来布置窗口小部件很有诱惑力，在布局窗口小部件时，这可能是一个有用的近似初始值，但请记住以下几点： grid cells的数量、大小、边距会因设备而异，因此，保证您的控件非常灵活，可以容纳比预期更多或更少的空间是非常重要的。 实际上，当用户调整窗口小部件的大小时，系统将以dp级别的大小进行响应，您的窗口小部件可以在此基础上重绘自己。规划小部件调整大小策略跨“size buckets\"而不是可变的网格维度（grid dimensions）将为您提供最可靠的结果。 小部件配置 有时，小部件需要先设置才能发挥作用。例如，可以考虑一个电子邮件小部件，您需要在显示收件箱之前提供帐户，或者是静态照片小部件，其中用户必须设置要从图片库中显示的图片。 Android小部件在小部件被放到主面板后立即显示其配置选项。保证窗口小部件易于配置，不要提供超过2-3个配置元素的小部件。使用Dialog而不是full-screen样式的Activity来呈现配置选项并保留用户位置的上下文（user's context of place），即使这样做需要使用多个对话框。 设置完成后，通常没有太多理由重新访问设置。因此，Android小部件不显示“设置”或“配置”按钮。 将Play小部件添加到主面板后，小部件会要求用户指定小部件应显示的媒体类型。 总结 专注于您的小部件上的一小部分可浏览信息，在应用中展开详细信息。 为您的需求选择正确的小部件类型。 对于可调整大小的小部件，请规划小部件的内容应如何适应不同的大小。 通过确保布局能够拉伸和收缩，使您的窗口小部件独立于方向和设备。 "},"Activity/AppWidgets/构建应用程序小部件.html":{"url":"Activity/AppWidgets/构建应用程序小部件.html","title":"构建应用程序小部件","keywords":"","body":"构建应用程序小部件 原文(英文)地址 App Widgets是迷你应用程序视图，可以嵌入到其他应用程序（例如主屏幕）中并接收定期更新。这些视图在用户界面中称为窗口小部件，您可以使用 App Widget provider发布一个窗口小部件。能够容纳其他App Widgets的应用程序组件称为App Widget host。下图显示了音乐应用小部件： 本文描述如何使用App Widget provider发布一个应用程序小部件。想了解如何创建你自己的AppWidgetHost以托管应用程序小部件，请参阅构建应用程序小部件主机（Host）.md). 注意：关于如何设计你的app小部件的内容请参阅 App小部件概述 基础 要创建App Widget，您需要以下内容： AppWidgetProviderInfo对象 描述App Widget的元数据，例如App Widget的布局，更新频率和AppWidgetProvider类。这应该在XML中定义。 AppWidgetProvider类的实现 定义允许您基于广播事件以使用代码与App Widget进行交互的基本方法。通过它，您将在App Widget更新，启用，禁用和删除时收到广播。 View layout 在XML中定义App Widget的初始布局。 此外，您可以实现配置App Widget的Activity。这是一个可选的Activity，当用户添加App Widget并允许他们在创建时修改App Widget设置时启动。 以下部分描述了如何设置每个组件。 在Manifest文件中声明App Widgets 首先在Manifest文件中声明AppWidgetProvider类，比如： 元素需要android:name属性，该属性唯一确定了App小部件使用的AppWidgetProvider。 元素必须包含一个含有android：name属性的元素，该属性(android:name)指定了AppWidgetProvider接受的ACTION_APPWIDGET_UPDATE广播。 这是你唯一需要显式声明的广播。AppWidgetManager会在必要的时候自动将所有其他App 小部件的广播发送到AppWidgetProvider。 元素指定了AppWidgetProviderInfo的resource，并且该元素需要以下属性： android:name ：指定metadata的名字。使用android.appwidget.provider将数据标识为AppWidgetProviderInfo描述符。 android:resource：指定了AppWidgetProviderInfo的资源位置 添加AppWidgetProviderInfo元数据（Metadata） AppWidgetProviderInfo定义App Widget的基本属性，例如其最小布局维度，初始布局资源，更新App Widget的频率，以及（可选）在创建时启动的配置Activity。使用单个元素在XML资源中定义AppWidgetProviderInfo对象，并将其保存在项目的res / xml /文件夹中。 比如： 以下是的属性总结： minWidth和minHeight属性的值指定App Widget默认使用的最小尺寸。默认主屏幕根据具有已定义高度和宽度的单元格网格在其窗口中定位App Widgets。如果App Widget的最小宽度或高度的值与单元格的尺寸不匹配，则App Widget尺寸将向上舍入到最接近的单元格大小。 关于App Widgets布局的更多信息参阅App Widget Design Guidelines updatePeriodMillis属性定义App Widget框架通过调用onUpdate（）回调方法从AppWidgetProvider请求更新的频率。实际的更新不能保证准确地按时发生，我们建议尽可能不经常更新——也许每小时不超过一次以节省电量。您可能还允许用户调整配置中的频率——有些人可能希望股票代码每15分钟更新一次，或者一天只能更新四次。 注意：如果设备在更新（由updatePeriodMillis定义）时处于睡眠状态，则设备将被唤醒以执行更新。如果每小时更新不超过一次，这可能不会导致电池寿命出现严重问题。但是，如果您需要更频繁地更新或者在设备处于睡眠状态时不需要更新，则可以基于不会唤醒设备的警报（alarm）执行更新。为此，请使用AlarmManager和AppWidgetProvider接收的Intent设置警报。将警报类型设置为ELAPSED_REALTIME或RTC，它仅在设备唤醒时发出警报。然后将updatePeriodMillis设置为零（“0”）。 initialLayout属性定义了App小部件的布局资源文件的位置 configure属性定义了当用户添加小部件到屏幕上时需要启动的Activity，以便用户配置App Wdiget，这是可选的，请参阅下面的创建一个配置App小部件的Activity previewImage属性指定应用程序窗口小部件配置只后的外观预览，用户在选择应用程序窗口小部件时会看到该窗口小部件。如果未提供，则用户会看到应用程序的启动器图标。此字段对应于AndroidManifest.xml文件中元素中的android：previewImage属性。有关使用previewImage的更多内容，请参阅设置预览图像。 autoAdvanceViewId属性指定应由窗口小部件主机（host）自动提升（auto-advanced）的应用窗口小部件子视图的视图ID。在Android 3.0中推出。 resizeMode属性指定可以调整窗口小部件的规则。您可以使用此属性使主屏幕小部件可以水平，垂直或在两个轴上进行调整。用户触摸按住窗口小部件以显示其调整大小手柄，然后拖动水平和/或垂直手柄以更改布局网格上的大小。 resizeMode属性的值包括“horizontal”，“vertical”和“none”。要将窗口小部件声明为水平和垂直可调整大小，请提供值“horizontal | vertical”。在Android 3.1中引入。 minResizeHeight属性指定可以调整窗口小部件的最小高度（以dps为单位）。如果此字段大于minHeight或未启用垂直调整大小，则此字段无效（请参阅resizeMode）。在Android 4.0中推出。 minResizeWidth属性指定可以调整窗口小部件的最小宽度（以dps为单位）。如果此字段大于minWidth或未启用水平调整大小，则此字段无效（请参阅resizeMode）。在Android 4.0中推出。 widgetCategory属性声明您的App Widget是否可以显示在主屏幕（home_screen），锁屏（键盘保护）或两者上。只有低于5.0的Android版本才支持锁屏小部件。对于Android 5.0及更高版本，只有home_screen有效。 关于更多元素的属性值，请参阅AppWidgetProviderInfo 创建应用程序小部件布局 你必须为你的app小部件定义一个舒适的布局xml文件，并且将其保存在res/layout目录下。你可以使用以下列出的View对象来设计你的App小部件，但是在你开始设计你的app小部件的布局之前，请先阅读app小部件设计原则. 如果你对Layouts很熟悉，那么构建一个app小部件的布局对你来说很容易。但是你必须注意，App小部件的布局是基于RemoteViews的，该组件不支持所有的View组件。 一个RemoteViews对象(以及App小部件)可以支持一下布局类： FrameLayout LinearLayout RelativeLayout GridLayout 以及以下组件类： AnalogClock Button Chronometer ImageButton ImageView ProgressBar TextView ViewFlipper ListView GridView StackView AdapterViewFlipper 这些类之外的其他类是不被支持的。 RemoteViews同样支持ViewStub，这是一个不可见的，零大小的视图，您可以使用它在运行时惰加载过大的布局资源。 在App小部件中添加边距(margins) 窗口小部件通常不应扩展到屏幕边缘，并且不应在视觉上与其他窗口小部件齐平，因此您应在窗口小部件框架的所有边上添加边距。 从Android 4.0开始，应用程序小部件会在窗口小部件框架和应用程序窗口小部件的边界框之间自动填充，以便更好地与用户主屏幕上的其他窗口小部件和图标对齐。要利用此强烈建议的行为，请将应用程序的targetSdkVersion设置为14或更高。 编写具有应用于早期版本平台的自定义边距，并且没有针对Android 4.0及更高版本的额外边距的单个布局很容易： 将应用程序的targetSdkVersion设置为14或更高。 创建一个如下所示的布局，引用其边距的 dimension resource ： … 创建两个dimensions resources，一个在res/values/下，用来提供Android4.0之前的自定义边距（margins），另一个在res/values-v14，用于提供android 4.0之后的额外填充（padding） res/values/dimens.xml: 8dp res/values-v14/dimens.xml: 0dp 另一个选择是默认在nine-patch背景中添加额外的边距，并为API级别14或更高版本提供没有边距的nine-patch资源。 使用AppWidgetProvider类 AppWidgetProvider类继承自BroadCastReceiver，AppWidgetProvider类将BroadcastReceiver扩展为一个更加方便的类来处理App Widget广播。 AppWidgetProvider仅接收与App Widget相关的广播事件，例如更新，删除，启用和禁用App Widget。当这些广播事件发生时，AppWidgetProvider会收到以下方法调用： onUpdate()) 该方法按AppWidgetProviderInfo中的updatePeriodMillis属性定义的间隔事件被调用，用来更新App Widget（请参阅上面的添加AppWidgetProviderInfo元数据）。用户添加App Widget时也会调用此方法，因此它应执行基本设置，例如为视图定义事件处理程序并在必要时启动临时服务。但是，如果已声明配置Activity，则在用户添加App Widget时不会调用此方法，但会为后续更新调用此方法。配置Activity负责在配置完成时执行第一次更新。 （请参阅下面的“创建一个配置App小部件的Activity”。） onAppWidgetOptionsChanged()) 该方法在App小部件第一次被放置以及每次resize 小部件时会会被调用。你可以在本方法中根据小部件的尺寸隐藏或者增加一些内容。你可以使用getAppWidgetOptions())方法得到尺寸的范围，该方法返回一个Bundle类型的数据，该数据中包含了以下内容： OPTION_APPWIDGET_MIN_WIDTH 小部件实例的当前宽度下限，以dp为单位 OPTION_APPWIDGET_MIN_HEIGHT 小部件实例的当前高度下限，以dp为单位 OPTION_APPWIDGET_MAX_WIDTH 小部件实例的当前宽度上限，以dp为单位 OPTION_APPWIDGET_MAX_HEIGHT 小部件实例的当前高度上限，以dp为单位 本方法是在API 16（Android 4.1）中引入的。如果您实现了次回调，请确保在您的应用不会依赖于这个方法，因为该方法在老版本的设备上会失效。 onDeleted(Context, int[])) 小部件每次从小部件主机(host)中被删除时都会调用这个方法。 onEnabled(Context)) 当App小部件第一次被创建时会调用此方法。比如，用户添加了两个你app小部件的实例，该方法仅仅会在第一个小部件被创建时调用。如果您需要打开一个新数据库或执行其他只需要为所有App Widget实例发生一次的设置，那么这是一个很好的执行这些操作的地方。 onDisabled(Context)) 该方法会在最后一个实例被从App小部件主机删除的时候调用。在这里你应该清除任何在onEnabled(Context)中做的工作，比如删除临时的数据库。 onReceive(Context, Intent)) 在每个广播和每个上述回调方法被调用之前调用此方法。您通常不需要实现此方法，因为默认的AppWidgetProvider实现过滤所有App Widget广播并根据需要调用上述方法。 注意：您必须使用AndroidManifest中的元素将AppWidgetProvider类实现声明为广播接收器（请参阅上面的在Manifest中的声明应用程序小部件）。 AppWidgetProvider最重要的回调是onUpdate（），因为在将每个App Widget添加到主机时会调用它（除非您使用配置Activity）。如果您的App Widget接受任何用户交互事件，那么您需要在此回调中注册事件处理程序。如果您的App Widget不创建临时文件或数据库，或执行需要清理的其他工作，则onUpdate（）可能是您需要定义的唯一回调方法。例如，如果您想要一个App Widget，其按钮在单击时启动Activity，您可以使用AppWidgetProvider的以下实现： public class ExampleAppWidgetProvider extends AppWidgetProvider { public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { final int N = appWidgetIds.length; // Perform this loop procedure for each App Widget that belongs to this provider for (int i=0; i 此AppWidgetProvider仅定义onUpdate（）方法，用于定义PendingIntent，该PendingIntent启动Activity并使用setOnClickPendingIntent（int，PendingIntent）将其附加到App Widget的按钮。请注意，它包含一个遍历appWidgetIds中每个item的循环，这是一个ID数组，用于标识此provider创建的每个App Widget。这样，如果用户创建了多个App Widget实例，那么它们都会同时更新。但是，将仅为App Widget的所有实例管理一个updatePeriodMillis。例如，如果更新计划（update schedule）定义为每两个小时，并且在第一个实例之后一小时添加App Widget的第二个实例，那么它们将在第一个小部件定义的时间段内更新，第二个小部件定义的更新将被忽略（它们将每两小时更新一次，而不是每小时更新一次）。 注意：因为AppWidgetProvider是BroadcastReceiver的子类，所以在回调方法返回后，您的进程不能保证继续运行（有关广播生命周期的信息，请参阅BroadcastReceiver）。如果您的App Widget设置过程可能需要几秒钟（可能在执行Web请求时），并且您需要继续运行进程，请考虑在onUpdate（）方法中启动Service。在Service中，您可以对App Widget执行自己的更新，而无需担心由于应用程序无响应（ANR）错误导致AppWidgetProvider关闭。有关运行服务的App Widget的示例，请参阅Wiktionary sample's AppWidgetProvider。 同样请参考ExampleAppWidgetProvider.java示例代码。 接收App小部件的broadcast intent AppWidgetProvider只是一个方便的类。如果您希望直接接收App Widget广播，您可以实现自己的BroadcastReceiver或覆盖onReceive（Context，Intent）回调。您需要关注的Intent如下： ACTION_APPWIDGET_UPDATE ACTION_APPWIDGET_DELETED ACTION_APPWIDGET_ENABLED ACTION_APPWIDGET_DISABLED ACTION_APPWIDGET_OPTIONS_CHANGED 固定App小部件 在Android8.0(API26)及以上，启动器不仅允许你创建pinned shortcuts(固定快捷方式)，同样也支持你将App小部件固定在启动器上。和固定快捷方式类似，固定的App小部件给了用户访问你App中特殊任务的权限。 在你的App中，您可以通过完成以下一系列步骤来创建系统请求以将窗口小部件固定到支持的启动器上： 1：在Manifest文件中创建小部件，就像下面这样： ... ... 2：调用requestPinAppWidget())方法： AppWidgetManager mAppWidgetManager = context.getSystemService(AppWidgetManager.class); ComponentName myProvider = new ComponentName(context, MyAppWidgetProvider.class); if (mAppWidgetManager.isRequestPinAppWidgetSupported()) { // Create the PendingIntent object only if your app needs to be notified // that the user allowed the widget to be pinned. Note that, if the pinning // operation fails, your app isn't notified. Intent pinnedWidgetCallbackIntent = new Intent( ... ); // Configure the intent so that your app's broadcast receiver gets // the callback successfully. This callback receives the ID of the // newly-pinned widget (EXTRA_APPWIDGET_ID). PendingIntent successCallback = PendingIntent.createBroadcast(context, 0, pinnedWidgetCallbackIntent); mAppWidgetManager.requestPinAppWidget(myProvider, null, successCallback); } 注意：如果您的应用程序不需要通知系统是否成功将小部件固定到支持的启动程序上，您可以将null作为第三个参数传递给requestPinAppWidget（）。 创建一个配置App小部件的configuration Activity 如果您希望用户在添加新的应用程序窗口小部件时配置设置，则可以创建应用程序窗口小部件配置Activity。此Activity将由App Widget host自动启动，并允许用户在创建时配置App Widget的可用设置，例如App Widget颜色，大小，更新周期或其他功能设置。 配置Activity应该在Android manifest文件中声明为普通Activity。但是，App Widget host将使用ACTION_APPWIDGET_CONFIGURE操作启动它，因此Activity需要接受此Intent。例如： 同样，必须在AppWidgetProviderInfo XML文件中使用android:configure属性声明该Activity(参考上面的添加AppWidgetProviderInfo元数据），比如： 请注意，Activity是使用完整的命名空间（fully-qualified namespace）声明的，因为它将从包范围外引用。 这就是开始使用配置Activity所需的全部内容，现在您只需要实现该Activity，在实现Activity时，需要记住两件重要的事情： App Widget host调用配置Activity，配置Activity应始终返回结果。结果应该包括由启动Activity时Intent传递的App Widget ID（在Intent extras中保存为EXTRA_APPWIDGET_ID）。 创建App Widget时不会调用onUpdate（）方法（系统在启动配置Activity时不会发送ACTION_APPWIDGET_UPDATE广播）。首次创建App Widget时，配置Activity负责从AppWidgetManager请求更新。但是，将为后续更新调用onUpdate（）——它仅在第一次被跳过。 有关如何从配置返回结果并更新App Widget的示例，请参阅以下部分中的代码片段。 在配置（configuration）Activity中更新App小部件 当App Widget使用配置Activity时，Activity负责在配置完成时更新App Widget。您可以通过直接从AppWidgetManager请求更新来完成此操作。 以下是正确更新App Widget并关闭配置Activity的过程： 1：首先，从启动Activity的Intent中获取App Widget ID： Intent intent = getIntent(); Bundle extras = intent.getExtras(); if (extras != null) { mAppWidgetId = extras.getInt( AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID); } 2：执行App Widget配置。 3：配置完成后，通过调用getInstance（Context）获取AppWidgetManager的实例： AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context); 4：通过调用updateAppWidget（int，RemoteViews）使用RemoteViews更新App小部件布局： RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.example_appwidget); appWidgetManager.updateAppWidget(mAppWidgetId, views); 5：最后，创建返回的Intent，将其设置为Activity的返回结果，并finish Activity Intent resultValue = new Intent(); resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId); setResult(RESULT_OK, resultValue); finish(); 提示：首次打开配置Activity时，将Activity结果与EXTRA_APPWIDGET_ID一起设置为RESULT_CANCELED，如上面的步骤5所示。这样，如果用户在到达结束之前退出Activity，则会通知App Widget host 配置已取消，并且不会添加App Widget。 查看ExampleAppWidgetConfigure.java示例Demo 设置预览图像 Android 3.0引入了previewImage字段，该字段指定应用程序小部件的外观预览。此预览将通过窗口小部件选择器显示给用户。如果未提供此字段，则应用小部件的图标将用于预览。 这是您在XML中指定此设置的方式： 为了帮助您为应用小部件创建预览图像（在previewImage字段中指定），Android模拟器包含一个名为“小部件预览（Widget Preview）”的应用程序。要创建预览图像，请启动此应用程序，为您的应用程序选择应用程序窗口小部件，并将其设置为您希望显示预览图像的方式，然后保存并将其放在应用程序的drawable 资源中。 将App小部件和集合一起使用 Android 3.0引入了带有集合的app小部件。这些类型的App Widgets使用RemoteViewsService显示来自如content provider这类远程数据支持的集合。 RemoteViewsService提供的数据使用以下视图类型之一显示在app小部件中，我们将其称为“集合视图”： ListView 一个视图，显示垂直滚动列表中的项目。有关示例，请参阅Gmail应用小部件。 GridView 在二维滚动网格中显示项目的视图。有关示例，请参阅“书签”应用小部件。 StackView 堆叠的卡片视图（类似于rolodex），用户可以分别向上/向下轻弹前卡以查看上一张/下一张卡片。示例包括YouTube和图书应用小部件。 AdapterViewFlipper 支持适配器的简单ViewAnimator，可在两个或多个视图之间进行动画处理。一次只能展示一个子视图。 如上所述，这些集合视图显示由远程数据支持的集合。这意味着他们使用Adapter将用户界面绑定到他们的数据，Adapter将一组数据中的各个项绑定到单个View对象中。由于这些集合视图由Adapter支持，因此Android框架必须包含额外的体系结构以支持它们在app小部件中的使用。在app小部件的上下文中，Adapter被RemoteViewsFactory取代，它只是Adapter接口的一个简易包装器。当请求集合中的特定项时，RemoteViewsFactory将创建集合的项并将其作为RemoteViews对象返回。要在应用小部件中包含集合视图，您必须实现RemoteViewsService和RemoteViewsFactory。 RemoteViewsService是一种允许远程Adapter请求RemoteViews对象的服务。 RemoteViewsFactory是集合视图（如ListView，GridView等）与该视图的基础数据之间的Adapter的接口。以下是StackWidget示例项目中用于实现此服务和接口的代码的示例： public class StackWidgetService extends RemoteViewsService { @Override public RemoteViewsFactory onGetViewFactory(Intent intent) { return new StackRemoteViewsFactory(this.getApplicationContext(), intent); } } class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory { //... include adapter-like methods here. See the StackWidget sample. } 示例应用程序 本节中的代码摘录摘自StackWidget sample 此示例包含10个视图的堆栈，显示从“0！”到“9！”，示例应用小部件具有以下主要行为： 用户可以丢弃（fling）app小部件中垂直投影的顶视图以显示下一个或上一个视图。这是StackView内置的一个行为。 在没有任何用户交互的情况下，app小部件会自动按顺序排列其视图，如幻灯片放映。这是由于在res / xml / stackwidgetinfo.xml文件中设置了android：autoAdvanceViewId =“@ id / stack_view”。此设置适用于视图ID，在本例中是堆栈视图的视图ID。 如果用户触摸顶视图，则app小部件显示Toast消息“Touched view n”，其中n是触摸视图的索引（位置）。有关如何实现此操作的更多讨论，请参阅给各个项添加行为。 实现app集合小部件 要实现app集合小部件，请遵循用于实现任何app小部件的相同基本步骤。以下部分描述了使用实现app集合小部件所需执行的其他步骤。 App集合小部件的Manifest文件 除了在manifest中声明应用程序窗口小部件中列出的要求之外，为了使app集合小部件可以绑定到RemoteViewsService，您必须使用权限BIND_REMOTEVIEWS在清单文件中声明该服务（RemoteViewsService）。这可以防止其他应用程序自由访问应用程序窗口小部件的数据。例如，在创建使用RemoteViewsService填充集合视图的App Widget时，清manifest条目可能如下所示： MyWidgetService是一个RemoteViewService的子类。 App集合小部件的布局(layout) 应用程序窗口小部件布局XML文件的主要要求是它包含一个集合视图：ListView，GridView，StackView或者AdapterViewFlipper，这里是StackWidget sample中的widget_layout.xml文件： 请注意，空视图（empty views）必须是集合视图（ collection view）的兄弟，其中空视图表示空状态。 除了整个应用程序窗口小部件的布局文件之外，还必须创建另一个布局文件，该文件定义集合中每个项目的布局（例如，书籍集合中每本书的布局）。 StackWidget sample中只有一个布局文件widget_item.xml，因为所有项目都使用相同的布局。 App集合小部件的AppWidgetProvider类 与常规应用程序窗口小部件一样，AppWidgetProvider子类中的大部分代码通常都在onUpdate（）中。在使用App集合小部件时，onUpdate（）实现的主要区别在于您必须调用setRemoteAdapter（），这告诉集合视图获取其数据的位置。然后，RemoteViewsService可以返回RemoteViewsFactory的实现，并且窗口小部件可以提供适当的数据。调用此方法时，必须传递指向RemoteViewsService实现的intent和指定要更新的app小部件的app widget ID。 例如，以下是StackWidget示例如何实现onUpdate（）回调方法，以将RemoteViewsService设置为应用程序窗口小部件集合的远程Adapter： public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { // update each of the app widgets with the remote adapter for (int i = 0; i 持久化数据 如上所述，您的RemoteViewsService子类提供用于填充远程集合视图的RemoteViewsFactory。 具体来说，您需要完成以下步骤： 子类RemoteViewsService。 RemoteViewsService是远程适配器可以通过其请求RemoteView的服务。 在RemoteViewsService子类中，包含一个实现RemoteViewsFactory接口的类。 RemoteViewsFactory是远程集合视图（如ListView，GridView等）与该视图的基础数据之间的Adapter的接口。您的实现负责为数据集中的每个项目创建RemoteViews对象。此接口是Adapter周围的简易包装器。 注意：您不能依赖Service的单个实例或其包含的任何数据来做持久化。因此，您不应在RemoteViewsService中存储任何数据（除非它是静态的）。如果您希望应用程序窗口小部件的数据保持不变，最好的方法是使用生命周期超出进程生命周期的ContentProvider。 RemoteViewsService实现的主要内容是RemoteViewsFactory，如下所述。 RemoteViewsFactory接口 实现RemoteViewsFactory接口的自定义类为应用程序窗口小部件提供其集合中项目的数据。为此，它将您的应用小部件item的XML布局文件与数据源相结合，这个数据源可以是从数据库到简单数组的任何数据。在StackWidget示例中，数据源是WidgetItems的数组。 RemoteViewsFactory用作将数据粘贴到远程集合视图的Adapter。 您需要为RemoteViewsFactory子类实现的两个最重要的方法是onCreate（）和getViewAt（）。 第一次创建工厂（factory）时，系统会调用onCreate（）。您可以在此处为数据源设置任何连接和/或游标。例如，StackWidget示例使用onCreate（）来初始化WidgetItem对象的数组。当您的应用程序窗口小部件处于生效状态时，系统将使用其在数组中的索引位置访问这些对象，并显示它们包含的文本。 以下是StackWidget示例的RemoteViewsFactory中onCreate（）方法的部分内容： class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory { private static final int mCount = 10; private List mWidgetItems = new ArrayList(); private Context mContext; private int mAppWidgetId; public StackRemoteViewsFactory(Context context, Intent intent) { mContext = context; mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID); } public void onCreate() { // In onCreate() you setup any connections / cursors to your data source. Heavy lifting, // for example downloading or creating content etc, should be deferred to onDataSetChanged() // or getViewAt(). Taking more than 20 seconds in this call will result in an ANR. for (int i = 0; i RemoteViewsFactory的getViewAt（）方法返回与数据集中指定位置的数据对应的RemoteViews对象。以下是StackWidget示例的RemoteViewsFactory的实现： public RemoteViews getViewAt(int position) { // Construct a remote views item based on the app widget item XML file, // and set the text based on the position. RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.widget_item); rv.setTextViewText(R.id.widget_item, mWidgetItems.get(position).text); ... // Return the remote views object. return rv; } 给单个项添加行为 以上部分介绍如何将数据绑定到App集合小部件。但是，如果要将动态行为添加到集合视图中的各个项目，该怎么办？ 如使用AppWidgetProvider类中所述，通常使用setOnClickPendingIntent（）来设置对象的单击行为，例如使按钮启动Activity。但是，集合项中的单个子视图不允许使用此方法（为了澄清(clarify)，您可以使用setOnClickPendingIntent（）在启动应用程序的Gmail应用程序窗口小部件中设置全局按钮监听，但不能在单个列表项上设置）。要将单击行为添加到集合中的各个项目，请使用setOnClickFillInIntent（），这需要为您的集合视图设置待定的Intent模板（intent template），然后通过RemoteViewsFactory为集合中的每个项目设置填充意图（fill-in intent ）。 本节使用StackWidget示例来描述如何向单个项添加行为。在StackWidget示例中，如果用户触摸顶视图，则app小部件显示Toast消息“Touched view n”，其中n是触摸视图的索引（位置）。这是它的工作原理： StackWidgetProvider（AppWidgetProvider子类）创建一个挂起（pending ）的intent，它具有一个名为TOAST_ACTION的自定义操作。 当用户触摸View时，Intent被触发并广播TOAST_ACTION。 StackWidgetProvider的onReceive（）方法拦截此广播，app小部件显示触摸视图的Toast消息。集合项的数据由RemoteViewsFactory通过RemoteViewsService提供。 注意：StackWidget示例使用广播，但通常app小部件会在类似这样的场景中启动Activity。 设置待定的意图模板(intent template) StackWidgetProvider（AppWidgetProvider子类）设置挂起的Intent，集合中的单个项无法设置自己的待处理Intent，集合会作为一个整体设置一个待定的意图模板，并且各个项目设置一个填充Intent，以逐项创建唯一的行为。 该类还接收用户触摸视图时发送的广播。它在onReceive（）方法中处理此事件。如果intent的操作是TOAST_ACTION，则app小部件会显示当前视图的Toast消息。 public class StackWidgetProvider extends AppWidgetProvider { public static final String TOAST_ACTION = \"com.example.android.stackwidget.TOAST_ACTION\"; public static final String EXTRA_ITEM = \"com.example.android.stackwidget.EXTRA_ITEM\"; ... // Called when the BroadcastReceiver receives an Intent broadcast. // Checks to see whether the intent's action is TOAST_ACTION. If it is, the app widget // displays a Toast message for the current item. @Override public void onReceive(Context context, Intent intent) { AppWidgetManager mgr = AppWidgetManager.getInstance(context); if (intent.getAction().equals(TOAST_ACTION)) { int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID); int viewIndex = intent.getIntExtra(EXTRA_ITEM, 0); Toast.makeText(context, \"Touched view \" + viewIndex, Toast.LENGTH_SHORT).show(); } super.onReceive(context, intent); } @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { // update each of the app widgets with the remote adapter for (int i = 0; i 设置填充Intent 您的RemoteViewsFactory必须为集合中的每个项目设置填充Intent，这使得可以区分给定项目的单独点击动作，然后将填充意图与PendingIntent模板组合，以确定单击该项时将执行的最终Intent。 public class StackWidgetService extends RemoteViewsService { @Override public RemoteViewsFactory onGetViewFactory(Intent intent) { return new StackRemoteViewsFactory(this.getApplicationContext(), intent); } } class StackRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory { private static final int mCount = 10; private List mWidgetItems = new ArrayList(); private Context mContext; private int mAppWidgetId; public StackRemoteViewsFactory(Context context, Intent intent) { mContext = context; mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID); } // Initialize the data set. public void onCreate() { // In onCreate() you set up any connections / cursors to your data source. Heavy lifting, // for example downloading or creating content etc, should be deferred to onDataSetChanged() // or getViewAt(). Taking more than 20 seconds in this call will result in an ANR. for (int i = 0; i 保持集合数据的有效性 下图说明了在发生更新时使用App集合小部件中发生的流程。它显示了应用程序窗口小部件代码如何与RemoteViewsFactory交互，以及如何触发更新： 使用集合的app小部件的一个功能是为用户提供最新内容的能力。例如，考虑Android 3.0 Gmail应用小部件，该小部件为用户提供其收件箱的快照。为了实现这一点，您需要能够触发RemoteViewsFactory和集合视图来获取和显示新数据。您可以使用AppWidgetManager调用notifyAppWidgetViewDataChanged（）来实现此目的。此调用导致对RemoteViewsFactory的onDataSetChanged（）方法的回调，这使您有机会获取任何新数据。请注意，您可以在onDataSetChanged（）回调中同步执行处理密集型操作。您可以保证在从RemoteViewsFactory获取元数据或视图数据之前完成此调用。此外，您可以在getViewAt（）方法中执行处理密集型操作。如果此调用需要很长时间，则加载视图（由RemoteViewsFactory的getLoadingView（）方法指定）将显示在集合视图的相应位置，直到它返回为止。 "},"应用程序架构指南.html":{"url":"应用程序架构指南.html","title":"应用程序架构指南","keywords":"","body":"应用程序（APP）架构指南 本指南面向的开发者：已熟知构建应用方面的基础知识，现在希望了解有哪些最佳做法和推荐架构有助于构建注重生产质量的强大应用。 本页假定您熟悉 Android 框架。如果您是 Android 应用开发新手，请查看我们的开发者指南，其中介绍了学习本指南的先修内容。 移动应用用户体验 在大多数情况下，桌面应用将桌面或程序启动器当做单个入口点，然后作为单个整体流程运行。Android 应用则不然，它们的结构要复杂得多。典型的 Android 应用包含多个应用组件，包括 Activity、Fragment、Service、content providers、broadcast receivers.。 您需要在应用清单中声明其中的大多数应用组件。Android 操作系统随后使用此文件决定如何将您的应用集成到设备的整体用户体验中。鉴于正确编写的 Android 应用包含多个组件，并且用户经常会在短时间内与多个应用进行交互，因此应用需要适应不同类型的用户驱动型工作流和任务。 例如，思考一下当您在自己喜欢的社交网络应用中分享照片时会发生什么： 该应用将触发相机 intent。Android 操作系统随后启动相机应用来处理请求。 此时，用户已离开社交网络应用，但他们的体验仍然是无缝的。 相机应用可能会触发其他 intent，如启动文件选择器，而这可能会再启动一个应用。 最后，用户返回社交网络应用并分享照片。 在此过程中，用户随时可能会被电话或通知打断。对此中断采取行动后，用户希望能够返回并恢复此照片分享过程。这种应用跳跃行为在移动设备上很常见，因此您的应用必须正确处理这些流程。 请注意，移动设备的资源也很有限，因此操作系统可能随时终止某些应用进程以便为新的进程腾出空间。 鉴于这种环境条件，您的应用组件可以不按顺序地单独启动，并且操作系统或用户可以随时销毁它们。由于这些事件不受您的控制，因此您不应在应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖。 常见的架构原则 如果您不应使用应用组件存储应用数据和状态，那么应如何设计应用？ 分离关注点 要遵循的最重要的原则是分离关注点。一种常见的错误是在一个 Activity 或 Fragment中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。应尽可能使这些类保持精简，这样可以避免许多与生命周期相关的问题。 请注意，您并不拥有 Activity 和 Fragment 的实现，这些只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户交互或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，最好尽量减少对它们的依赖。 通过模型（model）驱动界面 另一个重要原则是您应该通过模型（model）驱动界面，最好是持久性模型（model）。模型（model）是负责处理应用数据的组件。它们独立于应用中的 View 对象和应用组件，因此不受应用的生命周期以及相关关注点的影响。 持久性是理想之选，原因如下： 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。 当网络连接不稳定或不可用时，应用会继续工作。 应用所基于的模型（model）类应明确定义数据管理职责，这样将使应用更可测试且更一致。 推荐应用架构 在本部分，我们将通过一个端到端用例演示如何使用架构组件构造应用。 注意：不可能有一种应用编写方式对每种情况都最为合适。话虽如此，但推荐的这个架构是适合大多数情况和工作流的一个很好的起点。如果您已经有编写 Android 应用的好方法（遵循常见的架构原则），则无需更改。 假设我们要构建一个用于显示用户个人资料的界面。我们将使用私有后端和 REST API 获取给定个人资料的数据。 概述 首先，请查看下图，该图显示了设计应用后所有模块应如何相互交互： 请注意，每个组件仅依赖于其下一级的组件。例如，Activity 和 Fragment 仅依赖于视图模型( view model)。存储区(repository)是唯一一个依赖于其他多个类的类；在本例中，存储区(repository)依赖于持久性数据模型(persistent data model )和远程后端数据源( remote backend data source)。 这种设计打造了一致且愉快的用户体验。无论用户是在上次关闭应用几分钟后还是几天后回到应用，他们都会立即看到应用在本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始在后台更新数据。 构建界面 界面由 Fragment UserProfileFragment 及其对应的布局文件 user_profile_layout.xml组成。 要驱动该界面，数据模型需要存储以下数据元素： 用户 ID：用户的标识符。最好使用 Fragment 参数将该信息传递到相应 Fragment 中。如果 Android 操作系统销毁我们的进程，该信息将保留，以便下次重启应用时 ID 可用。 用户对象：用于存储用户详细信息的数据类。 我们将使用 UserProfileViewModel（基于 ViewModel 架构组件）存储这些信息。 ViewModel对象为特定的界面组件（如 Fragment 或 Activity）提供数据，并包含数据处理业务逻辑，以与模型进行通信。例如，ViewModel 可以调用其他组件来加载数据，还可以转发用户请求来修改数据。ViewModel 不依赖于界面组件，因此不受配置更改（如在旋转设备时重新创建 Activity）的影响。 我们现在定义了以下文件： user_profile.xml：屏幕的界面布局定义。 UserProfileFragment：显示数据的界面控制器。 UserProfileViewModel：准备数据以便在 UserProfileFragment 中查看并对用户交互做出响应的类。 以下代码段显示了这些文件起始的内容。（为简单起见，省略了布局文件。） UserProfileViewModel public class UserProfileViewModel extends ViewModel { private String userId; private User user; public void init(String userId) { this.userId = userId; } public User getUser() { return user; } } UserProfileFragment public class UserProfileFragment extends Fragment { private static final String UID_KEY = \"uid\"; private UserProfileViewModel viewModel; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); String userId = getArguments().getString(UID_KEY); viewModel = ViewModelProviders.of(this).get(UserProfileViewModel.class); viewModel.init(userId); } @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.user_profile, container, false); } } 现在，我们有了这些代码模块，如何将它们连接起来？毕竟，在 UserProfileViewModel 类中设置 user 字段后，我们需要一种通知界面的方法。这就是 LiveData 架构组件的用处所在。 LiveData 是一种可观察的(observable)数据存储器。应用中的其他组件可以使用此存储器来监控对象的更改，而无需在它们之间创建明确且严格的依赖路径。LiveData 组件还遵循(respects)应用组件（如 Activity、Fragment 和 Service）的生命周期状态，并包括清理逻辑(cleanup logic)以防止对象泄漏和过多的内存消耗。 注意：如果您已在使用诸如 RxJava 或 Agera 之类的库，您可以继续使用这些库而不是 LiveData。但在使用诸如此类的库和方法时，请确保正确处理应用的生命周期。特别是，在相关的 LifecycleOwner 停止时暂停数据流，并在相关的 LifecycleOwner 销毁时销毁这些数据流。您还可以添加 android.arch.lifecycle:reactivestreams 软件工件(artifact)，以将 LiveData 与其他响应流库（如 RxJava2）一起使用。 为了将 LiveData 组件纳入应用，我们将 UserProfileViewModel 中的字段类型更改为 LiveData。现在，更新数据时，会通知 UserProfileFragment。此外，由于此 LiveData 字段具有生命周期感知能力，因此当不再需要引用时，会自动清理它们。 UserProfileViewModel public class UserProfileViewModel extends ViewModel { ... //private User user; private LiveData user; public LiveData getUser() { return user; } } 现在，我们修改 UserProfileFragment 以观察数据并更新界面： UserProfileFragment @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); viewModel.getUser().observe(this, user -> { // Update UI. }); } 每次更新用户个人资料数据时，都会调用 onChanged()) 回调并刷新界面。 如果您熟悉使用可观察回调(observable callbacks)的其他库，您可能已经意识到，我们并未重写 Fragment 的 onStop() 方法以停止观察数据。使用 LiveData 时没必要执行此步骤，因为它具有生命周期感知能力。这意味着，除非 Fragment 处于活跃状态（即，已接收 onStart() 但尚未接收 onStop()），否则它不会调用 onChanged() 回调。当调用 Fragment 的 onDestroy() 方法时，LiveData 还会自动移除观察者。 此外，我们也没有添加任何逻辑来处理配置更改，如用户旋转设备的屏幕。UserProfileViewModel 会在配置更改后自动恢复，所以一旦创建新的 Fragment，它就会接收相同的 ViewModel 实例，并且会立即使用当前的数据调用回调。鉴于 ViewModel 对象应该比它们更新的相应 View 对象存在的时间更长，因此 ViewModel 实现中不得包含对 View 对象的直接引用。要详细了解与界面组件生命周期对应的 ViewModel 生命周期，请参阅 ViewModel 的生命周期。 获取数据 现在，我们已使用 LiveData 将 UserProfileViewModel 连接到 UserProfileFragment，那么如何获取用户个人资料数据？ 在本例中，我们假定后端提供 REST API。我们使用 Retrofit 库访问后端，不过您可以随意使用具有相同作用的其他库。 下面是与后端进行通信的 Webservice 的定义： Webservice public interface Webservice { /** * @GET declares an HTTP GET request * @Path(\"user\") annotation on the userId parameter marks it as a * replacement for the {user} placeholder in the @GET path */ @GET(\"/users/{user}\") Call getUser(@Path(\"user\") String userId); } 实现 ViewModel 的最直接的想法可能是直接调用 Webservice 来获取数据，然后将该数据分配给 LiveData 对象。这种设计行得通，但如果采用这种设计，随着应用的扩大，应用会变得越来越难以维护。这样会给 UserProfileViewModel 类太多的责任，这就违背了分离关注点原则。此外，ViewModel 的时间范围与 Activity 或 Fragment 生命周期相关联，这意味着，当关联界面对象的生命周期结束时，会丢失 Webservice 的数据。此行为会带来不良的用户体验。 ViewModel 会将数据获取过程委派给一个新的模块，即存储区(repository)。 存储区模块会处理数据操作。它们会提供一个干净(clean)的 API，以便应用的其余部分可以轻松检索该数据。数据更新时，它们知道从何处获取数据以及进行哪些 API 调用。您可以将存储区视为不同数据源（如持久性模型、网络服务和缓存）之间的媒介(mediators)。 UserRepository 类（如以下代码段中所示）使用 WebService 实例来获取用户的数据： UserRepository public class UserRepository { private Webservice webservice; // ... public LiveData getUser(int userId) { // This isn't an optimal implementation. We'll fix it later. final MutableLiveData data = new MutableLiveData<>(); webservice.getUser(userId).enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { data.setValue(response.body()); } // Error case is left out for brevity. }); return data; } } 虽然存储区模块看起来是不必要的，但它起着一项重要的作用：它会从应用的其余部分中提取数据源。现在，UserProfileViewModel 不知道如何获取数据，因此我们可以为视图模型提供从几个不同的数据获取实现获得的数据。 注意：为简单起见，我们省去了网络错误情况的处理。有关公开错误和加载状态的替代实现，请参阅附录：公开网络状态。 管理组件之间的依赖关系 上方的 UserRepository 类需要一个 Webservice 实例才能获取用户的数据。它可以直接创建该实例，但要做到这一点，它还需要知道 Webservice 类的依赖项。此外，UserRepository 或许不是唯一一个需要 Webservice 的类。这种情况需要我们复制代码，因为每个需要引用 Webservice 的类都需要知道如何构造该实例及其依赖项。如果每个类都创建一个新的 WebService，应用会变得非常耗费资源。 您可以使用以下设计模式来解决此问题： 依赖注入 ( Dependency injection ，DI)：依赖注入使类能够定义其依赖项而不构造它们。在运行时，另一个类负责提供这些依赖项。我们建议使用 Dagger 2 库在 Android 应用中实现依赖注入。Dagger 2 通过遍历依赖项树自动构造对象，并为依赖项提供编译时保证。 服务定位器(service locator )：服务定位器模式提供了一个注册表，类可以从中获取其依赖项而不构造它们。 实现服务注册表比使用 DI 更容易，因此，如果您不熟悉 DI，请改用服务定位器模式。 您可以借助这些模式来扩展代码，因为它们可提供清晰的依赖项管理模式（无需复制代码，也不会增添复杂性）。此外，您还可以借助这些模式在测试和生产数据获取实现之间快速切换。 我们的示例应用使用 Dagger 2 来管理 Webservice 对象的依赖项。 连接 ViewModel 与存储区 现在，我们修改 UserProfileViewModel 以使用 UserRepository 对象： UserProfileViewModel public class UserProfileViewModel extends ViewModel { private LiveData user; private UserRepository userRepo; // Instructs Dagger 2 to provide the UserRepository parameter. @Inject public UserProfileViewModel(UserRepository userRepo) { this.userRepo = userRepo; } public void init(int userId) { if (this.user != null) { // ViewModel is created on a per-Fragment basis, so the userId // doesn't change. return; } user = userRepo.getUser(userId); } public LiveData getUser() { return this.user; } } 缓存数据 UserRepository 实现会抽象化对 Webservice 对象的调用，但由于它只依赖于一个数据源，因此不是很灵活。 UserRepository 实现的关键问题是，它从后端获取数据后，不会将该数据存储在任何位置。因此，如果用户在离开 UserProfileFragment 后再返回该类，则应用必须重新获取数据，即使数据未发生更改也是如此。 这种设计不够理想，原因如下： 浪费了宝贵的网络带宽。 迫使用户等待新的查询完成。 为了弥补这些缺点，我们向 UserRepository 添加了一个新的数据源，用于将 User 对象缓存在内存中： UserRepository // Informs Dagger that this class should be constructed only once. @Singleton public class UserRepository { private Webservice webservice; // Simple in-memory cache. Details omitted for brevity. private UserCache userCache; public LiveData getUser(int userId) { LiveData cached = userCache.get(userId); if (cached != null) { return cached; } final MutableLiveData data = new MutableLiveData<>(); userCache.put(userId, data); // This implementation is still suboptimal but better than before. // A complete implementation also handles error cases. webservice.getUser(userId).enqueue(new Callback() { @Override public void onResponse(Call call, Response response) { data.setValue(response.body()); } }); return data; } } 保存数据 使用我们当前的实现时，如果用户旋转设备或离开应用后立即返回应用，则现有界面将立即变为可见，因为存储区将从内存中的缓存检索数据。 不过，如果用户离开应用，数小时后当 Android 操作系统已终止进程后再回来，会发生什么？在这种情况下，如果依赖我们当前的实现，则需要再次从网络中获取数据。这一重新获取的过程不仅是一种糟糕的用户体验，而且很浪费资源，因为它会消耗宝贵的移动数据。 您可以通过缓存网络请求来解决此问题，但这样做会带来一个值得关注的新问题：如果相同的用户数据因另一种类型的请求（如获取好友列表）而显示出来，会发生什么？应用将会显示不一致的数据，这样比较容易让用户感到困惑。例如，如果用户在不同的时间发出好友列表请求和单一用户请求，应用可能会显示同一用户的数据的两个不同版本。应用将需要弄清楚如何合并这些不一致的数据。 处理这种情况的正确方法是使用持久性模型。这就是 Room 持久性库的用武之地。 Room 是一个对象映射库，可利用最少的样板代码实现本地数据持久性。在编译时，它会根据数据架构验证每个查询，这样损坏的 SQL 查询会导致编译时错误而不是运行时失败。Room 可以抽象化处理原始 SQL 表格和查询的一些底层实现细节。它还允许您观察对数据库数据（包括集合和连接查询）的更改，并使用 LiveData 对象公开这类更改。它甚至明确定义了解决一些常见线程问题（如访问主线程上的存储空间）的执行约束。 注意：如果您的应用已使用 SQLite 对象关系映射 (ORM) 等其他持久性解决方案，那么您无需将现有解决方案替换为 Room。不过，如果您正在编写新应用或重构现有应用，那么我们建议您使用 Room 保留应用数据。这样一来，您便可以利用该库的抽象和查询验证功能。 要使用 Room，我们需要定义本地架构。首先，我们向 User 数据模型类添加 @Entity 注解，并向该类的 id 字段添加 @PrimaryKey 注解。这些注解会将 User 标记为数据库中的表格，并将 id 标记为该表格的主键： User @Entity class User { @PrimaryKey private int id; private String name; private String lastName; // Getters and setters for fields. } 然后，我们通过为应用实现 RoomDatabase 来创建一个数据库类： UserDatabase @Database(entities = {User.class}, version = 1) public abstract class UserDatabase extends RoomDatabase { } 请注意，UserDatabase 是抽象类。Room 将自动提供它的实现。详情请参阅 Room 文档。 现在，我们需要一种将用户数据插入数据库的方法。为了完成此任务，我们创建一个数据访问对象 (data access object，DAO)。 UserDao @Dao public interface UserDao { @Insert(onConflict = REPLACE) void save(User user); @Query(\"SELECT * FROM user WHERE id = :userId\") LiveData load(int userId); } 请注意，load 方法将返回一个 LiveData 类型的对象。Room 知道何时修改了数据库，并会自动在数据发生更改时通知所有活跃的观察者。由于 Room 使用 LiveData，因此此操作很高效；仅当至少有一个活跃的观察者时，它才会更新数据。 注意：Room 将根据表格的修改情况检查是否失效，这意味着它可能会发出误报通知。 定义 UserDao 类后，从我们的数据库类引用该 DAO： UserDatabase @Database(entities = {User.class}, version = 1) public abstract class UserDatabase extends RoomDatabase { public abstract UserDao userDao(); } 现在，我们可以修改 UserRepository 以纳入 Room 数据源： @Singleton public class UserRepository { private final Webservice webservice; private final UserDao userDao; private final Executor executor; @Inject public UserRepository(Webservice webservice, UserDao userDao, Executor executor) { this.webservice = webservice; this.userDao = userDao; this.executor = executor; } public LiveData getUser(String userId) { refreshUser(userId); // Returns a LiveData object directly from the database. return userDao.load(userId); } private void refreshUser(final String userId) { // Runs in a background thread. executor.execute(() -> { // Check if user data was fetched recently. boolean userExists = userDao.hasUser(FRESH_TIMEOUT); if (!userExists) { // Refreshes the data. Response response = webservice.getUser(userId).execute(); // Check for errors here. // Updates the database. The LiveData object automatically // refreshes, so we don't need to do anything else here. userDao.save(response.body()); } }); } } 请注意，虽然我们在 UserRepository 中更改了数据的来源，但不需要更改 UserProfileViewModel 或 UserProfileFragment。这种小范围的更新展示了我们的应用架构所具有的灵活性。这也很适合测试，因为我们可以提供虚拟的的 UserRepository，与此同时测试生产 UserProfileViewModel。 如果用户等待几天后再返回使用此架构的应用，他们很可能会看到过时的信息，直到存储区可以获取更新的信息。根据您的用例，您可能不希望显示这些过时的信息。您可以显示占位符数据，此类数据将显示虚拟值并指示您的应用当前正在获取并加载最新信息。 单一可信来源 不同的 REST API 端点返回相同的数据是一种很常见的现象。例如，如果我们的后端有其他端点返回好友列表，则同一个用户对象可能来自两个不同的 API 端点，甚至可能使用不同的粒度级别。如果 UserRepository 按原样从 Webservice 请求返回响应，而不检查一致性，则界面可能会显示混乱的信息，因为来自存储区的数据的版本和格式将取决于最近调用的端点。 因此，我们的 UserRepository 实现会将网络服务响应保存在数据库中。这样一来，对数据库的更改将触发对活跃 LiveData 对象的回调。使用此模型时，数据库会充当单一可信来源，应用的其他部分则使用 UserRepository 对其进行访问。无论您是否使用磁盘缓存，我们都建议您的存储区将某个数据源指定为应用其余部分的单一可信来源。 显示正在执行的操作 在某些用例（如拉动刷新）中，界面务必要向用户显示当前正在执行某项网络操作。将界面操作与实际数据分离开来是一种很好的做法，因为数据可能会因各种原因而更新。例如，如果我们获取了好友列表，可能会以编程方式再次获取相同的用户，从而触发 LiveData 更新。从界面的角度来看，传输中的请求只是另一个数据点，类似于 User 对象本身中的其他任何数据。 我们可以使用以下某个策略，在界面中显示一致的数据更新状态（无论更新数据的请求来自何处）： 更改 getUser() 以返回一个 LiveData 类型的对象。此对象将包含网络操作的状态。 有关示例，请参阅 Android 架构组件 GitHub 项目中的 NetworkBoundResource 实现。 在 UserRepository 类中再提供一个可以返回 User 刷新状态的公共函数。如果您只想在数据获取过程源自于显式用户操作（例如滑动以刷新）时在界面中显示网络状态，使用此策略效果会更好。 测试每个组件 在分离关注点部分中，我们已经提到，遵循此原则的一个主要好处是可测试性。 以下列表显示了如何测试扩展示例中的每个代码模块： 界面和交互（UI）：使用 Android 界面插桩测试。创建此测试的最佳方法是使用 Espresso 库。您可以创建 Fragment 并为其提供模拟的 UserProfileViewModel。由于 Fragment 只与 UserProfileViewModel 通信，因此模拟这一个类就足以完整测试应用的界面。 ViewModel：您可以使用 JUnit 测试来测试 UserProfileViewModel 类。您只需模拟一个类，即 UserRepository。 UserRepository：您也可以使用 JUnit 测试来测试 UserRepository。您需要模拟 Webservice 和 UserDao。在这些测试中，请验证以下行为： 存储区是否进行了正确的网络服务调用。 存储区是否将结果保存到数据库中。 在数据已缓存且保持最新状态时，存储区是否不会发出不必要的请求。 由于 Webservice 和 UserDao 都是接口，因此您可以模拟它们或者为更复杂的测试用例创建虚假实现。 UserDao：使用插桩测试来测试 DAO 类。由于这些插桩测试不需要任何界面组件，因此它们会快速运行。 对于每个测试，都请创建内存中数据库以确保测试没有任何副作用（例如更改磁盘上的数据库文件）。 注意：Room 允许指定数据库实现，因此可以通过提供 SupportSQLiteOpenHelper 的 JUnit 实现来测试 DAO。不过，不建议您使用这种方法，因为设备上运行的 SQLite 版本可能与开发设备上的 SQLite 版本不同。 Webservice：在这些测试中，请避免对后端进行网络调用。所有测试（尤其是基于网络的测试）都务必独立于外界。 有几个库（包括 MockWebServer）可帮助您为这些测试创建虚假的本地服务器。 测试软件工件：架构组件提供了一个可控制其后台线程的 maven 软件工件。android.arch.core:core-testing 软件工件包含以下 JUnit 规则： InstantTaskExecutorRule：使用此规则可立即在调用线程上执行任何后台操作。 CountingTaskExecutorRule：使用此规则可等待架构组件的后台操作。您还可以将此规则作为空闲资源与 Espresso 关联。 最佳做法 编程是一个创造性的领域，构建 Android 应用也不例外。无论是在多个 Activity 或 Fragment 之间传递数据，检索远程数据并将其保留在本地以在离线模式下使用，还是复杂应用遇到的任何其他常见情况，解决问题的方法都会有很多种。 虽然以下建议不是强制性的，但根据我们的经验，从长远来看，遵循这些建议会使您的代码库更强大、可测试性更高且更易维护： 请避免将应用的入口点（如 Activity、Service 和广播接收器）指定为数据源。 相反，您应只将其与其他组件协调，以检索与该入口点相关的数据子集。每个应用组件存在的时间都很短暂，具体取决于用户与其设备的交互情况以及系统当前的整体运行状况。 在应用的各个模块之间设定明确定义的职责界限。 例如，请勿在代码库中将从网络加载数据的代码散布到多个类或软件包中。同样，也不要将不相关的职责（如数据缓存和数据绑定）定义到同一个类中。 尽量少公开每个模块中的代码。 请勿试图创建“就是那一个(just that one)”快捷方式来呈现一个模块的内部实现细节。短期内，您可能会省了点时间，但随着代码库的不断发展，您可能会反复陷入技术上的麻烦。 考虑如何使每个模块可独立测试。 例如，如果使用明确定义的 API 从网络获取数据，将会更容易测试在本地数据库中保留该数据的模块。如果您将这两个模块的逻辑混放在一处，或将网络代码分散在整个代码库中，那么即便能够进行测试，难度也会大很多。 专注于应用的独特核心，以使其从其他应用中脱颖而出。 不要一次又一次地编写相同的样板代码，这是在做无用功。相反，您应将时间和精力集中放在能让应用与众不同的方面上，并让 Android 架构组件以及建议的其他库处理重复的样板。 保留尽可能多的相关数据和最新数据。 这样，即使用户的设备处于离线模式，他们也可以使用您应用的功能。请注意，并非所有用户都能享受到稳定的高速连接。 将一个数据源指定为单一可信来源。 每当应用需要访问这部分数据时，这部分数据都应一律源于此单一可信来源。 附录：公开网络状态 在上文的推荐应用架构部分中，我们省略了网络错误和加载状态以简化代码段。 本部分将演示如何使用可封装数据及其状态的 Resource 类来公开网络状态。 以下代码段提供了 Resource 的实现示例： // A generic class that contains data and status about loading this data. public class Resource { @NonNull public final Status status; @Nullable public final T data; @Nullable public final String message; private Resource(@NonNull Status status, @Nullable T data, @Nullable String message) { this.status = status; this.data = data; this.message = message; } public static Resource success(@NonNull T data) { return new Resource<>(Status.SUCCESS, data, null); } public static Resource error(String msg, @Nullable T data) { return new Resource<>(Status.ERROR, data, msg); } public static Resource loading(@Nullable T data) { return new Resource<>(Status.LOADING, data, null); } public enum Status { SUCCESS, ERROR, LOADING } } 有一个很常见的情况是，一边从网络加载数据，一边显示这些数据在磁盘上的副本，因此建议您创建一个可在多个地方重复使用的辅助程序类。在本例中，我们创建一个名为 NetworkBoundResource 的类。 下图显示了 NetworkBoundResource 的决策树： 它首先观察资源的数据库。首次从数据库中加载条目时，NetworkBoundResource 会检查结果是好到足以分派，还是应从网络中重新获取。请注意，考虑到您可能会希望在通过网络更新数据的同时显示缓存的数据，这两种情况可能会同时发生。 如果网络调用成功完成，它会将响应保存到数据库中并重新初始化数据流。如果网络请求失败，NetworkBoundResource 会直接分派失败消息。 注意：在将新数据保存到磁盘后，我们会重新初始化来自数据库的数据流。不过，通常我们不需要这样做，因为数据库本身正好会分派更改。 请注意，依赖于数据库来分派更改将产生相关副作用，这样不太好，原因是，如果由于数据未更改而使得数据库最终未分派更改，就会出现这些副作用的未定义行为。 此外，不要分派来自网络的结果，因为这样将违背单一可信来源原则。毕竟，数据库可能包含在“保存”操作期间更改数据值的触发器。同样，不要在没有新数据的情况下分派 SUCCESS，因为如果这样做，客户端会接收错误版本的数据。 以下代码段显示了 NetworkBoundResource 类为其子级提供的公共 API： // ResultType: Type for the Resource data. // RequestType: Type for the API response. public abstract class NetworkBoundResource { // Called to save the result of the API response into the database. @WorkerThread protected abstract void saveCallResult(@NonNull RequestType item); // Called with the data in the database to decide whether to fetch // potentially updated data from the network. @MainThread protected abstract boolean shouldFetch(@Nullable ResultType data); // Called to get the cached data from the database. @NonNull @MainThread protected abstract LiveData loadFromDb(); // Called to create the API call. @NonNull @MainThread protected abstract LiveData> createCall(); // Called when the fetch fails. The child class may want to reset components // like rate limiter. @MainThread protected void onFetchFailed(); // Returns a LiveData object that represents the resource that's implemented // in the base class. public final LiveData> getAsLiveData(); } 请注意有关该类定义的以下重要细节： 它定义了两个类型参数（ResultType 和 RequestType），因为从 API 返回的数据类型可能与本地使用的数据类型不匹配。 它对网络请求使用了一个名为 ApiResponse 的类。ApiResponse 是 Retrofit2.Call类的一个简单封装容器，可将响应转换为 LiveData 实例。 NetworkBoundResource 类的完整实现作为 Android 架构组件 GitHub 项目的一部分出现。 创建 NetworkBoundResource 后，我们可以使用它在 UserRepository 类中编写磁盘和网络绑定的 User 实现： UserRepository class UserRepository { Webservice webservice; UserDao userDao; public LiveData> loadUser(final int userId) { return new NetworkBoundResource() { @Override protected void saveCallResult(@NonNull User item) { userDao.insert(item); } @Override protected boolean shouldFetch(@Nullable User data) { return rateLimiter.canFetch(userId) && (data == null || !isFresh(data)); } @NonNull @Override protected LiveData loadFromDb() { return userDao.load(userId); } @NonNull @Override protected LiveData> createCall() { return webservice.getUser(userId); } }.getAsLiveData(); } } "},"ArchitectureComponents/Android架构组件-概述.html":{"url":"ArchitectureComponents/Android架构组件-概述.html","title":"概述","keywords":"","body":"Android架构组件——概述 Android体系结构组件是一组库（libraries），可帮助您设计健壮，可测试和可维护的应用程序。从用于管理UI组件生命周期和处理数据持久性的类开始。 轻松管理应用程序的生命周期。lifecycle-aware components可帮助您管理Activity和Fragment生命周期。生存配置更改（Survive configuration changes,），避免内存泄漏并轻松将数据加载到UI中。 使用LiveData构建数据对象，以便在基础数据库更改时通知视图（Vires）。 ViewModel存储在应用程序切换（rotations）中未销毁的UI相关的数据。 Room是一个SQLite对象映射库。使用它来避免样板（boilerplate）代码并轻松地将SQLite表数据转换为Java对象。 Room提供SQLite语句的编译时检查，可以返回RxJava，Flowable和LiveData observable。 最新的视频和新闻 视频 Improve your App's Architecture 博客 7 Steps To Room ViewModels and LiveData: Patterns + AntiPatterns ViewModels : A Simple Example ViewModels: Persistence, onSaveInstanceState(), Restoring UI State and Loaders Understanding migrations with Room 其他资源 想学习更多Android架构组件的内容，请考虑查看以下资源： Samples Sunflower：一个园艺应用程序，演示Android Jetpack的Android开发最佳实践。 Android Architecture Components basic sample (more...) Codelabs Android Room with a View (Java) (Kotlin) Android Data Binding codelab (more...) Training Udacity: Developing Android Apps Blog posts Announcing Architecture Components 1.0 Stable Android and Architecture (more...) Videos Android Jetpack: what's new in Architecture Components (Google I/O '18) Android Jetpack: easy background processing with WorkManager (Google I/O '18) (more...) "},"ArchitectureComponents/Android架构组件-给你的项目中添加组件.html":{"url":"ArchitectureComponents/Android架构组件-给你的项目中添加组件.html","title":"给你的项目中添加架构组件","keywords":"","body":"Android架构组件——给你的项目中添加架构组件 在开始之前，我们建议您阅读应用程序架构指南，该指南包含一些适用于所有Android应用程序的有用原则，并展示了如何将架构组件一起使用。 架构组件可从Google的Maven存储库获得。要使用它们，必须将存储库添加到项目中。 打开项目的build.gradle文件（不是您的应用或模块的文件）并添加google（）存储库，如下所示： allprojects { repositories { google() jcenter() } } 声明依赖 打开应用程序或模块的build.gradle文件，并添加所需的工件作为依赖项。您可以为所有体系结构组件添加依赖项，也可以选择子集。 请参阅发行说明中有关为每个Archiecture Component声明依赖关系的说明： Futures (found in androidx.concurrent) Lifecycle components (including ViewModel) Navigation (including SafeArgs) Paging Room WorkManager 有关AndroidX重构的更多信息，以及它如何影响这些类包和模块ID，请参阅AndroidX重构文档（refactor documentation）。 Kotlin 几个AndroidX依赖项支持Kotlin扩展模块。这些模块的名称后面附加了后缀“-ktx”。例如： implementation \"androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version\" 变为： implementation \"androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version\" 更多信息包括在Kotlin扩展的文档，可以在ktx documentation查看。 注意：对于基于Kotlin的应用程序，请确保使用kapt而不是annotationProcessor。你还应该添加kotlin-kapt插件。 "},"ArchitectureComponents/Android架构组件-布局和绑定表达式.html":{"url":"ArchitectureComponents/Android架构组件-布局和绑定表达式.html","title":"布局和绑定表达式","keywords":"","body":"布局和绑定表达式 "},"ArchitectureComponents/Android架构组件-使用可观察的数据对象.html":{"url":"ArchitectureComponents/Android架构组件-使用可观察的数据对象.html","title":"使用可观察的数据对象","keywords":"","body":"使用可观察的数据对象 "},"ArchitectureComponents/Android架构组件-生成的绑定类.html":{"url":"ArchitectureComponents/Android架构组件-生成的绑定类.html","title":"生成的绑定类","keywords":"","body":"生成的绑定类 "},"Intent-And-Intent-Filter/Intent和IntentFilters——概述.html":{"url":"Intent-And-Intent-Filter/Intent和IntentFilters——概述.html","title":"概述","keywords":"","body":"Intent和Intent filters——概述 原文(英文)地址 Intent 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用途主要包括以下三个： 启动 Activity Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并可以携带任何必要的数据。 如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，返回的结果将作为单独的 Intent 对象被您的 Activity 接收。如需了解详细信息，请参阅 Activity 指南。 启动Service Service 是一个没有用户界面而在后台执行操作的组件。在Android5.0（API21）及以上，你可以使用JobScheduler启动一个service，关于JobScheduler的更多信息请参阅API-reference documentation。 对于早于Android5.0的版本，你可以使用Service类的方法启动一个service。通过将 Intent 传递给 startService()，您可以启动service执行一个一次性（one-time）操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。 如果希望通过Service使用客户端-服务器接口（client-server interface），则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。如需了解详细信息，请参阅Service指南。 传递广播(Broadcast) 广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。 本文档剩余的部分将解释Intent是如何工作的以及如何使用Intent，相关内容请参阅和其他应用交互和Sharing Content Intent的类型 Intent 分为两种类型： 显式 Intent：按目标app的包名或者组件类的类名（完全限定类名， fully-qualified component class name）指定要启动的组件。 通常，您会在自己的应用中使用显式 Intent 来启动组件，这是因为您知道要启动的 Activity 或Service的类名。例如，启动新 Activity 以响应用户操作，或者启动Service以在后台下载文件。 隐式 Intent ：不会指定特定的组件，而是声明要执行的操作，从而允许其他应用中的组件来处理它。 例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。 图一展示了启动一个Activity时intent是如何被使用的。当Intent对象显式命名特定Activity组件时，系统立即启动该组件。 图 1. 隐式 Intent 如何通过系统传递以启动其他 Activity 的图解：[1]Activity A 创建包含操作描述的 Intent，并将其传递给 startActivity()。[2]Android 系统搜索所有应用中与 Intent 匹配的 Intent filter(过滤器)。 找到匹配项之后，[3] 系统通过调用匹配 Activity（Activity B）的 onCreate()方法并将Intent传递给该Activity ，以此启动匹配 Activity。 创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。 如果 Intent 匹配到了某个 Intent filter（过滤器），则系统将启动该Intent filter对应的组件，并向其传递 Intent 对象。 如果有多个Intent filter（过滤器）都匹配上了目标Intent，则系统会显示一个对话框，支持用户选取要使用的应用。 IIntent filter（过滤器）是应用清单文件中的一个表达式，它指定该组件要接收的 Intent 类型。 例如，通过为 Activity 声明 Intent 过滤器，您可以使其他应用能够直接使用某一特定类型的 Intent 启动该 Activity。同样，如果您没有为 Activity 声明任何 Intent 过滤器，则 Activity 只能通过显式 Intent 启动。 注意：为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为Service声明 Intent 过滤器。使用隐式 Intent 启动Service存在安全隐患，因为您无法确定哪些Service将响应 Intent，且用户无法看到哪些Service已启动。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会引发异常。 构建 Intent Intent 对象携带了 Android 系统用来确定要启动哪个组件的信息（例如，准确的组件名称或应当接收该 Intent 的组件类别），以及接收Intent的组件（就是Intent filter匹配上Intent的组件）为了正确执行操作而需要使用的信息（例如，要采取的操作以及要处理的数据）。 Intent 中包含的主要信息如下： 组件名称 要启动的组件名称。 这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。 如果没有组件名称，则 Intent 是隐式的，且系统将根据其他 Intent 信息（例如，以下所述的action、data和category）决定哪个组件应当接收 Intent。 因此，如需在应用中启动特定的组件，则应指定该组件的名称。 注：启动 Service 时，您应始终指定组件名称。 否则，您无法确定哪项Service会响应 Intent，且用户无法看到哪项服务已启动。 Action 指定要执行的通用操作（例如，“查看”或“选取”）的字符串。 对于broadcast Intent，这是指已发生且正在报告的操作。Action在很大程度上决定了其余 Intent 的构成，特别是data和 extra中包含的内容。 您可以指定自己的Action，供 Intent 在您的应用内使用（或者供其他应用调用您应用中的组件）。但是，您通常应该使用由 Intent 类或其他框架类定义的Action常量。以下是一些用于启动 Activity 的常见Action： ACTION_VIEW 如果您拥有一些可以通过某项Activity 向用户显示的信息（例如，要使用图库应用查看的照片；或者要使用地图应用查看的地址），请使用 Intent 将此Action与startActivity() 结合使用。 ACTION_SEND 这也称为“共享”Intent。如果您拥有一些用户可通过其他应用（例如，电子邮件应用或社交共享应用）共享的数据，则应使用 Intent 将此Action与 startActivity() 结合使用。 有关更多定义通用操作的常量，请参阅 Intent 类参考文档。 其他Action在 Android 框架中的其他位置定义。例如，对于在系统的设置应用中打开特定屏幕的操作，将在 Settings 中定义。 您可以使用 setAction() 或 Intent 构造函数为 Intent 指定Action。如果定义自己的Action，请确保将应用的软件包名称作为前缀。 例如：static final String ACTION_TIMETRAVEL = \"com.example.action.TIMETRAVEL\"; kotlin const val ACTION_TIMETRAVEL = \"com.example.action.TIMETRAVEL\" java static final String ACTION_TIMETRAVEL = \"com.example.action.TIMETRAVEL\"; Data 一个引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的Action决定。例如，如果操作是 ACTION_EDIT，则数据应包含待编辑文档的 URI。 创建 Intent 时，除了指定 URI 以外，指定数据类型（其 MIME 类型）往往也很重要。例如，能够显示图像的 Activity 可能无法播放音频文件，即便 URI 格式十分类似时也是如此。因此，指定数据的 MIME 类型有助于 Android 系统找到接收 Intent 的最佳组件。但有时，MIME 类型可以从 URI 中推断得出，特别当数据是 content: URI 时尤其如此。这表明数据位于设备中，且由 ContentProvider 控制，这使得数据 MIME 类型对系统可见。 要仅设置Data URI，请调用 setData()。 要仅设置 MIME 类型，请调用 setType()。如有必要，您可以使用 setDataAndType() 同时显式设置二者。 注意：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType() 同时设置 URI 和 MIME 类型。 Category 一个包含应处理 Intent 组件类型的附加信息的字符串。 您可以将任意数量的Category描述放入一个 Intent 中，但大多数 Intent 均不需要Category。 以下是一些常见的Category： CATEGORY_BROWSABLE 目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。 CATEGORY_LAUNCHER 该 Activity 是任务的初始(initial) Activity，在系统的应用启动器中列出。 有关category的完整列表，请参阅 Intent 类描述。 您可以使用 addCategory() 指定类别。 以上列出的这些属性（component name, action, data, category）表示 Intent 的既定特征。 通过读取这些属性，Android 系统能够解析应当启动哪个应用组件。 但是，Intent 也有可能会一些携带不影响其如何解析为应用组件的信息。 Intent 还可以提供： Extra 携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。 您可以使用各种 putExtra() 方法添加 extra 数据，每种方法均接受两个参数：键名和值。您还可以创建一个包含所有 extra 数据的 Bundle 对象，然后使用 putExtras() 将Bundle 插入 Intent 中。 例如，使用 ACTION_SEND 创建用于发送电子邮件的 Intent 时，可以使用 EXTRA_EMAIL键指定“目标”收件人，并使用 EXTRA_SUBJECT 键指定“主题”。 Intent 类将为标准化的数据类型指定多个 EXTRA_* 常量。如需声明自己的 extra 键（对于应用接收的 Intent），请确保将应用的软件包名称作为前缀。 例如： kotlin const val EXTRA_GIGAWATTS = \"com.example.EXTRA_GIGAWATTS\" java static final String EXTRA_GIGAWATTS = \"com.example.EXTRA_GIGAWATTS\"; Flag 在 Intent 类中定义的、充当 Intent 元数据的标志。 标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个任务），以及启动之后如何处理（例如，它是否属于最近的 Activity 列表）。 如需了解详细信息，请参阅 setFlags()) 方法。 显式 Intent 示例 显式 Intent 是指用于启动某个特定应用组件（例如，应用中的某个特定 Activity 或Service）的 Intent。 要创建显式 Intent，请为 Intent 对象定义组件名称 — Intent 的所有其他属性均为可选属性。 例如，如果在应用中构建了一个名为 DownloadService、旨在从网页下载文件的Service，则可使用以下代码启动该Service： kotlin // Executed in an Activity, so 'this' is the Context // The fileUrl is a string URL, such as \"http://www.example.com/image.png\" val downloadIntent = Intent(this, DownloadService::class.java).apply { data = Uri.parse(fileUrl) } startService(downloadIntent) Java // Executed in an Activity, so 'this' is the Context // The fileUrl is a string URL, such as \"http://www.example.com/image.png\" Intent downloadIntent = new Intent(this, DownloadService.class); downloadIntent.setData(Uri.parse(fileUrl)); startService(downloadIntent); Intent(Context, Class) 构造函数提供 App Context 和 component Class 对象。因此，此 Intent 将显式启动该应用中的 DownloadService 类。 如需了解有关构建和启动服务的详细信息，请参阅服务指南。 隐式 Intent 示例 隐式 Intent 指定能够在可以执行相应操作的设备上调用任何应用的操作。 如果您的应用无法执行该操作而其他应用可以，且您希望用户选取要使用的应用，则使用隐式 Intent 非常有用。 例如，如果您希望用户与他人共享您的内容，请使用 ACTION_SEND 操作创建 Intent，并添加指定共享内容的 extra。 使用该 Intent 调用 startActivity() 时，用户可以选取共享内容所使用的应用。 注意：用户可能没有任何应用处理您发送到 startActivity() 的隐式 Intent；或者，由于配置文件限制或管理员的设置，目标应用程序可能无法访问。如果出现这种情况，则调用将会失败，且应用会崩溃。要验证 Activity 是否会接收 Intent，请对 Intent 对象调用 resolveActivity()方法，如果返回结果为非空，则至少有一个应用能够处理该 Intent，且可以安全调用 startActivity()。 如果结果为空，则不应使用该 Intent。如有可能，您应停用发出该 Intent 的功能。以下示例显示如何验证intent是否可以解析为Activity。此示例不使用URI，但声明intent的data type以指定extras携带的内容。 kotlin // Create the text message with a string val sendIntent = Intent().apply { action = Intent.ACTION_SEND putExtra(Intent.EXTRA_TEXT, textMessage) type = \"text/plain\" } // Verify that the intent will resolve to an activity if (sendIntent.resolveActivity(packageManager) != null) { startActivity(sendIntent) } java // Create the text message with a string Intent sendIntent = new Intent(); sendIntent.setAction(Intent.ACTION_SEND); sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage); sendIntent.setType(\"text/plain\"); // Verify that the intent will resolve to an activity if (sendIntent.resolveActivity(getPackageManager()) != null) { startActivity(sendIntent); } 调用 startActivity() 时，系统将检查已安装的所有应用，确定哪些应用能够处理这种 Intent（即：含 ACTION_SEND 操作并携带“text/plain” data的 Intent ）。 如果只有一个应用能够处理，则该应用将立即打开并为其提供 Intent。 如果多个 Activity 接受 Intent，则系统将显示一个如图二所示的对话框，使用户能够选取要使用的应用。 图 2. 选择器对话框 强制使用应用选择器 如果有多个应用响应隐式 Intent，则用户可以选择要使用的应用，并将其设置为该操作的默认选项。 如果用户可能希望今后一直使用相同的应用执行某项操作（例如，打开网页时，用户往往倾向于仅使用一种网络浏览器），则这一点十分有用。 但是，如果多个应用可以响应 Intent，且用户可能希望每次使用不同的应用，则应采用显式方式显示选择器对话框。 选择器对话框每次都会要求用户选择用于操作的应用（用户无法为该操作选择默认应用）。 例如，当应用使用 ACTION_SEND 操作执行“共享”时，用户根据目前的状况可能需要使用另一不同的应用，因此应当始终使用选择器对话框，如图 2 中所示。 要展示选择器，请使用 createChooser() 创建 Intent，并将其传递给 startActivity()。如下面的例子所示。 kotlin val sendIntent = Intent(Intent.ACTION_SEND) ... // Always use string resources for UI text. // This says something like \"Share this photo with\" val title: String = resources.getString(R.string.chooser_title) // Create intent to show the chooser dialog val chooser: Intent = Intent.createChooser(sendIntent, title) // Verify the original intent will resolve to at least one activity if (sendIntent.resolveActivity(packageManager) != null) { startActivity(chooser) } java Intent sendIntent = new Intent(Intent.ACTION_SEND); ... // Always use string resources for UI text. // This says something like \"Share this photo with\" String title = getResources().getString(R.string.chooser_title); // Create intent to show the chooser dialog Intent chooser = Intent.createChooser(sendIntent, title); // Verify the original intent will resolve to at least one activity if (sendIntent.resolveActivity(getPackageManager()) != null) { startActivity(chooser); } 这将显示一个对话框，其中有响应传递给 createChooser() 方法的 Intent 的应用列表，并且将提供的文本用作对话框标题。 接收隐式 Intent 要公布应用可以接收哪些隐式 Intent，请在清单文件中使用 元素为每个应用组件声明一个或多个 Intent 过滤器。每个 Intent 过滤器均根据 Intent 的action、data和category指定自身接受的 Intent 类型。 仅当隐式 Intent 可以通过某一个 Intent 过滤器传递时，系统才会将该 Intent 传递给应用组件。 注：显式 Intent 始终会传递给其目标，无论组件声明的 Intent 过滤器如何均是如此。 应用组件应当为自身可执行的每个独特工作声明单独的过滤器。例如，图像库应用中的一个 Activity 可能会有两个过滤器，分别用于查看图像和编辑图像。 当 Activity 启动时，它将检查 Intent 并根据 Intent 中的信息决定具体的行为（例如，是否显示编辑器控件）。 每个 Intent 过滤器均由应用清单文件中的 元素定义，并嵌套在相应的应用组件（例如，元素）中。 在内部，您可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型： 在 name 属性中，声明接受的 Intent 操作。该值必须是操作的文本字符串值，而不是类常量。 使用一个或多个指定数据 URI 各个方面（scheme、host、port、path 等）和 MIME 类型的属性，声明接受的数据类型。 在 name 属性中，声明接受的 Intent 类别。该值必须是操作的文本字符串值，而不是类常量。 注：为了接收隐式 Intent，必须将 CATEGORY_DEFAULT 类别包括在 Intent 过滤器中。 方法 startActivity() 和 startActivityForResult() 将按照已申明 CATEGORY_DEFAULT类别的方式处理所有 Intent。 如果未在 Intent 过滤器中声明此类别，则隐式 Intent 不会解析为您的 Activity。 例如，以下是一个使用包含 Intent 过滤器的 Activity 声明，当数据类型为文本时，系统将接收ACTION_SEND Intent ： 您可以创建一个包括多个,,实例的过滤器。创建时，仅需确定组件能够处理这些过滤器元素的任何及所有组合即可。 如果要处理多种intent，但只能处理action,data,category的特定组合，则需要创建多个Intent 过滤器。 通过将Intent与三个元素中的每一个进行比较，以针对过滤器测试隐式Intent。要传递给组件，Intent必须通过所有三个测试。如果它甚至不能匹配其中一个，Android系统将不会将Intent传递给该组件。但是，由于组件可能具有多个intent过滤器，因此不通过组件过滤器之一的intent可能会在另一个过滤器上通过。有关如何解析Intent的更多信息，请参阅以下有关Intent解析的部分。 限制对组件的访问 使用 Intent 过滤器时，无法安全地防止其他应用启动组件。 尽管 Intent 过滤器将组件限制为仅响应特定类型的隐式 Intent，但如果开发者确定您的组件名称，则其他应用有可能通过使用显式 Intent 启动您的应用组件。如果必须确保只有您自己的应用才能启动您的某一组件，请针对该组件将 exported 属性设置为 \"false\"。 系统通过将 Intent 与所有这三个元素进行比较，根据过滤器测试隐式 Intent。 隐式 Intent 若要传递给组件，必须通过所有这三项测试。如果 Intent 甚至无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件。 但是，由于一个组件可能有多个 Intent 过滤器，因此未能通过某一组件过滤器的 Intent 可能会通过另一过滤器。如需了解有关系统如何解析 Intent 的详细信息，请参阅下文的 Intent 解析部分。 警告：使用Intent过滤器不是防止其他应用程序启动组件的安全方法。尽管intent过滤器限制组件仅响应某些类型的隐式Intent，但如果开发人员知道了您的组件名称，则另一个应用程序可能会使用显式Intent启动您的应用程序组件。如果只有您自己的应用程序能够启动您的某个组件很重要，请不要在清单中声明intent过滤器。而是将该组件的exported属性设置为“false”。 同样，为避免无意中运行其他应用程序的Service，请始终使用显示的意图来启动您自己的Service。 注：对于所有 Activity，您必须在清单文件中声明 Intent 过滤器。但是，Broadcast receiver的过滤器可以通过调用 registerReceiver() 动态注册， 之后，您可以使用 unregisterReceiver() 注销该接收器。这样一来，应用便可仅在应用运行时的某一指定时间段内侦听特定的广播。 过滤器示例 为了更好地了解一些 Intent 过滤器的行为，我们一起来看看从社交共享应用的清单文件中截取的以下片段。 第一个 Activity， MainActivity 是应用的入口点。当用户最初使用启动器图标启动应用时，该 Activity 将打开： ACTION_MAIN 操作指示这是主入口点，且不要求输入任何 Intent 数据。 CATEGORY_LAUNCHER 类别指示此 Activity 的图标应放入系统的应用启动器。 如果 元素未使用 icon 指定图标，则系统将使用元素中的图标。 这两个元素必须配对使用，Activity 才会显示在应用启动器中。 第二个 Activity， ShareActivity 旨在共享文本和媒体内容。 尽管用户可以通过从 MainActivity 导航进入此 Activity，但也可以从发出隐式 Intent（与两个 Intent 过滤器之一匹配）的另一应用中直接进入 ShareActivity。 注：MIME 类型 application/vnd.google.panorama360+jpg 是一个指定全景照片的特殊数据类型，您可以使用 Google panorama API 对其进行处理。 使用Pending Intent PendingIntent 对象是 Intent 对象的包装器。PendingIntent 的主要目的是授权外部应用使用包含(contained)的 Intent，就像是它从您应用本身的进程中执行的一样。 待定 Intent 的主要作用包括： 声明用户使用您的Notification执行操作时所要执行的 Intent（Android 系统的 NotificationManager 执行 Intent）。 声明用户使用您的 应用小部件执行操作时要执行的 Intent（主屏幕应用执行 Intent）。 声明未来某一特定时间要执行的 Intent（Android 系统的 AlarmManager 执行 Intent）。 由于每个 Intent 对象均设计为由特定类型的应用组件（Activity、Service 或BroadcastReceiver）进行处理，因此创建 PendingIntent也必须基于相同的考虑因素。使用Pending Intent 时，应用不会使用调用（如 startActivity()）执行该 Intent。相反，通过调用相应的构造方法创建 PendingIntent 时，您必须声明所需的组件类型： PendingIntent.getActivity()，适用于启动 Activity 的 Intent。 PendingIntent.getService()，适用于启动 Service 的 Intent。 PendingIntent.getBroadcast()，适用于启动 BroadcastReceiver 的 Intent。 除非您的应用正在从其他应用中接收待定 Intent，否则上述用于创建 PendingIntent 的方法可能是您所需的唯一 PendingIntent 方法。 每种方法均会提取当前的应用 Context、您要包装的 Intent 以及一个或多个指定应如何使用该 Intent 的标志（例如，是否可以多次使用该 Intent）。 如需了解有关使用待定 Intent 的详细信息，请参阅通知和应用小部件 API 指南等手册中每个相应用例的相关文档。 Intent 解析 当系统收到隐式 Intent 以启动 Activity 时，它根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity： Action Data（URI 和data type） Category 下文根据如何在应用的清单文件中声明 Intent 过滤器，描述 Intent 如何与相应的组件匹配。 Action测试 要指定接受的 Intent Action，Intent 过滤器既可以不声明任何元素，也可以声明多个此类元素。例如： ... 要匹配到此过滤器，您在 Intent 中指定的action必须与过滤器中列出的某一action匹配。 如果该过滤器未列出任何action，则 Intent 没有任何匹配项，因此所有 Intent 均无法通过测试。 但是，如果 Intent 未指定action，则只要某个过滤器至少包含一个Action就会通过测试。 Category测试 要指定接受的 Intent 类别， Intent 过滤器既可以不声明任何 元素，也可以声明多个此类元素。 例如： ... 若要使 Intent 通过category测试，则 Intent 中的每个类别均必须与过滤器中的category匹配。反之则未必，Intent 过滤器声明的category可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。 因此，不含category的 Intent 应当始终会通过此测试，无论过滤器中声明何种category均是如此。 注：Android 会自动将 CATEGORY_DEFAULT category应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent。因此，如需 Activity 接收隐式 Intent，则必须将 \"android.intent.category.DEFAULT\" 的类别包括在其 Intent 过滤器中（如上文的 示例所示）。 Data测试 要指定接受的 Intent data， Intent 过滤器既可以不声明任何元素，也可以声明多个此类元素。 例如： ... 每个 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。 URI 的每个部分均包含单独的 scheme、host、port 和 path 属性： ://:/ 例如： content://com.example.project:200/folder/subfolder/etc 在此 URI 中，scheme(架构)是 content，host(主机)是　com.example.project，port(端口)是 200，path(路径)是 folder/subfolder/etc。 在元素中，上述每个属性均为可选，但存在线性依赖关系： 如果未指定scheme，则会忽略host。 如果未指定host，则会忽略port。 如果未指定scheme和host，则会忽略path。 将 Intent 中的 URI 与过滤器中的 URI 进行比较时，它仅与过滤器中包含的 URI 的一部分进行比较。 例如： 如果过滤器仅指定scheme，则具有该scheme的所有Intent URI 均与该过滤器匹配。 如果过滤器指定scheme和authority，但未指定path，则具有相同scheme和authority的所有Intent URI 都会通过（passing）过滤器，无论其path如何均是如此。 如果过滤器指定scheme, authority, 和 path，则仅具有相同scheme, authority, 和 path的Intent URI 才会通过过滤器。 注：path规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。 Data测试会将 Intent 中的 URI 和 MIME 类型与过滤器中指定的 URI 和 MIME 类型进行比较。 规则如下： 仅当过滤器未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。 对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与过滤器的 URI 格式匹配、且过滤器同样未指定 MIME 类型时，才会通过测试。 仅当过滤器列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型、但不含 URI 的 Intent 才会通过测试。 仅当 MIME 类型与过滤器中列出的category匹配，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过 MIME category部分的测试。 如果 Intent 的 URI 与过滤器中的 URI 匹配，或者如果 Intent 具有content:或 file: URI 且过滤器未指定 URI，则 Intent 会通过测试的 URI 部分。 换言之，如果过滤器只是列出 MIME 类型，则假定组件支持content:或file: data 注意：如果intent指定URI或MIME类型，当中没有元素时，data测试将失败。 最后一条规则，即rule (d)，反映了期望组件能够从文件中或ContentProvider获得本地数据。因此，其过滤器可以仅列出数据类型，而不必显式命名 content: 和 file: schemes。这是一个典型的案例。 例如，下文中的元素向 Android 指出，组件可从ContentProvider处获得并显示图像数据： ... 由于大部分可用数据均由ContentProvider分发，因此指定数据类型（而非 URI）的过滤器也许最为常见。 另一常见的配置是具有scheme和type的过滤器。例如，下文中的元素向 Android 指出，组件可从网络中检索视频数据以执行操作： ... Intent 匹配 通过 Intent 过滤器匹配 Intent，这不仅有助于发现要激活的目标组件，还有助于发现设备上组件集的相关信息。 例如，主页应用通过使用指定 ACTION_MAIN 操作和 CATEGORY_LAUNCHER 类别的 Intent 过滤器查找所有 Activity，以此填充应用启动器。 您的应用可以采用类似的方式使用 Intent 匹配。PackageManager 提供了一整套 query...()方法来返回所有能够接受特定 Intent 的组件。此外，它还提供了一系列类似的 resolve...()方法来确定响应 Intent 的最佳组件。 例如，queryIntentActivities() 将返回能够执行那些作为参数传递的 Intent 的所有 Activity 列表，而 queryIntentServices() 则可返回类似的Service列表。这两种方法均不会激活组件，而只是列出能够响应的组件。 对于广播接收器，有一种类似的方法： queryBroadcastReceivers()。 "},"Intent-And-Intent-Filter/Intent和IntentFilters——通用Intent.html":{"url":"Intent-And-Intent-Filter/Intent和IntentFilters——通用Intent.html","title":"通用Intent","keywords":"","body":"Intent和Intent filters——通用Intent Intent 用于通过描述您想在某个 Intent 对象中执行的简单操作（如“查看地图”或“拍摄照片”）来启动另一应用中的某个 Activity。 这种 Intent 称作隐式 Intent，因为它并不指定要启动的应用组件，而是指定一项操作并提供执行该操作所需的一些数据。 当您调用 startActivity() 或 startActivityForResult() 并向其传递隐式 Intent 时，系统会 将 Intent 解析为可处理该 Intent 的应用并启动其对应的 Activity。 如果有多个应用可处理 Intent，系统会为用户显示一个对话框，供其选择要使用的应用。 本文档介绍几种可用于执行常见操作的隐式 Intent，按处理 Intent 的应用类型分成不同部分。 此外，每个部分还介绍如何创建 Intent 过滤器来公布您的应用执行相应操作的能力。 注意：如果设备上没有可接收隐式 Intent 的应用，您的应用将在调用 startActivity() 时崩溃。如需事先验证是否存在可接收 Intent 的应用，请对 Intent 对象调用resolveActivity()。如果结果为非空，则至少有一个应用能够处理该 Intent，并且可以安全调用 startActivity()。 如果结果为空，则您不应使用该 Intent。如有可能，您应停用调用该 Intent 的功能。 如果您不熟悉如何创建 Intent 或 Intent 过滤器，应该先阅读 Intent 和 Intent 过滤器。 如需了解如何从开发主机触发本页面上所列的 Intent，请参阅使用 Android 调试桥验证 Intent。 Google Voice Actions Google Voice Actions 会触发本页面上所列的一些 Intent 来响应语音命令。 如需了解详细信息，请参阅 Google Voice Actions 触发的 Intent。 闹钟 创建闹铃 Google Voice Actions “设置一个上午 7 点的闹铃” 如需创建新闹铃，请使用 ACTION_SET_ALARM action并使用下文介绍的 extra 指定时间和消息等闹铃详细信息。 注：Android 2.3（API 级别 9）及更高版本上只提供了小时、分钟和消息 extra。 其他 extra 是在更新版本的平台上新增的 extra。 操作 ACTION_SET_ALARM 数据 URI 无 MIME 类型 无 Extra EXTRA_HOUR 闹铃的小时。 EXTRA_MINUTES 闹铃的分钟。 EXTRA_MESSAGE 用于标识闹铃的自定义消息。 EXTRA_DAYS 一个 ArrayList，其中包括应重复触发该闹铃的每个周日。 每一天都必须使用 Calendar 类中的某个整型值（如 MONDAY）进行声明。对于一次性闹铃，无需指定此 extra。 EXTRA_RINGTONE 一个 content: URI，用于指定闹铃使用的铃声，也可指定 VALUE_RINGTONE_SILENT 以不使用铃声。如需使用默认铃声，则无需指定此 extra。 EXTRA_VIBRATE 一个布尔型值，用于指定该闹铃触发时是否振动。 EXTRA_SKIP_UI 一个布尔型值，用于指定响应闹铃的应用在设置闹铃时是否应跳过其 UI。 若为 true，则应用应跳过任何确认 UI，直接设置指定的闹铃。 示例 Intent： public void createAlarm(String message, int hour, int minutes) { Intent intent = new Intent(AlarmClock.ACTION_SET_ALARM) .putExtra(AlarmClock.EXTRA_MESSAGE, message) .putExtra(AlarmClock.EXTRA_HOUR, hour) .putExtra(AlarmClock.EXTRA_MINUTES, minutes); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 注:为了调用 ACTION_SET_ALARM Intent，您的应用必须具有 SET_ALARM 权限： 示例 Intent 过滤器： 创建定时器 Google Voice Actions “设置 5 分钟定时器” 如需创建倒计时器，请使用 ACTION_SET_TIMER 操作并使用下文介绍的 extra 指定持续时间等定时器详细信息。 注：此 Intent 是在 Android 4.4（API 级别 19）中添加的。 操作 ACTION_SET_TIMER 数据 URI 无 MIME 类型 无 Extra EXTRA_LENGTH以秒为单位的定时器定时长度。EXTRA_MESSAGE用于标识定时器的自定义消息。EXTRA_SKIP_UI一个布尔型值，用于指定响应定时器的应用在设置定时器时是否应跳过其 UI。 若为 true，则应用应跳过任何确认 UI，直接启动指定的定时器。 示例 Intent： public void startTimer(String message, int seconds) { Intent intent = new Intent(AlarmClock.ACTION_SET_TIMER) .putExtra(AlarmClock.EXTRA_MESSAGE, message) .putExtra(AlarmClock.EXTRA_LENGTH, seconds) .putExtra(AlarmClock.EXTRA_SKIP_UI, true); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 注为了调用 ACTION_SET_TIMER Intent，您的应用必须具有 SET_ALARM 权限： 示例 Intent 过滤器： 显示所有闹铃 如需显示闹铃列表，请使用 ACTION_SHOW_ALARMS 操作。 尽管调用此 Intent 的应用并不多（使用它的主要是系统应用），但任何充当闹钟的应用都应实现此 Intent 过滤器，并通过显示现有闹铃列表作出响应。 注：此 Intent 是在 Android 4.4（API 级别 19）中添加的。 操作 ACTION_SHOW_ALARMS 数据 URI 无 MIME 类型 无 示例 Intent 过滤器： 日历 添加日历事件 如需向用户的日历添加新事件，请使用 ACTION_INSERT 操作指定具有 Events.CONTENT_URI的数据 URI。 然后您就可以使用下文介绍的 extra 指定事件的各类详细信息。 操作 ACTION_INSERT 数据 URI Events.CONTENT_URI MIME 类型 \"vnd.android.cursor.dir/event\" Extra EXTRA_EVENT_ALL_DAY 一个布尔型值，指定此事件是否为全天事件。 EXTRA_EVENT_BEGIN_TIME 事件的开始时间（从新纪年开始计算的毫秒数）。 EXTRA_EVENT_END_TIME 事件的结束时间（从新纪年开始计算的毫秒数）。 TITLE 事件标题。 DESCRIPTION 事件说明。 EVENT_LOCATION 事件地点。 EXTRA_EMAIL 以逗号分隔的受邀者电子邮件地址列表。 可使用 CalendarContract.EventsColumns 类中定义的常量指定许多其他事件详细信息。 示例 Intent： public void addEvent(String title, String location, Calendar begin, Calendar end) { Intent intent = new Intent(Intent.ACTION_INSERT) .setData(Events.CONTENT_URI) .putExtra(Events.TITLE, title) .putExtra(Events.EVENT_LOCATION, location) .putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, begin) .putExtra(CalendarContract.EXTRA_EVENT_END_TIME, end); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 相机 拍摄照片或视频并将其返回 如需打开相机应用并接收拍摄的照片或视频，请使用 ACTION_IMAGE_CAPTURE 或 ACTION_VIDEO_CAPTURE 操作。此外，还可在 EXTRA_OUTPUT extra 中指定您希望相机将照片或视频保存到的 URI 位置。 操作 ACTION_IMAGE_CAPTURE 或 ACTION_VIDEO_CAPTURE 数据 URI 架构 无 MIME 类型 无 Extra EXTRA_OUTPUT相机应用应将照片或视频文件保存到的 URI 位置（Uri 对象形式）。 当相机应用成功将焦点归还给您的 Activity（您的应用收到 onActivityResult() 回调）时，您可以按通过 EXTRA_OUTPUT 值指定的 URI 访问照片或视频。 注：当您使用 ACTION_IMAGE_CAPTURE 拍摄照片时，相机可能还会在结果 Intent 中返回缩小尺寸的照片副本（缩略图），这个副本以 Bitmap 形式保存在名为 \"data\" 的 extra 字段中。 示例 Intent： static final int REQUEST_IMAGE_CAPTURE = 1; static final Uri mLocationForPhotos; public void capturePhoto(String targetFilename) { Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.withAppendedPath(mLocationForPhotos, targetFilename)); if (intent.resolveActivity(getPackageManager()) != null) { startActivityForResult(intent, REQUEST_IMAGE_CAPTURE); } } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == RESULT_OK) { Bitmap thumbnail = data.getParcelable(\"data\"); // Do other work with full size photo saved in mLocationForPhotos ... } } 如需了解有关如何使用此 Intent 拍摄照片的详细信息，包括如何创建与输出位置相适应的Uri，请阅读只拍摄照片或只拍摄视频。 示例 Intent 过滤器： 处理此 Intent 时，您的 Activity 应检查传入 Intent 中有无 EXTRA_OUTPUT extra，然后将拍摄的图像或视频保存在该 extra 指定的位置，并调用带 Intent 的 setResult()，该 Intent 将经过压缩的缩略图包括在名为 \"data\" 的 extra 中。 以静态图像模式启动相机应用 如需以静态图像模式打开相机应用，请使用 INTENT_ACTION_STILL_IMAGE_CAMERA 操作。 操作 INTENT_ACTION_STILL_IMAGE_CAMERA 数据 URI 架构 无 MIME 类型 无 Extra 无 示例 Intent： public void capturePhoto() { Intent intent = new Intent(MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA); if (intent.resolveActivity(getPackageManager()) != null) { startActivityForResult(intent); } } 示例 Intent 过滤器： 以视频模式启动相机应用 如需以视频模式打开相机应用，请使用 INTENT_ACTION_VIDEO_CAMERA 操作。 操作 INTENT_ACTION_VIDEO_CAMERA 数据 URI 架构 无 MIME 类型 无 Extra 无 示例 Intent： public void capturePhoto() { Intent intent = new Intent(MediaStore.INTENT_ACTION_VIDEO_CAMERA); if (intent.resolveActivity(getPackageManager()) != null) { startActivityForResult(intent); } } 示例 Intent 过滤器： 联系人/人员应用 选择联系人 如需让用户选择联系人和为您的应用提供对所有联系人信息的访问权限，请使用 ACTION_PICK操作，并将 MIME 类型指定为 Contacts.CONTENT_TYPE。 传送至您的 onActivityResult() 回调的结果 Intent 包含指向所选联系人的 content:URI。响应会利用 Contacts Provider API 为您的应用授予该联系人的临时读取权限，即使您的应用不具备 READ_CONTACTS 权限也没有关系。 提示：如果您只需要访问某一条联系人信息（如电话号码或电子邮件地址），请改为参见下一节的内容，其中介绍了如何选择特定联系人数据。 操作 ACTION_PICK 数据 URI 架构 无 MIME 类型 Contacts.CONTENT_TYPE 示例 Intent： static final int REQUEST_SELECT_CONTACT = 1; public void selectContact() { Intent intent = new Intent(Intent.ACTION_PICK); intent.setType(ContactsContract.Contacts.CONTENT_TYPE); if (intent.resolveActivity(getPackageManager()) != null) { startActivityForResult(intent, REQUEST_SELECT_CONTACT); } } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_SELECT_CONTACT && resultCode == RESULT_OK) { Uri contactUri = data.getData(); // Do something with the selected contact at contactUri ... } } 如需了解有关在获得联系人 URI 后如何检索联系人详情的信息，请阅读检索联系人详情。 请谨记，使用以上 Intent 检索联系人 URI 时，读取该联系人的详情并不需要 READ_CONTACTS 权限。 选择特定联系人数据 如需让用户选择某一条联系人信息，如电话号码、电子邮件地址或其他数据类型，请使用ACTION_PICK 操作，并将 MIME 类型指定为下列其中一个内容类型（如 CommonDataKinds.Phone.CONTENT_TYPE），以获取联系人的电话号码。 如果您只需要检索一种类型的联系人数据，则将此方法与来自ContactsContract.CommonDataKinds 类的 CONTENT_TYPE 配合使用要比使用 Contacts.CONTENT_TYPE（如上一部分中所示）更高效，因为结果可让您直接访问所需数据，无需对联系人提供程序执行更复杂的查询。 传送至您的 onActivityResult() 回调的结果 Intent 包含指向所选联系人数据的content: URI。响应会为您的应用授予该联系人数据的临时读取权限，即使您的应用不具备READ_CONTACTS 权限也没有关系。 操作 ACTION_PICK 数据 URI 架构 无 MIME 类型 CommonDataKinds.Phone.CONTENT_TYPE 从有电话号码的联系人中选取。 CommonDataKinds.Email.CONTENT_TYPE 从有电子邮件地址的联系人中选取。 CommonDataKinds.StructuredPostal.CONTENT_TYPE 从有邮政地址的联系人中选取。 或者 ContactsContract 下众多其他 CONTENT_TYPE 值中的一个。 示例 Intent： static final int REQUEST_SELECT_PHONE_NUMBER = 1; public void selectContact() { // Start an activity for the user to pick a phone number from contacts Intent intent = new Intent(Intent.ACTION_PICK); intent.setType(CommonDataKinds.Phone.CONTENT_TYPE); if (intent.resolveActivity(getPackageManager()) != null) { startActivityForResult(intent, REQUEST_SELECT_PHONE_NUMBER); } } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_SELECT_PHONE_NUMBER && resultCode == RESULT_OK) { // Get the URI and query the content provider for the phone number Uri contactUri = data.getData(); String[] projection = new String[]{CommonDataKinds.Phone.NUMBER}; Cursor cursor = getContentResolver().query(contactUri, projection, null, null, null); // If the cursor returned is valid, get the phone number if (cursor != null && cursor.moveToFirst()) { int numberIndex = cursor.getColumnIndex(CommonDataKinds.Phone.NUMBER); String number = cursor.getString(numberIndex); // Do something with the phone number ... } } } 查看联系人 如需显示已知联系人的详情，请使用 ACTION_VIEW 操作，并使用 content: URI 作为 Intent 数据指定联系人。 初次检索联系人 URI 的方法主要有两种： 使用 ACTION_PICK 返回的联系人 URI，如上一节所示（此方法不需要任何应用权限） 直接访问所有联系人的列表，如检索联系人列表所述（此方法需要 READ_CONTACTS 权限） 操作 ACTION_VIEW 数据 URI 架构 content: MIME 类型 无。该类型是从联系人 URI 推断得出。 示例 Intent： public void viewContact(Uri contactUri) { Intent intent = new Intent(Intent.ACTION_VIEW, contactUri); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 编辑现有联系人 如需编辑已知联系人，请使用 ACTION_EDIT 操作，使用 content: URI 作为 Intent 数据指定联系人，并将 extra 中由常量指定的任何已知联系人信息包括在 ContactsContract.Intents.Insert 中。 初次检索联系人 URI 的方法主要有两种： 使用 ACTION_PICK 返回的联系人 URI，如上一节所示（此方法不需要任何应用权限） 直接访问所有联系人的列表，如检索联系人列表所述（此方法需要 READ_CONTACTS 权限） 操作 ACTION_EDIT 数据 URI 架构 content: MIME 类型 该类型是从联系人 URI 推断得出。 Extra ContactsContract.Intents.Insert 中定义的一个或多个 extra，以便您填充联系人详情字段。 示例 Intent： public void editContact(Uri contactUri, String email) { Intent intent = new Intent(Intent.ACTION_EDIT); intent.setData(contactUri); intent.putExtra(Intents.Insert.EMAIL, email); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 如需了解有关如何编辑联系人的详细信息，请阅读使用 Intent 修改联系人。 插入联系人 如需插入新联系人，请使用 ACTION_INSERT 操作，将 Contacts.CONTENT_TYPE 指定为 MIME 类型，并将 extra 中由常量指定的任何已知联系人信息包括在ContactsContract.Intents.Insert 中。 操作 ACTION_INSERT 数据 URI 架构 无 MIME 类型 Contacts.CONTENT_TYPE Extra ContactsContract.Intents.Insert 中定义的一个或多个 extra。 示例 Intent： public void insertContact(String name, String email) { Intent intent = new Intent(Intent.ACTION_INSERT); intent.setType(Contacts.CONTENT_TYPE); intent.putExtra(Intents.Insert.NAME, name); intent.putExtra(Intents.Insert.EMAIL, email); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 如需了解有关如何插入联系人的详细信息，请阅读使用 Intent 修改联系人。 电子邮件 撰写带有可选附件的电子邮件 如需撰写电子邮件，请根据其是否包括附件使用以下其中一项操作，并使用下列 extra 键加入收件人和主题等电子邮件详情。 操作 ACTION_SENDTO（适用于不带附件） ACTION_SEND（适用于带一个附件） ACTION_SEND_MULTIPLE（适用于带多个附件） 数据 URI 架构 无 MIME 类型 \"text/plain\"``\"*/*\" Extra Intent.EXTRA_EMAIL ​ 包含所有“主送”收件人电子邮件地址的字符串数组。 Intent.EXTRA_CC 包含所有“抄送”收件人电子邮件地址的字符串数组。 Intent.EXTRA_BCC 包含所有“密件抄送”收件人电子邮件地址的字符串数组。 Intent.EXTRA_SUBJECT 包含电子邮件主题的字符串。 Intent.EXTRA_TEXT 包含电子邮件正文的字符串。 Intent.EXTRA_STREAM 指向附件的 Uri。如果使用的是 ACTION_SEND_MULTIPLE 操作，应将其改为包含多个 Uri 对象的 ArrayList。 示例 Intent： public void composeEmail(String[] addresses, String subject, Uri attachment) { Intent intent = new Intent(Intent.ACTION_SEND); intent.setType(\"*/*\"); intent.putExtra(Intent.EXTRA_EMAIL, addresses); intent.putExtra(Intent.EXTRA_SUBJECT, subject); intent.putExtra(Intent.EXTRA_STREAM, attachment); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 如果您想确保 Intent 只由电子邮件应用（而非其他短信或社交应用）进行处理，则需使用 ACTION_SENDTO 操作并加入 \"mailto:\" 数据架构。例如： public void composeEmail(String[] addresses, String subject) { Intent intent = new Intent(Intent.ACTION_SENDTO); intent.setData(Uri.parse(\"mailto:\")); // only email apps should handle this intent.putExtra(Intent.EXTRA_EMAIL, addresses); intent.putExtra(Intent.EXTRA_SUBJECT, subject); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 文件存储 检索特定类型的文件 如需请求用户选择文档或照片等文件并向您的应用返回文件引用，请使用ACTION_GET_CONTENT 操作并指定所需 MIME 类型。 向您的应用返回的文件引用对 Activity 的当前生命周期而言是瞬态引用，因此如果您想稍后进行访问，就必须导入可在稍后读取的副本。用户还可利用此 Intent 在进程中创建新文件（例如，用户可以不选择现有照片，而是用相机拍摄新照片）。 传送至您的 onActivityResult() 方法的结果 Intent 包括的数据具有指向该文件的 URI。该 URI 可以是任何类型，如 http: URI、file: URI 或 content: URI。 不过，如果您想将可选择的文件限定为可从内容提供程序 (content: URI) 访问的文件，以及通过 openFileDescriptor() 以文件流形式提供的文件，则您应该为 Intent 添加 CATEGORY_OPENABLE 类别。 在 Android 4.3（API 级别 18）及更高版本上，您还可以通过为 Intent 添加EXTRA_ALLOW_MULTIPLE 并将其设置为 true，允许用户选择多个文件。然后您就可以在getClipData() 返回的 ClipData 对象中访问每一个选定的文件。 操作 ACTION_GET_CONTENT 数据 URI 架构 无 MIME 类型 与用户应选择的文件类型对应的 MIME 类型。 Extra EXTRA_ALLOW_MULTIPLE 一个布尔型值，声明用户是否可以一次选择多个文件。 EXTRA_LOCAL_ONLY 一个布尔型值，声明是否返回的文件必须直接存在于设备上，而不是需要从远程服务下载。 类别（可选） CATEGORY_OPENABLE只返回可通过 openFileDescriptor() 以文件流形式表示的“可打开”文件。 用于获取照片的示例 Intent： static final int REQUEST_IMAGE_GET = 1; public void selectImage() { Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\"image/*\"); if (intent.resolveActivity(getPackageManager()) != null) { startActivityForResult(intent, REQUEST_IMAGE_GET); } } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_IMAGE_GET && resultCode == RESULT_OK) { Bitmap thumbnail = data.getParcelable(\"data\"); Uri fullPhotoUri = data.getData(); // Do work with photo saved at fullPhotoUri ... } } 用于返回照片的示例 Intent 过滤器： 打开特定类型的文件 在 Android 4.4 或更高版本上运行时，您可以不必检索必须导入应用的文件副本（使用 ACTION_GET_CONTENT 操作），而是使用 ACTION_OPEN_DOCUMENT 操作并指定 MIME 类型，请求打开由另一个应用管理的文件。如果还需要允许用户创建应用可写入的新文档，可改用ACTION_CREATE_DOCUMENT 操作。例如，ACTION_CREATE_DOCUMENT Intent 允许用户选择他们想在哪里创建新 PDF 文档（在另一个管理文档存储的应用内），而不是从现有文档中进行选择 — 您的应用随后会收到其可以写入新文档的 URI 位置。 尽管从 ACTION_GET_CONTENT 操作传递至您的 onActivityResult() 方法的 Intent 可能返回任何类型的 URI，来自 ACTION_OPEN_DOCUMENT 和 ACTION_CREATE_DOCUMENT 的结果 Intent 始终将所选文件指定为 DocumentsProvider 支持的 content: URI。您可以通过openFileDescriptor() 打开该文件，并使用 DocumentsContract.Document 中的列查询其详细信息。 返回的 URI 会为您的应用授予对文件的长期读取权限（还可能会授予写入权限）。 因此，如果您想读取现有文件而不将其副本导入您的应用，或者您想就地打开和编辑文件，特别适合使用ACTION_OPEN_DOCUMENT操作（而不是使用 ACTION_GET_CONTENT）。 您还可以通过为 Intent 添加 EXTRA_ALLOW_MULTIPLE 并将其设置为 true，允许用户选择多个文件。如果用户只选择一项，您就可以从 getData() 检索该项目。如果用户选择多项，则 getData() 返回 null，此时您必须改为从 getClipData() 返回的 ClipData 对象检索每个项目。 注：您的 Intent 必须指定 MIME 类型，并且必须声明 CATEGORY_OPENABLE 类别。必要时，您可以使用 EXTRA_MIME_TYPES extra 添加一个 MIME 类型数组来指定多个 MIME 类型 — 如果您这样做，必须将 setType() 中的主 MIME 类型设置为 \"*/*\"。 操作 ACTION_OPEN_DOCUMENT 或 ACTION_CREATE_DOCUMENT 数据 URI 架构 无 MIME 类型 与用户应选择的文件类型对应的 MIME 类型。 Extra EXTRA_MIME_TYPES 与您的应用请求的文件类型对应的 MIME 类型数组。 当您使用此 extra 时，必须在setType() 中将主 MIME 类型设置为 \"*/*\"。 EXTRA_ALLOW_MULTIPLE 一个布尔型值，声明用户是否可以一次选择多个文件。 EXTRA_TITLE 供与 ACTION_CREATE_DOCUMENT 配合使用，用于指定初始文件名。 EXTRA_LOCAL_ONLY 一个布尔型值，声明是否返回的文件必须直接存在于设备上，而不是需要从远程服务下载。 类别 CATEGORY_OPENABLE只返回可通过 openFileDescriptor() 以文件流形式表示的“可打开”文件。 用于获取照片的示例 Intent： static final int REQUEST_IMAGE_OPEN = 1; public void selectImage() { Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT); intent.setType(\"image/*\"); intent.addCategory(Intent.CATEGORY_OPENABLE); // Only the system receives the ACTION_OPEN_DOCUMENT, so no need to test. startActivityForResult(intent, REQUEST_IMAGE_OPEN); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == REQUEST_IMAGE_OPEN && resultCode == RESULT_OK) { Uri fullPhotoUri = data.getData(); // Do work with full size photo saved at fullPhotoUri ... } } 第三方应用实际上无法通过 ACTION_OPEN_DOCUMENT 操作响应 Intent，而是由系统接收此 Intent，然后在统一用户界面中显示各类应用提供的所有文件。 如需在该 UI 中提供您的应用的文件，并允许其他应用打开它们，您必须实现一个DocumentsProvider，并加入一个 PROVIDER_INTERFACE Intent 过滤器 (\"android.content.action.DOCUMENTS_PROVIDER\")。例如： 如需了解有关如何实现从其他应用打开您的应用管理的文件的详细信息，请阅读存储访问框架指南。 本地操作 叫车 Google Voice Actions “给我叫一台出租车” “给我叫一台车” （仅限 Android Wear） 如需叫一台出租车，请使用ACTION_RESERVE_TAXI_RESERVATION 操作。 注：应用必须请求用户确认，然后才能完成操作。 操作 ACTION_RESERVE_TAXI_RESERVATION 数据 URI 无 MIME 类型 无 Extra 无 示例 Intent： public void callCar() { Intent intent = new Intent(ReserveIntents.ACTION_RESERVE_TAXI_RESERVATION); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 地图 显示地图上的位置 如需打开地图，请使用 ACTION_VIEW 操作，并通过下文介绍的其中一个架构在 Intent 数据中指定位置信息。 操作 ACTION_VIEW 数据 URI 架构 geo:*latitude*,*longitude* 显示给定经度和纬度处的地图。示例：\"geo:47.6,-122.3\" geo:*latitude*,*longitude*?z=*zoom* 按特定缩放级别显示给定经度和纬度处的地图。缩放级别为 1 时显示以给定纬度、经度为中心的全球地图。 最高（最精确）缩放级别为 23。示例：\"geo:47.6,-122.3?z=11\" geo:0,0?q=lat,lng(label) 显示给定经度和纬度处带字符串标签的地图。示例：\"geo:0,0?q=34.99,-106.61(Treasure)\" geo:0,0?q=my+street+address 显示“我的街道地址”的位置（可能是具体地址或位置查询）。示例：\"geo:0,0?q=1600+Amphitheatre+Parkway%2C+CA\" 注：geo URI 中传递的所有字符串都必须编码。 例如，字符串 1st & Pike, Seattle 应编码为 1st%20%26%20Pike%2C%20Seattle。字符串中的空格可使用 %20 编码或替换为加号 (+)。 MIME 类型 无 示例 Intent： public void showMap(Uri geoLocation) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(geoLocation); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 音乐或视频 播放媒体文件 如需播放音乐文件，请使用 ACTION_VIEW 操作，并在 Intent 数据中指定文件的 URI 位置。 操作 ACTION_VIEW 数据 URI 架构 file:**``content:**``http:** MIME 类型 \"audio/*\"``\"application/ogg\"``\"application/x-ogg\"``\"application/itunes\"或者您的应用可能需要的任何其他类型。 示例 Intent： public void playMedia(Uri file) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(file); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 基于搜索查询播放音乐 Google Voice Actions “播放 michael jackson 的 billie jean” 如需基于搜索查询播放音乐，请使用INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH Intent。应用可能会触发此 Intent 来响应用户的音乐播放语音命令。 接收此 Intent 的应用会在其库存音乐内搜索与给定查询匹配的现有内容，并在找到后开始播放该内容。 此 Intent 应该包括 EXTRA_MEDIA_FOCUS 字符串 extra，以指定预期搜索模式。 例如，搜索模式可指定搜索的目标是艺术家姓名还是歌曲名称。 操作 INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH 数据 URI 架构 无 MIME 类型 无 Extra MediaStore.EXTRA_MEDIA_FOCUS（必需） 表示搜索模式（用户是否在寻找特定艺术家、专辑、歌曲或播放列表）。 大多数搜索模式都需要额外的 extra。例如，如果用户有意收听某一首歌曲，Intent 可能需要额外增加三个 extra：歌曲名称、艺术家和专辑。 对于 EXTRA_MEDIA_FOCUS 的每个值，此 Intent 都支持下列搜索模式： 任意 - \"vnd.android.cursor.item/*\" 播放任意音乐。接收 Intent 的应用应该根据智能选择（如用户最后收听的播放列表）播放音乐。额外 extra：QUERY（必需）- 一个空字符串。始终提供此 extra，以实现向后兼容性：不了解搜索模式的现有应用可将此 Intent 作为非结构化搜索进行处理。 非结构化 - \"vnd.android.cursor.item/*\" 播放通过非结构化搜索查询找到的特定歌曲、专辑或类型。当应用无法识别用户想要收听的内容类型时，可能会生成一个具有此搜索模式的 Intent。 应用应尽可能使用更确切的搜索模式。额外 extra：QUERY（必需）- 一个包含艺术家、专辑、歌曲名称或类型任意组合的字符串。 类型 - Audio.Genres.ENTRY_CONTENT_TYPE 播放特定类型的音乐。额外 extra：\"android.intent.extra.genre\"（必需）- 类型。QUERY（必需）- 类型。始终提供此 extra，以实现向后兼容性：不了解搜索模式的现有应用可将此 Intent 作为非结构化搜索进行处理。 艺术家 - Audio.Artists.ENTRY_CONTENT_TYPE 播放特定艺术家的音乐。额外 extra：EXTRA_MEDIA_ARTIST（必需）- 艺术家。\"android.intent.extra.genre\" - 类型。QUERY（必需）- 一个包含艺术家或类型任意组合的字符串。 始终提供此 extra，以实现向后兼容性：不了解搜索模式的现有应用可将此 Intent 作为非结构化搜索进行处理。 专辑 - Audio.Albums.ENTRY_CONTENT_TYPE 播放特定专辑的音乐。额外 extra：EXTRA_MEDIA_ALBUM（必需）- 专辑。EXTRA_MEDIA_ARTIST - 艺术家。\"android.intent.extra.genre\" - 类型。QUERY（必需）- 一个包含专辑或艺术家任意组合的字符串。 始终提供此 extra，以实现向后兼容性：不了解搜索模式的现有应用可将此 Intent 作为非结构化搜索进行处理。 歌曲 - \"vnd.android.cursor.item/audio\" 播放特定歌曲。额外 extra：EXTRA_MEDIA_ALBUM - 专辑。EXTRA_MEDIA_ARTIST - 艺术家。\"android.intent.extra.genre\" - 类型。EXTRA_MEDIA_TITLE（必需）- 歌曲名称。QUERY（必需）- 一个包含专辑、艺术家、类型或名称任意组合的字符串。 始终提供此 extra，以实现向后兼容性：不了解搜索模式的现有应用可将此 Intent 作为非结构化搜索进行处理。 播放列表 - Audio.Playlists.ENTRY_CONTENT_TYPE 播放特定播放列表或符合额外 extra 指定的某些条件的播放列表。额外 extra：EXTRA_MEDIA_ALBUM - 专辑。EXTRA_MEDIA_ARTIST - 艺术家。\"android.intent.extra.genre\" - 类型。\"android.intent.extra.playlist\" - 播放列表。EXTRA_MEDIA_TITLE - 播放列表所基于的歌曲名称。QUERY（必需）- 一个包含专辑、艺术家、类型、播放列表或名称任意组合的字符串。 始终提供此 extra，以实现向后兼容性：不了解搜索模式的现有应用可将此 Intent 作为非结构化搜索进行处理。 示例 Intent： 如果用户想收听特定艺术家的音乐，搜索应用可生成以下 Intent： public void playSearchArtist(String artist) { Intent intent = new Intent(MediaStore.INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH); intent.putExtra(MediaStore.EXTRA_MEDIA_FOCUS, MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE); intent.putExtra(MediaStore.EXTRA_MEDIA_ARTIST, artist); intent.putExtra(SearchManager.QUERY, artist); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 处理此 Intent 时，您的 Activity 应通过检查传入 Intent 中 EXTRA_MEDIA_FOCUS extra 的值来确定搜索模式。您的 Activity 识别出搜索模式后，应该读取该特定搜索模式额外 extra 的值。您的应用随后便可利用这些信息在其库存音乐内进行搜索，以播放与搜索查询匹配的内容。 例如： protected void onCreate(Bundle savedInstanceState) { ... Intent intent = this.getIntent(); if (intent.getAction().compareTo(MediaStore.INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH) == 0) { String mediaFocus = intent.getStringExtra(MediaStore.EXTRA_MEDIA_FOCUS); String query = intent.getStringExtra(SearchManager.QUERY); // Some of these extras may not be available depending on the search mode String album = intent.getStringExtra(MediaStore.EXTRA_MEDIA_ALBUM); String artist = intent.getStringExtra(MediaStore.EXTRA_MEDIA_ARTIST); String genre = intent.getStringExtra(\"android.intent.extra.genre\"); String playlist = intent.getStringExtra(\"android.intent.extra.playlist\"); String title = intent.getStringExtra(MediaStore.EXTRA_MEDIA_TITLE); // Determine the search mode and use the corresponding extras if (mediaFocus == null) { // 'Unstructured' search mode (backward compatible) playUnstructuredSearch(query); } else if (mediaFocus.compareTo(\"vnd.android.cursor.item/*\") == 0) { if (query.isEmpty()) { // 'Any' search mode playResumeLastPlaylist(); } else { // 'Unstructured' search mode playUnstructuredSearch(query); } } else if (mediaFocus.compareTo(MediaStore.Audio.Genres.ENTRY_CONTENT_TYPE) == 0) { // 'Genre' search mode playGenre(genre); } else if (mediaFocus.compareTo(MediaStore.Audio.Artists.ENTRY_CONTENT_TYPE) == 0) { // 'Artist' search mode playArtist(artist, genre); } else if (mediaFocus.compareTo(MediaStore.Audio.Albums.ENTRY_CONTENT_TYPE) == 0) { // 'Album' search mode playAlbum(album, artist); } else if (mediaFocus.compareTo(\"vnd.android.cursor.item/audio\") == 0) { // 'Song' search mode playSong(album, artist, genre, title); } else if (mediaFocus.compareTo(MediaStore.Audio.Playlists.ENTRY_CONTENT_TYPE) == 0) { // 'Playlist' search mode playPlaylist(album, artist, genre, playlist, title); } } } 新笔记 创建笔记 如需创建新笔记，请使用 ACTION_CREATE_NOTE 操作并使用下文定义的 extra 指定笔记详情，例如主题和正文。 注：应用必须请求用户确认，然后才能完成操作。 操作 ACTION_CREATE_NOTE 数据 URI 架构 无 MIME 类型 PLAIN_TEXT_TYPE \"/\" Extra EXTRA_NAME 一个表示笔记标题或主题的字符串。 EXTRA_TEXT 一个表示笔记正文的字符串。 示例 Intent： public void createNote(String subject, String text) { Intent intent = new Intent(NoteIntents.ACTION_CREATE_NOTE) .putExtra(NoteIntents.EXTRA_NAME, subject) .putExtra(NoteIntents.EXTRA_TEXT, text); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 电话 发起通话 如需打开电话应用并拨打电话号码，请使用 ACTION_DIAL 操作，并使用下文定义的 URI 架构指定电话号码。 电话应用打开时会显示电话号码，但用户必需按拨打电话按钮才能开始通话。 Google Voice Actions “致电 555-5555” “致电 bob” “致电语音邮件” 如需直接拨打电话，请使用 ACTION_CALL 操作，并使用下文定义的 URI 架构指定电话号码。 电话应用打开时便会拨打电话，用户无需按拨打电话按钮。 ACTION_CALL 操作需要您在清单文件中添加 CALL_PHONE 权限： 操作 ACTION_DIAL - 打开拨号器或电话应用。ACTION_CALL - 拨打电话（需要 CALL_PHONE 权限） 数据 URI 架构 tel:``voicemail: MIME 类型 无 有效电话号码是指符合 IETF RFC 3966 规定的号码。举例来说，有效电话号码包括下列号码： tel:2125551212 tel:(212) 555 1212 电话的拨号器能够很好地对架构进行标准化，如电话号码。 因此并不严格要求 Uri.parse()方法中必须使用所述架构。不过，如果您尚未试用过架构，或者不确定是否可以处理架构，请改用 Uri.fromParts() 方法。 示例 Intent： public void dialPhoneNumber(String phoneNumber) { Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(\"tel:\" + phoneNumber)); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 搜索 使用特定应用搜索 Google Voice Actions “在我的视频应用中搜索有关猫的视频” 在您的应用中进行语音搜索 如需支持在您的应用环境内进行搜索，请使用 SEARCH_ACTION操作在您的应用中声明一个 Intent 过滤器，如下文示例 Intent 过滤器中所示。 操作 \"com.google.android.gms.actions.SEARCH_ACTION\"支持来自 Google Voice Actions 的搜索查询。 Extra QUERY一个包含搜索查询的字符串。 示例 Intent 过滤器： 执行网页搜索 如需发起网页搜索，请使用 ACTION_WEB_SEARCH 操作，并在 SearchManager.QUERY extra 中指定搜索字符串。 操作 ACTION_WEB_SEARCH 数据 URI 架构 无 MIME 类型 无 Extra SearchManager.QUERY搜索字符串。 示例 Intent： public void searchWeb(String query) { Intent intent = new Intent(Intent.ACTION_SEARCH); intent.putExtra(SearchManager.QUERY, query); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 设置 打开特定设置部分 如需在您的应用要求用户更改内容时打开某个系统设置屏幕，请使用下列其中一个 Intent 操作打开与操作名称对应的设置屏幕。 操作 ACTION_SETTINGS ACTION_WIRELESS_SETTINGS ACTION_AIRPLANE_MODE_SETTINGS ACTION_WIFI_SETTINGS ACTION_APN_SETTINGS ACTION_BLUETOOTH_SETTINGS ACTION_DATE_SETTINGS ACTION_LOCALE_SETTINGS ACTION_INPUT_METHOD_SETTINGS ACTION_DISPLAY_SETTINGS ACTION_SECURITY_SETTINGS ACTION_LOCATION_SOURCE_SETTINGS ACTION_INTERNAL_STORAGE_SETTINGS ACTION_MEMORY_CARD_SETTINGS 有关其他可用的设置屏幕，请参见 Settings 文档。 数据 URI 架构 无 MIME 类型 无 示例 Intent： public void openWifiSettings() { Intent intent = new Intent(Intent.ACTION_WIFI_SETTINGS); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 发送短信 撰写带附件的短信/彩信 如需发起短信或彩信，请使用以下其中一个 Intent 操作，并使用下列 extra 键指定电话号码、主题和消息正文等消息详情。 操作 ACTION_SENDTO 或 ACTION_SEND 或 ACTION_SEND_MULTIPLE 数据 URI 架构 sms:** smsto:** mms:** mmsto:** 以上每一个架构的处理方式都相同。 MIME 类型 \"text/plain\" \"image/*\" \"video/*\" Extra \"subject\" 表示消息主题的字符串（通常只适用于彩信）。 \"sms_body\" 表示消息正文的字符串。 EXTRA_STREAM 指向要附加的图像或视频的 Uri。 如果使用的是 ACTION_SEND_MULTIPLE 操作，此 extra 应为指向要附加的图像/视频的 Uri ArrayList。 示例 Intent： public void composeMmsMessage(String message, Uri attachment) { Intent intent = new Intent(Intent.ACTION_SENDTO); intent.setType(HTTP.PLAIN_TEXT_TYPE); intent.putExtra(\"sms_body\", message); intent.putExtra(Intent.EXTRA_STREAM, attachment); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 如果您想确保 Intent 只由短信应用（而非其他电子邮件或社交应用）进行处理，则需使用ACTION_SENDTO 操作并加入 \"smsto:\" 数据架构。例如： public void composeMmsMessage(String message, Uri attachment) { Intent intent = new Intent(Intent.ACTION_SEND); intent.setData(Uri.parse(\"smsto:\")); // This ensures only SMS apps respond intent.putExtra(\"sms_body\", message); intent.putExtra(Intent.EXTRA_STREAM, attachment); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 注：如果您要开发短信/彩信应用，必须为几项额外操作实现 Intent 过滤器，才能在 Android 4.4 及更高版本上成为默认短信应用。 如需了解详细信息，请参见 Telephony 处的文档。 网络浏览器 加载网址 Google Voice Actions “打开 example.com” 如需打开网页，请使用 ACTION_VIEW 操作，并在 Intent 数据中指定网址。 操作 ACTION_VIEW 数据 URI 架构 http:** https:** MIME 类型 \"text/plain\" \"text/html\" \"application/xhtml+xml\" \"application/vnd.wap.xhtml+xml\" 示例 Intent： public void openWebPage(String url) { Uri webpage = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW, webpage); if (intent.resolveActivity(getPackageManager()) != null) { startActivity(intent); } } 示例 Intent 过滤器： 提示：如果您的 Android 应用提供与您的网站相似的功能，请为指向您的网站的 URL 加入一个 Intent 过滤器。 之后，如果用户安装了您的应用，点击电子邮件或其他网页中指向您的网站的链接时，将会打开您的 Android 应用而不是您的网页。 使用 Android 调试桥验证 Intent 如需验证您的应用可以对您想支持的 Intent 作出响应，可以使用 adb 工具来触发特定 Intent： 设置一台用于开发的 Android 设备，或使用一台虚拟设备。 安装一个处理您想支持的 Intent 的应用版本。 使用adb触发一个 Intent： adb shell am start -a -t -d \\ -e -n 例如： adb shell am start -a android.intent.action.DIAL \\ -d tel:555-5555 -n org.example.MyApp/.MyActivity 如果您定义了必需的 Intent 过滤器，您的应用应该会处理 Intent。 如需了解详细信息，请参见 ADB Shell 命令。 "},"UserInterface/使用RecyclerView创建列表.html":{"url":"UserInterface/使用RecyclerView创建列表.html","title":"使用RecyclerView创建列表","keywords":"","body":"使用RecyclerView创建列表 原文(英文)地址 如果您的应用需要显示含有大量数据（或经常更改的数据）的滚动元素列表，你应该使用本文描述的RecyclerView。 提示：你可以在Android studio中点击File->New->Fragment->Fragment(List)创建特定的模板代码，然后将该fragment添加到你的activity中。 图1. 一个使用RecyclerView的列表 图 2. 一个同时使用了 CardView的列表 如果你想要创建一个像图2那样具有卡片的列表，请同时使用Create a Card-based Layout中描述的CardView。 如果你想阅读更多关于RecycleView的示例代码，请访问RecyclerView Sample App。 RecyclerView概述 RecyclerView控件是一个更高级、更灵活版本的ListView。 在RecyclerView中，若干不同的组件可以工作在一起以展示你的数据，用户界面的整体容器是您添加到layout的RecyclerView对象。 RecyclerView使用您提供的布局管理器中提供的View填充自己，这里的布局管理器指的是我们的标准布局管理器之一（例如LinearLayoutManager或GridLayoutManager），或您自己自定义的布局管理器。 列表中的View由ViewHolder对象表示。这些对象是您通过继承RecyclerView.ViewHolder定义的类的实例。每个ViewHolder对象负责显示View中的单个项目（item）。例如，如果您的列表显示音乐集，则每个ViewHolder对象可能代表一个专辑。 RecyclerView仅会创建当前显示在屏幕上的列表部分所需的ViewHolder，以及一些附加的View，当用户滚动列表时，RecyclerView才会获取屏幕外的View并将它们重新绑定到滚动到屏幕上的数据。 ViewHolder对象是被一个adapter对象所管理的，你可以通过继承RecyclerView.Adapter类来自定义你自己的Adapter类，这个Adapter会根据需要创建ViewHolder，同时将ViewHolder和对应的数据绑定起来。它通过将ViewHolder分配到一个位置，并调用Adapter类的onBindViewHolder（）方法来完成此操作，该方法使用ViewHolder的位置（基于其列表位置）来确定需要显示的内容应该是什么。 这个RecyclerView模型做了很多优化工作，所以你不必： 首次填充列表时，它会创建并绑定列表的某些ViewHolder对象。例如，如果当前View显示位置0到9的列表，则RecyclerView会创建并绑定这些ViewHolder对象，也可能会创建并绑定位置10的ViewHolder对象，这样，如果用户滚动列表，则下一个元素已经准备好显示了。 当用户滚动列表时，RecyclerView会根据需要创建新的ViewHolder对象。它还可以保存已滚动到屏幕外的ViewHolder对象，因此可以重复使用。如果用户改变他们正在滚动的方向，则可以向后移动从屏幕滚动出来的ViewHolder对象。另一方面，如果用户继续向相同方向滚动，则距离可显示屏幕距离最长的ViewHolder对象可以重新绑定到新的数据。ViewHolder对象不需要创建或填充View，相反，应用程序只更新View的内容以匹配它绑定的新项目。 当显示的项目发生更改时，您可以通过调用适当的RecyclerView.Adapter.notify ...（）方法来通知适配器。然后，适配器的内置代码仅重新绑定受影响的项目。 添加依赖库 要使用RecyclerView，您需要将v7支持库添加到项目中，如下所示： 打开你app的build.gradle文件 添加支持库 dependencies { implementation 'com.android.support:recyclerview-v7:28.0.0' } 添加RecyclerView到你的布局文件中 现在，您可以将RecyclerView添加到布局文件中。例如，以下布局使用RecyclerView作为整个布局的唯一View： 将RecyclerView添加到布局文件后，获取对象的句柄，将其连接到布局管理器，并为要显示的数据添加适配器： kotlin class MyActivity : Activity() { private lateinit var recyclerView: RecyclerView private lateinit var viewAdapter: RecyclerView.Adapter private lateinit var viewManager: RecyclerView.LayoutManager override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.my_activity) viewManager = LinearLayoutManager(this) viewAdapter = MyAdapter(myDataset) recyclerView = findViewById(R.id.my_recycler_view).apply { // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView setHasFixedSize(true) // use a linear layout manager layoutManager = viewManager // specify an viewAdapter (see also next example) adapter = viewAdapter } } // ... } Java public class MyActivity extends Activity { private RecyclerView recyclerView; private RecyclerView.Adapter mAdapter; private RecyclerView.LayoutManager layoutManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.my_activity); recyclerView = (RecyclerView) findViewById(R.id.my_recycler_view); // use this setting to improve performance if you know that changes // in content do not change the layout size of the RecyclerView recyclerView.setHasFixedSize(true); // use a linear layout manager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); // specify an adapter (see also next example) mAdapter = new MyAdapter(myDataset); recyclerView.setAdapter(mAdapter); } // ... } 添加Adapter 要将所有数据提供给列表，必须继承RecyclerView.Adapter类。此对象为项（item）创建View，并在原始项不再可见时用新数据项替换某些View的内容。 以下代码示例显示了一个数据集的简单实现，该数据集由使用TextView小部件显示的字符串数组组成： kotlin ```kotlin class MyAdapter(private val myDataset: Array) : RecyclerView.Adapter() { // Provide a reference to the views for each data item // Complex data items may need more than one view per item, and // you provide access to all the views for a data item in a view holder. // Each data item is just a string in this case that is shown in a TextView. class MyViewHolder(val textView: TextView) : RecyclerView.ViewHolder(textView) // Create new views (invoked by the layout manager) override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyAdapter.MyViewHolder { // create a new view val textView = LayoutInflater.from(parent.context) .inflate(R.layout.my_text_view, parent, false) as TextView // set the view's size, margins, paddings and layout parameters ... return MyViewHolder(textView) } // Replace the contents of a view (invoked by the layout manager) override fun onBindViewHolder(holder: MyViewHolder, position: Int) { // - get element from your dataset at this position // - replace the contents of the view with that element holder.textView.text = myDataset[position] } // Return the size of your dataset (invoked by the layout manager) override fun getItemCount() = myDataset.size } - Java ```java public class MyAdapter extends RecyclerView.Adapter { private String[] mDataset; // Provide a reference to the views for each data item // Complex data items may need more than one view per item, and // you provide access to all the views for a data item in a view holder public static class MyViewHolder extends RecyclerView.ViewHolder { // each data item is just a string in this case public TextView textView; public MyViewHolder(TextView v) { super(v); textView = v; } } // Provide a suitable constructor (depends on the kind of dataset) public MyAdapter(String[] myDataset) { mDataset = myDataset; } // Create new views (invoked by the layout manager) @Override public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { // create a new view TextView v = (TextView) LayoutInflater.from(parent.getContext()) .inflate(R.layout.my_text_view, parent, false); ... MyViewHolder vh = new MyViewHolder(v); return vh; } // Replace the contents of a view (invoked by the layout manager) @Override public void onBindViewHolder(MyViewHolder holder, int position) { // - get element from your dataset at this position // - replace the contents of the view with that element holder.textView.setText(mDataset[position]); } // Return the size of your dataset (invoked by the layout manager) @Override public int getItemCount() { return mDataset.length; } } 布局管理器会调用Adapter的onCreateViewHolder（）方法，该方法需要构建一个RecyclerView.ViewHolder对象并设置它用于显示其内容的View。 ViewHolder对象的类型必须与Adapter类签名中声明的类型匹配。通常，它会通过inflate XML布局文件来设置View。由于ViewHolder对象尚未分配给任何特定数据，因此该方法实际上并未设置View的内容。 然后，布局管理器将ViewHolder对象绑定到其数据，它通过调用适配器的onBindViewHolder（）方法将ViewHolder的位置传递给RecyclerView来完成此操作，onBindViewHolder（）方法需要获取适当的数据，并使用它来填充ViewHolder的布局。例如，如果RecyclerView正在显示名称列表，则该方法可能会在列表中找到相应的名称，并填写ViewHolder的TextView。 如果列表需要更新，请在RecyclerView.Adapter对象上调用通知方法，例如notifyItemChanged（），布局管理器会重新绑定所有受影响的ViewHolder，允许他们的数据进行更新。 提示：ListAdapter类可用于确定列表更改时列表中的哪些项目需要更新。 自定义你的RecyclerView 您可以自定义RecyclerView以满足您的特定需求。标准类提供了大多数开发人员所需的所有功能，在许多情况下，您需要做的唯一定制是为每个ViewHolder对象设计View（View），并编写代码以使用适当的数据更新这些View。但是，如果您的应用具有特定要求，则可以通过多种方式修改标准行为。以下部分描述了一些常见的自定义。 修改layout RecyclerView使用布局管理器（layout manager）在屏幕上定位各个项目（item），并确定何时重用用户不再可见的itemView。要重用（或回收）View，布局管理器可能会要求适配器使用与数据集不同的元素替换View的内容。以这种方式回收View可以避免创建不必要的View或执行昂贵的findViewById（）查找，从而提高性能。 Android支持库包括三个标准布局管理器，每个管理器提供许多自定义选项： LinearLayoutManager将项目排列在一维列表中。使用带有LinearLayoutManager的RecyclerView提供的功能类似于旧的ListView布局。 GridLayoutManager将项目排列在二维网格中，就像棋盘上的方块一样。使用带有GridLayoutManager的RecyclerView提供的功能类似于较旧的GridView布局。 StaggeredGridLayoutManager将项目排列在二维网格中，每列稍微偏离前一个，就像美国国旗中的星星一样。 如果这些布局管理器都不适合您的需求，您可以通过继承RecyclerView.LayoutManager抽象类来创建自己的布局管理器。 添加item动画 每当item发生变化时，RecyclerView都会使用动画师（animator）来改变其外观。这个动画师（animator）是一个继承了RecyclerView.ItemAnimator抽象类的对象。默认情况下，RecyclerView使用DefaultItemAnimator来提供动画。如果要提供自定义动画，可以通过继承RecyclerView.ItemAnimator来定义自己的动画对象。 允许item被选中 recyclerview-selection库使用户可以使用触摸或鼠标输入选择RecyclerView列表中的项目。您可以保持对所选项目的可视化表示的控制。您还可以保留对控制选择行为的策略的控制，例如可以选择的项目以及可以选择的项目数。 要向RecyclerView实例添加选择支持，请按照下列步骤操作： 确定要使用的选择键类型，然后构建ItemKeyProvider。 您可以使用三种键类型来标识所选项：Parcelable（以及所有子类，如Uri），String和Long。有关选择键类型的详细信息，请参阅SelectionTracker.Builder。 实现ItemDetailsLookup。 ItemDetailsLookup使选择库能够在给定MotionEvent的情况下访问有关RecyclerView项的信息。它实际上是由RecyclerView.ViewHolder实例备份（或从中提取）的ItemDetails实例的工厂。 在RecyclerView中更新项目视图以反映用户已选择或取消选择它。 选择库不为所选项目提供默认的可视化装饰。您必须在实现onBindViewHolder（）时提供此功能。建议的方法如下： 在onBindViewHolder（）中，使用true或false调用View对象上的setActivated（）（而不是setSelected（））（具体取决于是否选中了该项）。 更新视图样式以表示激活状态。我们建议您使用颜色状态列表资源来配置样式。 使用ActionMode为用户提供工具以对选择执行操作。 注册SelectionTracker.SelectionObserver，以便在选择更改时收到通知。首次创建选择时，启动ActionMode以将其表示给用户，并提供特定于选择的操作。例如，您可以向ActionMode栏添加删除按钮，并连接栏上的后退箭头以清除选择。当选择变空时（如果用户最后一次清除了选择），请不要忘记终止操作模式。 执行任何解释的辅助操作 在事件处理流水线的末尾，库可以通过点击它来确定用户正在尝试激活项目，或者正在尝试拖放项目或一组所选项目。通过注册适当的监听器来对这些解释做出反应。有关更多信息，请参阅SelectionTracker.Builder。 使用SelectionTracker.Builder组装所有内容 以下示例显示如何使用Long选择键将这些片段放在一起： kotlin var tracker = SelectionTracker.Builder( \"my-selection-id\", recyclerView, StableIdKeyProvider(recyclerView), MyDetailsLookup(recyclerView), StorageStrategy.createLongStorage()) .withOnItemActivatedListener(myItemActivatedListener) .build() Java SelectionTracker tracker = new SelectionTracker.Builder<>( \"my-selection-id\", recyclerView, new StableIdKeyProvider(recyclerView), new MyDetailsLookup(recyclerView), StorageStrategy.createLongStorage()) .withOnItemActivatedListener(myItemActivatedListener) .build(); 为了构建SelectionTracker实例，您的应用必须提供用于将RecyclerView初始化为SelectionTracker.Builder的相同RecyclerView.Adapter。因此，在创建RecyclerView.Adapter之后，您很可能需要在创建后将SelectionTracker实例注入RecyclerView.Adapter。否则，您将无法从onBindViewHolder（）方法检查项目的选定状态。 在活动生命周期事件中包括选择。 为了在活动生命周期事件中保留选择状态，您的应用程序必须分别从活动的onSaveInstanceState（）和onRestoreInstanceState（）方法调用选择跟踪器的onSaveInstanceState（）和onRestoreInstanceState（）方法。您的应用还必须为SelectionTracker.Builder构造函数提供唯一的选择ID。此ID是必需的，因为活动或片段可能具有多个不同的可选列表，所有这些列表都需要以其保存状态保留。 其他资源 RecyclerView在Sunflower示例项目中有示例用法。 "},"BackGroundTasks/Service/Service——概述.html":{"url":"BackGroundTasks/Service/Service——概述.html","title":"概述","keywords":"","body":"Service——概述 原文(英文)地址 Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。Service可由其他应用组件启动，而且即使用户切换到其他应用，Service仍将在后台继续运行。 此外，组件可以绑定（bind）到Service，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，Service可以处理网络事务、播放音乐，执行文件 I/O 或与Content Provider交互，而所有这一切均可在后台进行。 Service分为三种类型： Foreground(前台) 前台服务主要做一些用户可察觉的操作。比如一个音频App在前台Service播放音乐。前台Service必须展示一个Notification。即使用户的注意力不在App上，App中的前台Service仍然会继续运行。 BackGround(后台) 后台服务主要做一些用户不能直接察觉到的操作。比如，如果一个app使用一个Service去做压缩存储的操作，那么该Service通常是一个后台Service。 注意：如果你的app target API在26及以上，当应用程序本身不在前台时，系统会对运行的后台服务施加限制（restrictions on running background services）。在大多数情况下，您的应用应该使用scheduled job而不是后台Service。 Bound(绑定) 当应用组件通过调用 bindService() 绑定到Service时，Service即处于“绑定”状态。绑定Service提供了一个Client-Service接口，允许组件与Service进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 Bound Service仅当与另一个应用组件绑定时才会运行。 多个组件可以同时绑定到该Service，但全部取消绑定后，该Service即会被销毁。 虽然本文档将started Service和bound Service分开讨论，但是您的Service可以同时以这两种方式运行，也就是说，它既可以是started Service（以无限期运行），也允许binding。问题只是在于您是否实现了一组回调方法：onStartCommand()（允许组件started Service）和 onBind()（允许binding Service）。 无论应用是处于启动状态还是绑定状态，抑或处于启动且绑定状态，任何应用组件均可像使用 Activity 那样通过调用 Intent 来使用Service（即使此Service来自另一应用）。 不过，您可以通过清单文件将Service声明为私有Service，并阻止其他应用访问。 使用清单文件声明Service部分将对此做更详尽的阐述。 注意：Service在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果Service需要执行任何 CPU 密集型工作( CPU-intensive work)或阻塞性操作（例如 MP3 播放或联网），则应在Service内创建新线程来完成这项工作。通过使用单独的线程，可以降低发生“应用无响应”(ANR) 错误的风险，而应用的主线程仍可继续专注于运行用户与 Activity 之间的交互。 在Service和Thread之间做出选择 Service是一种即使用户未与应用交互也可在后台运行的简单组件。 因此，您应仅在必要时才创建Service。 如果仅仅需要当用户正在关注你的app时启动主线程之外的线程执行工作，则应创建新线程而非Service。 例如，如果您只是想在 Activity 运行的同时播放一些音乐，则可在onCreate() 中创建子线程，在 onStart() 中启动子线程，然后在 onStop() 中停止子线程。您还可以考虑使用 AsyncTask 或 HandlerThread，而非传统的 Thread 类。如需了解有关线程的详细信息，请参阅进程和线程文档。 请记住，如果您确实要使用Service，默认情况下，它仍会在应用的主线程中运行，因此，如果Service执行的是密集型或阻塞性操作，则您仍应在Service内创建新线程。 基础知识 要创建Service，您必须创建 Service 的子类（或使用它的一个现有子类）。在实现中，您需要重写一些回调方法，以处理Service生命周期的某些关键点，如果合适，也提供一种机制以允许其他组件绑定到你的Service。 应重写的最重要的回调方法包括： onStartCommand() 当另一个组件（如 Activity）通过调用 startService() 请求启动Service时，系统将调用此方法。一旦执行此方法，Service即会启动并可在后台无限期运行。 如果您实现此方法，则在Service工作完成后，需要由您通过调用 stopSelf() 或 stopService() 来停止Service，如果您只想提供binding方式，则无需实现此方法。 onBind() 当另一个组件想通过调用 bindService() 与Service绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，您必须通过返回 IBinder 来提供一个接口，该接口供客户端与Service进行通信。请务必实现此方法，但如果您并不希望允许binding，则应返回 null。 onCreate() 首次创建Service时，系统将调用此方法来执行一次性设置程序（在调用onStartCommand() 或 onBind() 之前）。如果Service已在运行，则不会调用此方法。 onDestroy() 当Service不再被使用且将被销毁时，系统将调用此方法。Service应该实现此方法来清理所有资源，如线程、注册的侦听器（listener）、接收器（receiver）等。 这是Service接收的最后一个调用。 如果组件通过调用 startService() 启动Service（这会导致对 onStartCommand() 的调用），则Service将一直运行，直到Service使用 stopSelf() 自行停止运行，或由其他组件通过调用 stopService() 停止它为止。 如果组件是通过调用 bindService() 来创建Service且未调用 onStartCommand()，则Service只会在该组件与其绑定时运行。一旦该Service与所有客户端之间的绑定全部取消，系统便会销毁它。 仅当内存过低且必须回收系统资源以供具有用户焦点的 Activity 使用时，Android 系统才会强制停止Service。如果将Service绑定到具有用户焦点的 Activity，则它不太可能会被kill；如果将Service声明为在前台运行（稍后讨论），则它几乎很难会被kill。或者，如果Service已启动并要长时间运行，则系统会随着时间的推移降低Service在后台任务列表中的优先级排名，Service也将随之变得非常容易被终止；如果Service是started Service，则您必须将其设计为能够妥善处理系统对它的重启。 如果系统终止Service，那么一旦资源变得再次可用，系统便会重启Service（不过这还取决于从onStartCommand() 返回的值，本文稍后会对此加以讨论）。如需了解有关系统会在何时销毁Service的详细信息，请参阅进程和线程文档。 在下文中，您将了解如何创建各类Service以及如何在其他应用组件中使用Service。 使用清单文件声明Service 如同 Activity（以及其他组件）一样，您必须在应用的清单文件中声明你应用中的所有Service。 要声明Service，请添加元素作为元素的子元素。例如： ... ... 如需了解有关使用清单文件声明Service的详细信息，请参阅 元素参考文档。 您还可将其他属性包括在元素中，以定义一些特性，如启动Service及其运行所在进程所需的权限。android:name 属性是唯一必需的属性，用于指定Service的类名。应用一旦发布，即不应更改此类名，如若不然，可能会存在因依赖显式 Intent 来启动或绑定Service而破坏代码的风险（详情请阅读博客文章Things That Cannot Change）。 注意：为了保证你app的安全性，启动Service时应该尽量使用显式Intent的启动方式，并且不要给你的Service生命元素。使用隐式Intent启动Service具有一个安全隐患，因为您无法确定响应Intent的Service，并且用户无法查看启动的Service。从Android 5.0（API级别21）开始，如果使用隐式intent调用bindService（），系统将抛出异常。 你可以通过添加 android:exported 属性并将其设置为 \"false\"，确保Service仅适用于您的应用。这可以有效阻止其他应用启动您的Service（即便其他应用使用显式 Intent 也无法启动你的Service）。 创建启动（started）Service 启动Service由另一个组件通过调用 startService() 启动，这会导致Service的onStartCommand() 方法被调用。 Service启动之后，其生命周期即独立于启动它的组件，并且可以在后台无限期地运行，即使启动Service的组件已被销毁也不受影响。 因此，Service应在工作执行完成后通过调用 stopSelf() 来自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 应用组件（如 Activity）可以通过调用 startService() 方法并传递 Intent 对象（指定Service并包含待使用Service的所有数据）来启动Service，Service通过 onStartCommand() 方法接收此 Intent。 例如，假设某 Activity 需要将一些数据保存到在线数据库中。该 Activity 可以启动一个协同Service，并通过向 startService() 传递一个 Intent，为该Service提供要保存的数据。Service通过 onStartCommand() 接收 Intent，连接到互联网并执行数据库事务。事务完成之后，Service自行停止运行并随即被销毁。 注意：默认情况下，Service与声明Service的应用运行于同一进程，而且运行于该应用的主线程中。 因此，如果Service在执行密集型或阻塞性操作时用户正在与同一应用的 Activity 进行交互，则会降低 Activity 性能。 为了避免影响应用性能，您应在Service内启动新线程。 从传统上讲，您可以扩展两个类来创建启动Service： Service 这是适用于所有Service的基类。扩展此类时，必须创建一个用于执行所有Service工作的新线程，因为默认情况下，Service将使用应用的主线程，这会降低应用正在运行的所有 Activity 的性能。 IntentService 这是 Service 的子类，它使用工作线程逐一（串行）处理所有start request。如果您不要求Service同时处理多个请求，这是最好的选择。 您只需实现 onHandleIntent() 方法即可，该方法会接收每个start request对应的 Intent，使您能够执行后台工作。 下文介绍如何使用其中任一个类来实现Service。 扩展 IntentService 类 由于大多数启动Service都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现Service也许是最好的选择。 IntentService 执行以下操作： 创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent，该工作线程独立于你应用程序的主线程。 创建一个工作队列，用于将 Intent 逐一传递给 onHandleIntent() 实现，这样您就永远不必担心多线程问题。 在处理完所有启动请求后停止Service，因此您永远不必调用 stopSelf()。 提供 onBind() 的默认实现（返回 null）。 提供 onStartCommand() 的默认实现，将 Intent 依次发送到工作队列和 onHandleIntent() 实现。 综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。（不过，您还需要为Service提供小型构造函数（small constructor ）。） 以下是 IntentService 的实现示例： kotlin /** * A constructor is required, and must call the super [android.app.IntentService.IntentService] * constructor with a name for the worker thread. */ class HelloIntentService : IntentService(\"HelloIntentService\") { /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ override fun onHandleIntent(intent: Intent?) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } } } java public class HelloIntentService extends IntentService { /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public HelloIntentService() { super(\"HelloIntentService\"); } /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000); } catch (InterruptedException e) { // Restore interrupt status. Thread.currentThread().interrupt(); } } } 您只需要一个构造函数和一个 onHandleIntent() 实现即可。 如果您决定还重写其他回调方法（如 onCreate()、onStartCommand() 或 onDestroy()），请确保调用超类实现，以便 IntentService 能够妥善处理工作线程的生命周期。 例如，onStartCommand() 必须返回默认实现（即，如何将 Intent 传递给 onHandleIntent()）： kotlin override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show() return super.onStartCommand(intent, flags, startId) } java @Override public int onStartCommand(Intent intent, int flags, int startId) { Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show(); return super.onStartCommand(intent,flags,startId); } 除 onHandleIntent() 之外，您无需从中调用超类对应方法的唯一方法就是 onBind()（仅当Service允许绑定时，才需要实现该方法）。 在下一节中，您将了解如何在extend Service 基类时实现同类Service，该方法需要实现更多代码，但如需同时处理多个启动请求，则更适合使用该基类。 扩展Service类 正如上一部分中所述，使用 IntentService 显著简化了启动Service的实现。但是，若要求Service执行多线程（而不是通过工作队列处理启动请求），则可extend Service 类来处理每个 Intent。 为了便于比较，以下提供了 Service 类实现的代码示例，该类执行的工作与上述使用 IntentService 的示例完全相同。也就是说，对于每个启动请求，它均使用工作线程执行作业，且每次仅处理一个请求。 kotlin class HelloService : Service() { private var serviceLooper: Looper? = null private var serviceHandler: ServiceHandler? = null // Handler that receives messages from the thread private inner class ServiceHandler(looper: Looper) : Handler(looper) { override fun handleMessage(msg: Message) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000) } catch (e: InterruptedException) { // Restore interrupt status. Thread.currentThread().interrupt() } // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1) } } override fun onCreate() { // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work will not disrupt our UI. HandlerThread(\"ServiceStartArguments\", Process.THREAD_PRIORITY_BACKGROUND).apply { start() // Get the HandlerThread's Looper and use it for our Handler serviceLooper = looper serviceHandler = ServiceHandler(looper) } } override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int { Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show() // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job serviceHandler?.obtainMessage()?.also { msg -> msg.arg1 = startId serviceHandler?.sendMessage(msg) } // If we get killed, after returning from here, restart return START_STICKY } override fun onBind(intent: Intent): IBinder? { // We don't provide binding, so return null return null } override fun onDestroy() { Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show() } } java public class HelloService extends Service { private Looper serviceLooper; private ServiceHandler serviceHandler; // Handler that receives messages from the thread private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try { Thread.sleep(5000); } catch (InterruptedException e) { // Restore interrupt status. Thread.currentThread().interrupt(); } // Stop the service using the startId, so that we don't stop // the service in the middle of handling another job stopSelf(msg.arg1); } } @Override public void onCreate() { // Start up the thread running the service. Note that we create a // separate thread because the service normally runs in the process's // main thread, which we don't want to block. We also make it // background priority so CPU-intensive work doesn't disrupt our UI. HandlerThread thread = new HandlerThread(\"ServiceStartArguments\", Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // Get the HandlerThread's Looper and use it for our Handler serviceLooper = thread.getLooper(); serviceHandler = new ServiceHandler(serviceLooper); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Toast.makeText(this, \"service starting\", Toast.LENGTH_SHORT).show(); // For each start request, send a message to start a job and deliver the // start ID so we know which request we're stopping when we finish the job Message msg = serviceHandler.obtainMessage(); msg.arg1 = startId; serviceHandler.sendMessage(msg); // If we get killed, after returning from here, restart return START_STICKY; } @Override public IBinder onBind(Intent intent) { // We don't provide binding, so return null return null; } @Override public void onDestroy() { Toast.makeText(this, \"service done\", Toast.LENGTH_SHORT).show(); } } 正如您所见，与使用 IntentService 相比，这种方式完成更多工作。 但是，因为是由您自己处理对 onStartCommand() 的每个调用，因此可以同时执行多个请求。此示例并未这样做，但如果您希望如此，则可为每个请求创建一个新线程，然后立即运行这些线程（而不是等待上一个请求完成）。 请注意，onStartCommand() 方法必须返回整型数。整型数是一个值，用于描述系统应该如何在Service终止的情况下继续运行Service（如上所述，IntentService 的默认实现将为您处理这种情况，不过您可以对其进行修改），从 onStartCommand() 返回的值必须是以下常量之一： START_NOT_STICKY 如果系统在 onStartCommand() 返回后终止Service，则除非有pending Intent 要传递，否则系统不会重建Service。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行Service。 START_STICKY 如果系统在 onStartCommand() 返回后终止Service，则会重建Service并调用onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有pending Intent 要启动Service（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似Service）。 START_REDELIVER_INTENT 如果系统在 onStartCommand() 返回后终止Service，则会重建Service，并通过传递给Service的最后一个 Intent 调用 onStartCommand()。任何pending Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的Service。 有关这些返回值的更多详细信息，请查阅MessagingService sample on GitHub。 启动Service 您可以通过将 Intent（指定要启动的Service）传递给 startService()，从 Activity 或其他应用组件启动Service。Android 系统调用Service的 onStartCommand() 方法，并向其传递 Intent。（切勿直接调用 onStartCommand()。） 注意：如果您的应用面向API级别26或更高级别，除非应用程序本身位于前台，否则系统会对应用程序使用或创建后台Service施加限制。如果应用程序需要创建前台Service，则应用程序应调用startForegroundService（），该方法创建后台Service，但该方法向系统发出信号，表示该Service将自己提升到前台，创建Service后，服务必须在五秒钟内调用其startForeground（）方法。 例如，Activity 可以结合使用显式 Intent 与 startService()，启动上文中的示例Service (HelloService)： kotlin Intent(this, HelloService::class.java).also { intent -> startService(intent) } java Intent intent = new Intent(this, HelloService.class); startService(intent); startService() 方法将立即返回，且 Android 系统调用Service的 onStartCommand() 方法。如果Service尚未运行，则系统会先调用 onCreate()，然后再调用 onStartCommand()。 如果Service没有提供binding，则使用 startService() 传递的 Intent 是应用组件与Service之间唯一的通信模式。但是，如果您希望Service返回结果，则启动Service的客户端可以为broadcast创建一个PendingIntent （使用 getBroadcast()），并通过将其传递给启动Service的 Intent 达到将其传递给Service的目的。然后，Service就可以使用广播传递结果。 多个Service启动请求会导致多次对Service的 onStartCommand() 进行相应的调用。但是，要停止Service，只需一个Service发起停止请求（使用 stopSelf() 或 stopService()）即可。 停止Service started Service必须管理自己的生命周期。也就是说，除非系统必须回收内存资源，否则系统不会停止或销毁Service，而且Service在 onStartCommand() 返回后会继续运行。因此，Service必须通过调用stopSelf() 自行停止运行，或者由另一个组件通过调用 stopService() 来停止它。 一旦请求使用 stopSelf() 或 stopService() 停止Service，系统就会尽快销毁Service。 但是，如果Service同时处理多个 onStartCommand() 请求，则您不应在处理完一个启动请求之后停止Service，因为您可能又收到了新的启动请求（在第一个请求结束时停止Service会终止第二个请求）。为了避免这一问题，您可以使用 stopSelf(int) 确保Service的stop request基于最近的start request。也就说，在调用 stopSelf(int) 时，传递与stop请求的 ID 对应的start请求的 ID（传递给 onStartCommand() 的 startId）。然后，如果在您调用 stopSelf(int)之前Service收到了新的启动请求，ID 就不匹配，Service也就不会停止。 注意：为了避免浪费系统资源和消耗电池电量，应用必须在工作完成之后停止其Service。 如有必要，其他组件可以通过调用 stopService() 来停止Service。即使为Service启用了绑定，一旦Service收到对 onStartCommand() 的调用，您始终须亲自停止Service。 如需了解有关Service生命周期的详细信息，请参阅下面有关管理Service生命周期的部分。 创建绑定(bound)Service 绑定Service允许应用组件通过调用 bindService() 与其绑定，以便创建长期连接,通常不允许组件通过调用 startService() 来启动这种类型的Service。 如需与 Activity 和其他应用组件中的Service进行交互，或者需要通过进程间通信 (IPC) 向其他应用公开某些应用功能，则应创建绑定Service。 要创建绑定Service，必须实现 onBind() 回调方法并返回 IBinder，返回的IBinder用于定义与Service通信的接口。然后，其他应用组件可以调用 bindService() 来接收该接口，并开始调用Service的方法。Service只用于与其绑定的应用组件，因此如果没有组件绑定到Service，则系统会销毁Service（您不必按通过 onStartCommand() 启动的Service那样来停止绑定Service）。 要创建绑定Service，首先必须定义指定客户端如何与Service通信的接口。 Service与客户端之间的这个接口必须是 IBinder 的实现，并且Service必须从 onBind() 回调方法返回它。一旦客户端收到IBinder，即可开始通过该接口与Service进行交互。 多个客户端可以同时绑定到Service。客户端完成与Service的交互后，会调用 unbindService() 取消绑定。一旦没有客户端绑定到该Service，系统就会销毁它。 有多种方法实现绑定Service，其实现比启动Service更为复杂，因此绑定Service将在有关绑定Service的单独文档中专门讨论。 向用户发送通知(notifications) Service一旦运行起来，Service即可使用Toast Notifications或Status Bar Notifications来通知用户所发生的事件。 Toast 通知是指出现在当前窗口的表面、片刻随即消失不见的消息，而状态栏通知则在状态栏中随消息一起提供图标，用户可以选择该图标来采取操作（例如启动 Activity）。 通常，当某些后台工作已经完成（例如文件下载完成）且用户现在可以对其进行操作时，状态栏通知是最佳方法。 当用户从展开视图中选定通知时，通知即可启动 Activity（例如查看已下载的文件）。 如需了解详细信息，请参阅Toast Notifications或Status Bar Notifications开发者指南。 在前台运行Service 前台Service被认为是用户主观可以感知到的一种Service，因此即使内存不足，系统也不会考虑将其终止。 前台Service必须在状态栏提供通知，放在“正在进行（OnGoing）”标题下方，这意味着除非Service停止或从前台移除，否则不能清除通知。 警告：请限制您的应用程序使用前台服务。 当应用程序需要执行用户可以注意到的任务时，即使用户没有直接与应用程序交互，您也应该只使用前台服务。因此，前台服务必须显示优先级为PRIORITY_LOW或更高的状态栏通知，这有助于确保用户了解您的应用正在执行的操作。如果操作的重要性足够低，您希望使用最低优先级通知，那么您可能不应该使用服务而是考虑使用scheduled job。 每个运行服务的应用程序都会给系统带来额外的负担，从而消耗系统资源。如果应用尝试使用低优先级通知隐藏其服务，则可能会影响用户正在与之交互的应用的性能。因此，如果某个应用尝试运行具有最低优先级通知的服务，系统会在通知抽屉的底部调出应用的行为。 例如，应该将通过Service播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。同样，让用户跟踪其行走路程的应用程序需要前台服务来跟踪用户的位置。 注意：针对Android 9（API级别28）或更高级别并使用前台服务的应用程序必须请求FOREGROUND_SERVICE权限。这是常规权限，因此系统会自动将其授予请求的应用程序。 如果针对API级别28或更高级别的应用尝试在不请求FOREGROUND_SERVICE的情况下创建前台服务，则系统会抛出SecurityException。 要请求让Service运行于前台，请调用 startForeground()。此方法采用两个参数：唯一标识通知的整型数和状态栏的 Notification，Notification必须拥有PRIORITY_LOW或者更高的优先级，例如： kotlin val pendingIntent: PendingIntent = Intent(this, ExampleActivity::class.java).let { notificationIntent -> PendingIntent.getActivity(this, 0, notificationIntent, 0) } val notification: Notification = Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE) .setContentTitle(getText(R.string.notification_title)) .setContentText(getText(R.string.notification_message)) .setSmallIcon(R.drawable.icon) .setContentIntent(pendingIntent) .setTicker(getText(R.string.ticker_text)) .build() startForeground(ONGOING_NOTIFICATION_ID, notification) java Intent notificationIntent = new Intent(this, ExampleActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0); Notification notification = new Notification.Builder(this, CHANNEL_DEFAULT_IMPORTANCE) .setContentTitle(getText(R.string.notification_title)) .setContentText(getText(R.string.notification_message)) .setSmallIcon(R.drawable.icon) .setContentIntent(pendingIntent) .setTicker(getText(R.string.ticker_text)) .build(); startForeground(ONGOING_NOTIFICATION_ID, notification); 注意：提供给 startForeground() 的整型 ID 不得为 0。 要从前台移除Service，请调用 stopForeground()，此方法需要一个布尔值作为参数，指示是否也移除状态栏通知， 此方法不会停止Service， 但是，如果您在Service正在前台运行时将其停止，则通知也会被移除。 如需了解有关通知的详细信息，请参阅创建状态栏通知。 管理Service生命周期 Service的生命周期比 Activity 的生命周期要简单得多。但是，密切关注如何创建和销毁Service反而更加重要，因为Service可以在用户没有意识到的情况下运行于后台。 Service生命周期（从创建到销毁）可以遵循两条不同的路径： started Service 该Service在其他组件调用 startService() 时创建，然后无限期运行，且必须通过调用stopSelf() 来自行停止运行。此外，其他组件也可以通过调用 stopService() 来停止Service。Service停止后，系统会将其销毁。 bound Service 该Service在另一个组件（客户端）调用 bindService() 时创建。然后，客户端通过IBinder 接口与Service进行通信。客户端可以通过调用 unbindService() 关闭连接。多个客户端可以绑定到相同Service，而且当所有绑定全部取消后，系统即会销毁该Service。 （Service不必自行停止运行。） 这两条路径并非完全独立。也就是说，您可以绑定到已经使用 startService() 启动的Service。例如，可以通过使用 Intent（标识要播放的音乐）调用 startService() 来启动后台音乐Service。随后，可能在用户需要稍加控制播放器或获取有关当前播放歌曲的信息时，Activity 可以通过调用 bindService() 绑定到Service。在这种情况下，除非所有客户端均取消绑定，否则 stopService() 或 stopSelf() 不会实际停止Service。 实现生命周期回调 与 Activity 类似，Service也拥有生命周期回调方法，您可以实现这些方法来监控Service状态的变化并适时执行工作。 以下框架Service展示了每种生命周期方法： kotlin class ExampleService : Service() { private var startMode: Int = 0 // indicates how to behave if the service is killed private var binder: IBinder? = null // interface for clients that bind private var allowRebind: Boolean = false // indicates whether onRebind should be used override fun onCreate() { // The service is being created } override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { // The service is starting, due to a call to startService() return mStartMode } override fun onBind(intent: Intent): IBinder? { // A client is binding to the service with bindService() return mBinder } override fun onUnbind(intent: Intent): Boolean { // All clients have unbound with unbindService() return mAllowRebind } override fun onRebind(intent: Intent) { // A client is binding to the service with bindService(), // after onUnbind() has already been called } override fun onDestroy() { // The service is no longer used and is being destroyed } } java public class ExampleService extends Service { int startMode; // indicates how to behave if the service is killed IBinder binder; // interface for clients that bind boolean allowRebind; // indicates whether onRebind should be used @Override public void onCreate() { // The service is being created } @Override public int onStartCommand(Intent intent, int flags, int startId) { // The service is starting, due to a call to startService() return mStartMode; } @Override public IBinder onBind(Intent intent) { // A client is binding to the service with bindService() return mBinder; } @Override public boolean onUnbind(Intent intent) { // All clients have unbound with unbindService() return mAllowRebind; } @Override public void onRebind(Intent intent) { // A client is binding to the service with bindService(), // after onUnbind() has already been called } @Override public void onDestroy() { // The service is no longer used and is being destroyed } } 注：与 Activity 生命周期回调方法不同，您不需要调用这些回调方法的超类实现。 图 2. Service生命周期。左图显示了使用 `startService()` 所创建的Service的生命周期，右图显示了使用`bindService()` 所创建的Service的生命周期. 图2说明了Service的典型回调方法。虽然该图将startService（）创建的服务与bindService（）创建的服务分开，但请记住，任何服务（无论它是如何启动的）都可能允许客户端绑定到它。最初使用onStartCommand（）（通过调用startService（）的客户端）启动的服务仍然可以接收对onBind（）的调用（当客户端调用bindService（）时）。 通过实现这些方法，您可以监控Service生命周期的两个嵌套循环： Service的整个生命周期从调用onCreate()开始起，到onDestroy()返回时结束。与 Activity 类似，Service也在onCreate()中完成初始设置，并在onDestroy()中释放所有剩余资源。例如，音乐播放Service可以在onCreate()中创建用于播放音乐的线程，然后在onDestroy()中停止该线程。 无论Service是通过 startService() 还是 bindService() 创建，都会为所有Service调用 onCreate() 和 onDestroy() 方法。 Service的有效生命周期从调用onStartCommand()或onBind()方法开始。每种方法均有Intent对象，该对象分别传递到startService()或bindService()。 对于started Service，有效生命周期与整个生命周期同时结束（即便是在 onStartCommand()返回之后，Service仍然处于活动状态）。对于bound Service，有效生命周期在 onUnbind() 返回时结束。 注：尽管启动Service是通过调用 stopSelf() 或 stopService() 来停止，但是该Service并无相应的回调（没有 onStop() 回调）。因此，除非Service绑定到客户端，否则在Service停止时，系统会将其销毁 — onDestroy() 是接收到的唯一回调。 如需了解有关创建提供绑定的Service的详细信息，请参阅绑定Service文档，该文档的管理绑定Service的生命周期部分提供了有关 onRebind() 回调方法的更多信息。 "},"BackGroundTasks/Service/Service——创建后台服务.html":{"url":"BackGroundTasks/Service/Service——创建后台服务.html","title":"创建后台Service","keywords":"","body":"Service——创建后台服务 原文(英文)地址 IntentService类提供了简单结构用于在单个后台线程运行操作。这使得它能够处理长时间运行的操作，而不会影响用户界面的响应能力。此外，IntentService不受大多数用户界面生命周期事件的影响，因此它会在关闭AsyncTask的情况下继续运行。 IntentService有以下几点限制： 他不能直接和你的用户界面通信，要将其执行结果显示在UI上，你必须先将结果发送到Activity。 工作任务需要串行执行，如果IntentService中已经有一个操作在执行了，这时你又发送了一个新的任务，它会在前一个任务执行完成之后才执行第二个任务。 IntentService中运行的任务不能被中断。 虽然有上述限制，IntentService依然是简单后台任务的最佳实现方式。 本篇文章向你介绍如何创建你自己的IntentService子类，以及如何创建onHandleIntent()回调方法，最后像你介绍如何在manifest文件中定义IntentService。 处理传入的Intent 要为你的app创建IntentService组件，你应该创建一个继承自IntentService的子类，在该子类中你应该重写onHandleIntent()方法，就像下面这样： kotlin class RSSPullService : IntentService(RSSPullService::class.simpleName) override fun onHandleIntent(workIntent: Intent) { // Gets data from the incoming Intent val dataString = workIntent.dataString ... // Do work here, based on the contents of dataString ... } } java public class RSSPullService extends IntentService { @Override protected void onHandleIntent(Intent workIntent) { // Gets data from the incoming Intent String dataString = workIntent.getDataString(); ... // Do work here, based on the contents of dataString ... } } 注意，其他Service的常见回调方法，比如onStartCommand()会被IntentService自动调用，在IntentService类中，你应该避免重写此类回调方法。 要了解创建IntentService的详细内容，请参考拓展IntentService类 在manifest文件中定义IntentService IntentService同样也需要在你应用的manifest文件中定义，你应该像Service那样为在下定义IntentService条目(entry)： ... ... android：name属性唯一标识了该IntentService的类名。 注意元素不含有intent filter，发送工作给IntentService执行的Activity需要使用显示Intent，所以没必要定义Intent filter。这也意味着只有同一个app中的组件或者其他含有相同user ID的应用中的组件才有权限访问该Service。 现在你已经有了基本的IntentService类，你可以使用Intent对象向其发送工作请求。下篇文章将介绍如何构建这些Intent对象并将它们发送到IntentService。 "},"BackGroundTasks/Service/Service——向后台Service发送工作请求.html":{"url":"BackGroundTasks/Service/Service——向后台Service发送工作请求.html","title":"向后台Service发送工作请求","keywords":"","body":"Service——向后台Service发送工作请求 原文(英文)地址 上一篇文章介绍了如何创建一个JobIntentService类.这篇文章将介绍如何通过一个Intent来触发JobIntentService去执行一个操作，这个Intent中也可以用于JobintentService执行任务（操作）的一些数据。 创建工作请求并将其发送到JobIntentService 为了创建一个工作请求并将其发送给JobIntentService，我们需要创建一个Intent并JobIntentService通过调用enqueueWork()将其加入工作队列。你还可以向Intent中添加一些数据以提供给JobIntentService去执行操作。您还可以选择将数据添加到Intent（以Intent extras的形式）以供JobIntentService进行任务处理。有关创建Intent的更多信息，请阅读Intent和IntentFilters——概述中的构建Intent部分。 下面的代码段演示了这个过程： 1：为名为RSSPullService的JobIntentService类创建一个Intent： kotlin /* * Creates a new Intent to start the RSSPullService * JobIntentService. Passes a URI in the * Intent's \"data\" field. */ serviceIntent = Intent().apply { putExtra(\"download_url\", dataUrl) } java /* * Creates a new Intent to start the RSSPullService * JobIntentService. Passes a URI in the * Intent's \"data\" field. */ serviceIntent = new Intent(); serviceIntent.putExtra(\"download_url\", dataUrl)); 2：调用enqueueWork() kotlin private const val RSS_JOB_ID = 1000 RSSPullService.enqueueWork(context, RSSPullService::class.java, RSS_JOB_ID, serviceIntent) java // Starts the JobIntentService private static final int RSS_JOB_ID = 1000; RSSPullService.enqueueWork(getContext(), RSSPullService.class, RSS_JOB_ID, serviceIntent); 注意你可以在Activity或者Fragment的任何地方发送这个请求(Request)。比如，如果你需要先获取用户的输入，你可以在button点击的回调事件中发起这个请求(Request)。 当你调用了enqueueWork()之后，JobIntentService将会执行定义在它onHandleWork()方法中的任务，执行完成之后JobIntentService会自己停止自己（stop itself）。 下一步就是将任务执行的结果返回给源的Activity或者Fragment，下个文档将会介绍如何使用BroadCastReceiver去实现这个目的。 "},"BackGroundTasks/Service/Service——绑定（bound）Service.html":{"url":"BackGroundTasks/Service/Service——绑定（bound）Service.html","title":"绑定Service","keywords":"","body":"Service——绑定（bound）Service 原文(英文)地址 [TOC] 本文向您介绍如何创建bound service，包括如何绑定到来自其他应用组件的service。 有关一般Service的其他信息，例如如何从Service传递通知以及将Service设置为在前台运行，请参阅Service文档。 基础知识 bound service是 Service 的实现类，允许其他应用与其绑定和交互。要提供service绑定，您必须实现 onBind() 回调方法。该方法返回的 IBinder 对象定义了客户端用来与service进行交互的接口。 绑定到已经启动的service 正如Service文档中描述的那样，您可以创建同时具有started和bound两种状态的service。 也就是说，可通过调用 startService() 启动service，让service无限期运行，还可通过调用 bindService() 使客户端绑定到service。 如果您允许您的service同时具有started和bound状态，则service启动后，系统不会在所有客户端都取消绑定时自动销毁service。 所以，您必须通过调用 stopSelf() 或 stopService() 显式停止service。 尽管您通常只实现 onBind() 或 onStartCommand()中的一个，但有时需要同时实现这两个方法。例如，对于音乐播放器来说，让其service无限期运行的同时提供绑定很有用处。 这样一来，Activity 便可启动service进行音乐播放，即使用户离开应用，音乐播放也不会停止。 然后，当用户返回应用时，Activity 可绑定到service，重新获得回放的控制权。 要了解关于添加binding方式启动service时service的生命周期，请参阅管理bound service的生命周期部分. 客户端可通过调用 bindService() 绑定到service。调用时，它必须提供 ServiceConnection的实现，它会监控与service的连接。bindService() 方法的返回值表示Service是否存在以及是否允许客户端访问他。当 Android 系统创建客户端与service之间的连接时，会对 ServiceConnection 调用 onServiceConnected()，onServiceConnected（）中包含了一个IBinder类型的参数，客户端使用该参数与bound service进行通信。 多个客户端可同时连接到一个service。不过，只有在第一个客户端绑定时，系统才会调用service的onBind() 方法来检索 IBinder，之后系统无需再次调用 onBind()，便可将同一 IBinder传递至任何其他绑定的客户端。 当最后一个客户端取消与service的绑定时，系统会将service销毁（除非该service同时又被通过 startService() 方法启动）。 当您实现bound service时，最重要的环节是定义您的 onBind() 回调方法返回的接口。您可以通过几种不同的方法定义service的 IBinder 接口，下文对这些方法逐一做了阐述。 创建bound service 创建提供绑定的service时，您必须给客户端一个用来与service进行交互的编程接口IBinder。 您可以通过三种方法定义IBinder接口： 继承 Binder 类 如果service您的应用专用的（私有的），并且在与客户端相同的进程中运行（这是最常见的情况），则应通过继承 Binder 类并从 onBind() 中返回一个该实现类的实例以创建IBinder接口。客户端收到 Binder 对象后，可利用它直接访问 Binder 实现中乃至 Service 中可用的public方法。 如果service只是您自己应用的后台工作线程，则优先采用这种方法。 不以这种方式创建接口的唯一原因是，您的service被其他应用或不同的进程占用。 使用 Messenger 如需让你的接口跨进程工作，则可使用 Messenger 为service创建接口。service可以通过这种方式定义对应于不同类型 Message 对象的 Handler。此 Handler 是 Messenger 的基础，Messenger随后可与客户端分享一个 IBinder，从而让客户端能利用 Message 对象向service发送命令。此外，客户端还可定义自有的 Messenger，以便service回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，这样您就不必特异为你的service进行线程安全设计。 使用 AIDL AIDL（Android 接口定义语言）执行所有将对象（objects）分解成原语（primiitives）的工作，操作系统可以识别这些原语并将它们编组（marshals）到各进程中，以执行 IPC。 之前采用 Messenger 的方法的底层实际上也是基于 AIDL的。 如上所述，Messenger 会在单一线程中创建包含所有客户端请求的队列，以便service一次接收一个请求。 不过，如果您想让service同时处理多个请求，则可直接使用 AIDL。 在此情况下，您的service必须具备多线程处理能力，并采用线程安全（thread-safe ）式设计。 如需直接使用 AIDL，您必须创建一个定义编程接口的 .aidl 文件。Android SDK 工具利用该文件生成一个实现了定义的接口并处理 IPC 的抽象类，您随后可在service内对其进行继承（extend）。 注：大多数应用都不应该使用 AIDL 来创建bound service，因为它可能要求具备多线程处理能力，并可能导致增加实现的复杂性。因此，AIDL 并不适合大多数应用，本文也不会阐述如何将其用于您的service。如果您确定自己需要直接使用 AIDL，请参阅 AIDL 文档。 继承Binder 类 如果您的service仅供本地应用使用，不需要跨进程工作，则可以实现自己的 Binder 类，让您的客户端通过该类直接访问service中的public方法。 注：此方法只有在客户端和service位于同一应用和进程内这一情况下才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的service的音乐应用，此方法非常有效。 以下是具体的设置方法： 在您的service中，创建一个可满足下列任一要求的Binder实例： 包含客户端可调用的public方法 返回当前 Service 实例，其含有客户端可调用的public方法 返回由service承载（hosted）的其他类的实例，其中包含客户端可调用的public方法 从 onBind() 回调方法返回此 Binder 实例。 在客户端中，在 onServiceConnected() 回调方法中接收 Binder，并使用提供的方法调用bound service。 注：之所以要求service和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。service和客户端还必须在同一进程内，因为此方法不执行任何跨进程编组（marshaling）。 例如，以下这个service可让客户端通过 Binder 实现访问service中的方法： kotlin class LocalService : Service() { // Binder given to clients private val binder = LocalBinder() // Random number generator private val mGenerator = Random() /** method for clients */ val randomNumber: Int get() = mGenerator.nextInt(100) /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ inner class LocalBinder : Binder() { // Return this instance of LocalService so clients can call public methods fun getService(): LocalService = this@LocalService } override fun onBind(intent: Intent): IBinder { return binder } } java public class LocalService extends Service { // Binder given to clients private final IBinder binder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ public class LocalBinder extends Binder { LocalService getService() { // Return this instance of LocalService so clients can call public methods return LocalService.this; } } @Override public IBinder onBind(Intent intent) { return binder; } /** method for clients */ public int getRandomNumber() { return mGenerator.nextInt(100); } } LocalBinder 为客户端提供 getService() 方法，以检索 LocalService 的当前实例。这样，客户端便可调用service中的公共方法。 例如，客户端可调用service中的 getRandomNumber()。 点击按钮时，以下这个 Activity 会绑定到 LocalService 并调用 getRandomNumber() 方法： kotlin class BindingActivity : Activity() { private lateinit var mService: LocalService private var mBound: Boolean = false /** Defines callbacks for service binding, passed to bindService() */ private val connection = object : ServiceConnection { override fun onServiceConnected(className: ComponentName, service: IBinder) { // We've bound to LocalService, cast the IBinder and get LocalService instance val binder = service as LocalService.LocalBinder mService = binder.getService() mBound = true } override fun onServiceDisconnected(arg0: ComponentName) { mBound = false } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.main) } override fun onStart() { super.onStart() // Bind to LocalService Intent(this, LocalService::class.java).also { intent -> bindService(intent, connection, Context.BIND_AUTO_CREATE) } } override fun onStop() { super.onStop() unbindService(connection) mBound = false } /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ fun onButtonClick(v: View) { if (mBound) { // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. val num: Int = mService.randomNumber Toast.makeText(this, \"number: $num\", Toast.LENGTH_SHORT).show() } } } java public class BindingActivity extends Activity { LocalService mService; boolean mBound = false; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } @Override protected void onStart() { super.onStart(); // Bind to LocalService Intent intent = new Intent(this, LocalService.class); bindService(intent, connection, Context.BIND_AUTO_CREATE); } @Override protected void onStop() { super.onStop(); unbindService(connection); mBound = false; } /** Called when a button is clicked (the button in the layout file attaches to * this method with the android:onClick attribute) */ public void onButtonClick(View v) { if (mBound) { // Call a method from the LocalService. // However, if this call were something that might hang, then this request should // occur in a separate thread to avoid slowing down the activity performance. int num = mService.getRandomNumber(); Toast.makeText(this, \"number: \" + num, Toast.LENGTH_SHORT).show(); } } /** Defines callbacks for service binding, passed to bindService() */ private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName className, IBinder service) { // We've bound to LocalService, cast the IBinder and get LocalService instance LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; } @Override public void onServiceDisconnected(ComponentName arg0) { mBound = false; } }; } 上例展示了客户端如何使用 ServiceConnection 的实现和 onServiceConnected() 回调绑定到service。下文会介绍更多关于绑定到service的过程。 注：在上例中，onStop() 方法将客户端与service取消绑定。 客户端应在适当时机与service取消绑定，如附加说明中所述。 如需查看更多示例代码，请参见 ApiDemos 中的 LocalService.java 类和 LocalServiceActivities.java 类。 使用 Messenger 如需让service与远程进程通信，则可使用 Messenger 为您的service提供接口。利用此方法，您无需使用 AIDL 便可执行进程间通信 (IPC)。 对你的接口使用Messenger比使用AIDL更简单，因为 Messenger 会将所有service的调用排入队列，而纯粹的 AIDL 接口会同时向Service发送多个请求，Service必须对多线程进行处理。 对于大多数应用，Service不需要进行多线程处理，因此使用 Messenger 可让Service一次处理一个调用。如果您的服务必须执行多线程处理，则应使用 AIDL 来定义接口。 以下是 Messenger 的使用方法摘要： service实现一个 Handler，由其接收来自客户端的每个调用的回调 Service使用该Handler 创建一个 Messenger 对象（该对象是 Handler 的一个引用） Messenger 创建service通过 onBind() 使其返回客户端的 IBinder 客户端使用 IBinder 将 Messenger（引用service的 Handler）实例化，然后使用后者将 Message 对象发送给service service在其 Handler 中（具体地讲，是在 handleMessage() 方法中）接收每个 Message。 这样，客户端并没有调用service的方法，客户端传递的消息（Message 对象）是service在其 Handler 中接收的。 以下是一个使用 Messenger 接口的service示例： kotlin /** Command to the service to display a message */ private const val MSG_SAY_HELLO = 1 class MessengerService : Service() { /** * Target we publish for clients to send messages to IncomingHandler. */ private lateinit var mMessenger: Messenger /** * Handler of incoming messages from clients. */ internal class IncomingHandler( context: Context, private val applicationContext: Context = context.applicationContext ) : Handler() { override fun handleMessage(msg: Message) { when (msg.what) { MSG_SAY_HELLO -> Toast.makeText(applicationContext, \"hello!\", Toast.LENGTH_SHORT).show() else -> super.handleMessage(msg) } } } /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ override fun onBind(intent: Intent): IBinder? { Toast.makeText(applicationContext, \"binding\", Toast.LENGTH_SHORT).show() mMessenger = Messenger(IncomingHandler(this)) return mMessenger.binder } } java public class MessengerService extends Service { /** * Command to the service to display a message */ static final int MSG_SAY_HELLO = 1; /** * Handler of incoming messages from clients. */ static class IncomingHandler extends Handler { private Context applicationContext; IncomingHandler(Context context) { applicationContext = context.getApplicationContext(); } @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_SAY_HELLO: Toast.makeText(applicationContext, \"hello!\", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); } } } /** * Target we publish for clients to send messages to IncomingHandler. */ Messenger mMessenger; /** * When binding to the service, we return an interface to our messenger * for sending messages to the service. */ @Override public IBinder onBind(Intent intent) { Toast.makeText(getApplicationContext(), \"binding\", Toast.LENGTH_SHORT).show(); mMessenger = new Messenger(new IncomingHandler(this)); return mMessenger.getBinder(); } } 请注意，service就是在 Handler 的 handleMessage() 方法中接收传入的 Message，并根据 what 属性决定下一步操作。 客户端只需根据service返回的 IBinder 创建一个 Messenger，然后利用 send() 发送一条消息。例如，以下就是一个绑定到service并向service传递 MSG_SAY_HELLO 消息的 Activity： kotlin class ActivityMessenger : Activity() { /** Messenger for communicating with the service. */ private var mService: Messenger? = null /** Flag indicating whether we have called bind on the service. */ private var bound: Boolean = false /** * Class for interacting with the main interface of the service. */ private val mConnection = object : ServiceConnection { override fun onServiceConnected(className: ComponentName, service: IBinder) { // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = Messenger(service) bound = true } override fun onServiceDisconnected(className: ComponentName) { // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null bound = false } } fun sayHello(v: View) { if (!bound) return // Create and send a message to the service, using a supported 'what' value val msg: Message = Message.obtain(null, MSG_SAY_HELLO, 0, 0) try { mService?.send(msg) } catch (e: RemoteException) { e.printStackTrace() } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.main) } override fun onStart() { super.onStart() // Bind to the service Intent(this, MessengerService::class.java).also { intent -> bindService(intent, mConnection, Context.BIND_AUTO_CREATE) } } override fun onStop() { super.onStop() // Unbind from the service if (bound) { unbindService(mConnection) bound = false } } } java public class ActivityMessenger extends Activity { /** Messenger for communicating with the service. */ Messenger mService = null; /** Flag indicating whether we have called bind on the service. */ boolean bound; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { // This is called when the connection with the service has been // established, giving us the object we can use to // interact with the service. We are communicating with the // service using a Messenger, so here we get a client-side // representation of that from the raw IBinder object. mService = new Messenger(service); bound = true; } public void onServiceDisconnected(ComponentName className) { // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; bound = false; } }; public void sayHello(View v) { if (!bound) return; // Create and send a message to the service, using a supported 'what' value Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0); try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } @Override protected void onStart() { super.onStart(); // Bind to the service bindService(new Intent(this, MessengerService.class), mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onStop() { super.onStop(); // Unbind from the service if (bound) { unbindService(mConnection); bound = false; } } } 请注意，此示例并未说明service如何对客户端作出响应。如果您想让service作出响应，则还需要在客户端中创建一个 Messenger。然后，当客户端收到 onServiceConnected() 回调时，会向service发送一条 Message，并在其 send() 方法的 replyTo 参数中包含客户端的 Messenger。 如需查看如何提供双向消息传递的示例，请参阅 MessengerService.java（service）和 MessengerServiceActivities.java（客户端）示例。 绑定到service 应用组件（客户端）可通过调用 bindService() 绑定到service，Android 系统紧接着会调用service的 onBind() 方法，该方法返回用于与service交互的 IBinder。 绑定是异步的，bindService() 会立即返回（不会将 IBinder 直接返回客户端）。要接收 IBinder，客户端必须创建一个 ServiceConnection 实例，并将其传递给 bindService()，ServiceConnection 包括一个回调方法，系统通过调用它来传递IBinder。 注：只有 Activity、service和content providers可以绑定到service — 您无法从broadcast receiver绑定到service。 因此，要想从您的客户端绑定到service，您必须： 实现ServiceConnection 您的实现必须重写两个回调方法： onServiceConnected() 系统会调用该方法以传递service的　onBind() 方法返回的 IBinder。 onServiceDisconnected() Android 系统会在与service的连接意外中断时（例如当service崩溃或被终止时）调用该方法。当客户端取消绑定时，系统不会调用该方法。 调用 bindService()，传递 ServiceConnection 实现。 注意：如果该方法返回false，说明你的客户端将没有和service建立一个有效的连接。但是，你的客户端仍需调用unbindService()，否则，你的客户端将防止Service在空间时关闭。 当系统调用您的 onServiceConnected() 回调方法时，您可以使用接口定义的方法开始调用service。 要断开与service的连接，请调用unbindService() 如果应用在客户端仍绑定到service时销毁客户端，则销毁会导致客户端取消绑定。 更好的做法是在客户端与service交互完成后立即取消绑定。 这样可以关闭空闲service。如需了解有关绑定和取消绑定的适当时机的详细信息，请参阅附加说明。 例如，以下代码段通过继承 Binder 类将客户端与上面创建的service相连，因此它只需将返回的 IBinder 转换为 LocalService 类并get LocalService 实例： kotlin var mService: LocalService val mConnection = object : ServiceConnection { // Called when the connection with the service is established override fun onServiceConnected(className: ComponentName, service: IBinder) { // Because we have bound to an explicit // service that is running in our own process, we can // cast its IBinder to a concrete class and directly access it. val binder = service as LocalService.LocalBinder mService = binder.getService() mBound = true } // Called when the connection with the service disconnects unexpectedly override fun onServiceDisconnected(className: ComponentName) { Log.e(TAG, \"onServiceDisconnected\") mBound = false } } java LocalService mService; private ServiceConnection mConnection = new ServiceConnection() { // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) { // Because we have bound to an explicit // service that is running in our own process, we can // cast its IBinder to a concrete class and directly access it. LocalBinder binder = (LocalBinder) service; mService = binder.getService(); mBound = true; } // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) { Log.e(TAG, \"onServiceDisconnected\"); mBound = false; } }; 客户端可通过将此 ServiceConnection 传递至 bindService() 进而绑定到service。例如： kotlin Intent(this, LocalService::class.java).also { intent -> bindService(intent, connection, Context.BIND_AUTO_CREATE) } java Intent intent = new Intent(this, LocalService.class); bindService(intent, connection, Context.BIND_AUTO_CREATE); bindService() 的第一个参数是一个 Intent，用于显式命名要绑定的service（但 Intent 可能是隐式的） 注意： 第二个参数是 ServiceConnection 对象 第三个参数是一个指示绑定选项的标志。它通常应该是 BIND_AUTO_CREATE，以便创建尚未激活的service。其他可能的值为 BIND_DEBUG_UNBIND 和 BIND_NOT_FOREGROUND，或 0（表示无）。 附加说明 以下是一些有关绑定到service的重要说明： 您应该始终捕获 DeadObjectException 异常，它们是在连接中断时引发的。这是远程方法引发的唯一异常。 对象是跨进程数量的引用。 您通常应该在客户端生命周期的引入 (bring-up) 和退出 (tear-down) 时刻执行对应的绑定和取消绑定操作。 例如： 如果您只需要在 Activity 可见时与service交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。 如果您希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用service，因此如果service位于其他进程内，那么当您提高该进程的权重时，系统终止该进程的可能性会增加。 注：通常情况下，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，您应该使发生在这些转换期间的c操作数量保持在最少水平。此外，如果您的应用内的多个 Activity 绑定到同一service，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一个 Activity 绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁service并重建service。 （Activity文档中介绍了这种有关 Activity 如何协调其生命周期的 Activity 转换。） 如需查看更多显示如何绑定到service的示例代码，请参阅 ApiDemos 中的 RemoteService.java类。 管理bound service的生命周期 当service与所有客户端之间的绑定全部取消时，Android 系统便会销毁service（除非解绑的同时又使用 onStartCommand() 启动了该service）。因此，如果您的service是纯粹的bound service，则无需对其生命周期进行管理 — Android 系统会根据它是否绑定到客户端代您管理。 不过，如果您实现了 onStartCommand() 回调方法，则您必须显式停止service，因为系统现在已将service视为已启动。在此情况下，service将一直运行，直到其通过 stopSelf() 自行停止，或其他组件调用 stopService() 为止（无论其是否绑定到任何客户端）。 此外，如果您的service已启动并接受绑定，则当系统调用您的 onUnbind() 方法时，如果您想在客户端下一次绑定到service时接收 onRebind() 调用，则可选择在onUnbind（）中返回 true。如果onRebind() 返回空值，客户端仍会在其 onServiceConnected() 回调中接收 IBinder。图 1 说明了这种生命周期的逻辑。 图 1. 已启动且允许绑定的service的生命周期 如需了解有关已启动service生命周期的详细信息，请参阅service文档。 "},"BackGroundTasks/Service/Service——AIDL.html":{"url":"BackGroundTasks/Service/Service——AIDL.html","title":"AIDL","keywords":"","body":"Service——AIDL 原文(英文)地址 AIDL（Android 接口定义语言）与您可能使用过的其他 IDL 类似。 您可以利用它定义客户端与服务端使用进程间通信 (IPC) 进行相互通信时都认可的编程接口。 在 Android 上，一个进程通常无法访问另一个进程的内存，所以，进程需要将其原对象分解成操作系统能够识别的原语，进而将原对象编组成可跨越边界的对象。 编写执行这一编组操作的代码是一项繁琐的工作，因此 Android 会使用 AIDL 来处理。 注：只有当即允许处于其他应用中的客户端用 IPC 方式访问你的Service，并且想要在Service中处理多线程时，才有必要使用 AIDL。 如果您不需要执行跨越不同应用的并发 IPC，就应该通过实现一个 Binder 创建接口；或者，如果您想执行 IPC，但根本不需要处理多线程，则使用 Messenger 类来实现接口。无论如何，在实现 AIDL 之前，请您务必理解绑定Service。 在您开始设计 AIDL 接口之前，要注意 AIDL 接口的调用是直接调用函数(direct function calls)。 您不应该猜想发生调用的线程到底是哪一个，因为调用是来自本地进程中的线程和来自远程进程中的线程是两种不同的情况，特别是： 来自本地进程的调用会在发起调用的相同线程中执行。如果该线程是您的 UI 线程，则该线程继续在 AIDL 接口中执行。 如果该线程是其他线程，则其便是在Service中执行您的代码的线程。 因此，只有在本地线程访问Service时，您才能完全控制哪些线程在Service中执行（但如果真是这种情况，您根本不应该使用 AIDL，而是应该通过实现 Binder 类创建接口）。 来自远程进程的调用将从平台在您自己的进程内维护的线程池中调度。您必须为来自未知线程的传入调用做好准备，同时发生多个调用。换句话说，AIDL接口的实现必须完全是线程安全的。从同一远程对象上的一个线程进行的调用按顺序到达接收器端。 oneway 关键字用于修改远程调用的行为。使用该关键字时，远程调用不会阻塞；它只是发送事务数据并立即返回。接口的实现最终接收此调用时，是以正常远程调用形式将其作为来自 Binder 线程池的常规调用进行接收。 如果 oneway 用于本地调用，则不会有任何影响，调用仍是同步调用。 定义 AIDL 接口 您必须使用 Java 编程语言语法在 .aidl 文件中定义 AIDL 接口，然后将它保存在托管Service的应用以及任何其他绑定到Service的应用的源代码（src/ ）目录内。 您开发每个包含 .aidl 文件的应用时，Android SDK 工具都会生成一个基于该 .aidl 文件的 IBinder 接口，并将其保存在项目的 gen/ 目录中。Service必须视情况实现 IBinder 接口。然后客户端应用便可绑定到该Service，并调用 IBinder 中的方法来执行 IPC。 如需使用 AIDL 创建绑定Service，请执行以下步骤： 创建 .aidl 文件 此文件定义带有方法签名的编程接口。 实现接口 Android SDK 工具基于您的 .aidl 文件，使用 Java 编程语言生成一个接口。此接口具有一个名为 Stub 的内部抽象类，用于扩展 Binder 类并实现 AIDL 接口中的方法。您必须继承 Stub 类并实现方这些法。 向客户端公开该接口 实现 Service 并重写 onBind() 以返回 Stub 类的实现。 注意：在 AIDL 接口首次发布后对其进行的任何更改都必须保持向后兼容性，以避免中断其他应用对您的Service的使用。 也就是说，因为必须将您的 .aidl 文件复制到其他应用，才能让这些应用访问您的Service的接口，因此您必须保留对原始接口的支持。 创建 .aidl 文件 AIDL 的语法很简单，它使您能通过可带参数和返回值的一个或多个方法来声明接口。 参数和返回值可以是任意类型，甚至可以是其他 AIDL 生成的接口。 您必须使用 Java 编程语言构建 .aidl 文件。每个 .aidl 文件都必须定义单个接口，并且只需包含接口声明和方法签名。 默认情况下，AIDL 支持下列数据类型： Java 编程语言中的所有原语类型（如 int、long、char、boolean 等等） String CharSequence List List 中的所有元素都必须是以上列表中支持的数据类型、其他 AIDL 生成的接口或您声明的可打包类型。 可选择将 List 用作“通用”类（例如，List）。另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口。 Map Map 中的所有元素都必须是以上列表中支持的数据类型、其他 AIDL 生成的接口或您声明的可打包类型。 不支持通用 Map（如 Map 形式的 Map）。 另一端实际接收的具体类始终是 HashMap，但生成的方法使用的是 Map 接口。 您必须为以上未列出的每个附加类型加入一个 import 语句，即使这些类型是在与您的接口相同包中定义的。 定义Service接口时，请注意： 方法可带零个或多个参数，返回值或空值。 所有非原语参数都需要指示数据走向的方向标记。可以是in、out或者inout（见以下示例）。 原语默认为 in，不能是其他的方向。 注意：您应该将方向限定为真正需要的方向，因为编组参数的开销极大。 .aidl 文件中包括的所有代码注释都包含在生成的 IBinder 接口中（import 和 package 语句之前的注释除外） 可以在aidl接口中定义String和int类型的常量，比如const int VERSION=1 方法的调用由transact（）进行调度，该代码通常基于接口中的方法索引。因为这会使版本控制变得困难，所以您可以手动将事务代码分配给方法：void method（）= 10;。 使用@nullable注释可为空的参数或返回类型。 以下是一个 .aidl 文件示例： // IRemoteService.aidl package com.example.android; // Declare any non-default types here with import statements /** Example service interface */ interface IRemoteService { /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); } 只需将您的 .aidl 文件保存在项目的 src/ 目录内，当您build应用时，SDK 工具会在项目的gen/ 目录中生成 IBinder 接口文件。生成的文件名与 .aidl 文件名一致，只是使用了.java 扩展名（例如，IRemoteService.aidl 生成的文件名是 IRemoteService.java）。 如果您使用 Android Studio，增量编译（incremental build）几乎会立即生成 Binder 类。 如果您不使用 Android Studio，则 Gradle 工具会在您下一次build应用时生成 Binder 类(您应该在编写完 .aidl 文件后立即用 gradle assembleDebug （或 gradle assembleRelease）编译项目，以便您的代码能够链接到生成的类）。 实现接口 当您开发应用时，Android SDK 工具会生成一个以 .aidl 文件命名的 .java 接口文件。生成的接口包括一个名为 Stub 的子类，这个子类是其父接口（例如，YourInterface.Stub）的抽象实现，用于声明 .aidl 文件中的所有方法。 注：Stub 还定义了几个helper method，其中最引人关注的是 asInterface()，该方法有一个 IBinder参数（通常便是传递给客户端 onServiceConnected() 回调方法的参数）并返回stub interface的实例。 如需了解如何进行这种转换的更多详细信息，请参见调用 IPC 方法一节。 如需实现 .aidl 生成的接口，请继承生成的 Binder 接口（例如，YourInterface.Stub）并实现从 .aidl 文件继承的方法。 以下是一个使用匿名实例实现名为 IRemoteService 的接口（由以上 IRemoteService.aidl示例定义）的示例： kotlin private val binder = object : IRemoteService.Stub() { override fun getPid(): Int = Process.myPid() override fun basicTypes( anInt: Int, aLong: Long, aBoolean: Boolean, aFloat: Float, aDouble: Double, aString: String ) { // Does nothing } } java private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid(){ return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Does nothing } }; 现在，mBinder 是 Stub 类的一个实例（一个 Binder），用于定义Service的 RPC 接口。 在下一步中，将向客户端公开该实例，以便客户端能与Service进行交互。 在实现 AIDL 接口时应注意遵守以下这几个规则： 由于不能保证在主线程上执行传入调用，因此您一开始就需要做好多线程处理准备，并将您的Service正确地编译为线程安全的Service。 默认情况下，RPC 调用是同步调用。如果您明知Service完成请求的时间不止几毫秒，就不应该从 Activity 的主线程调用Service，因为这样做可能会使应用挂起（Android 可能会显示“Application is Not Responding”对话框）， 您通常应该从客户端内的单独线程调用Service。 您引发的任何异常都不会回传给调用方。 向客户端公开该接口 您为Service实现该接口后，就需要向客户端公开该接口，以便客户端进行绑定。 要为您的Service公开该接口，请继承 Service 并实现 onBind()，以返回一个类实例，这个类实现了生成的Stub（见前文所述）。以下是一个向客户端公开 IRemoteService 示例接口的Service示例。 kotlin ```kotlin class RemoteService : Service() { override fun onCreate() { super.onCreate() } override fun onBind(intent: Intent): IBinder { // Return the interface return binder } private val binder = object : IRemoteService.Stub() { override fun getPid(): Int { return Process.myPid() } override fun basicTypes( anInt: Int, aLong: Long, aBoolean: Boolean, aFloat: Float, aDouble: Double, aString: String ) { // Does nothing } } } - java - ```java public class RemoteService extends Service { @Override public void onCreate() { super.onCreate(); } @Override public IBinder onBind(Intent intent) { // Return the interface return binder; } private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid(){ return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Does nothing } }; } 现在，当客户端（如 Activity）调用 bindService() 以连接此Service时，客户端的 onServiceConnected() 回调会接收Service的 onBind() 方法返回的 mBinder 实例。 客户端还必须具有对 interface 类的访问权限，因此如果客户端和Service在不同的应用内，则客户端的应用 src/ 目录内必须包含 .aidl 文件（它生成 android.os.Binder 接口 — 为客户端提供对 AIDL 方法的访问权限）的副本。 当客户端在 onServiceConnected() 回调中收到 IBinder 时，它必须调用YourServiceInterface.Stub.asInterface(service) 以将返回的参数转换成YourServiceInterface 类型。例如： kotlin var iRemoteService: IRemoteService? = null val mConnection = object : ServiceConnection { // Called when the connection with the service is established override fun onServiceConnected(className: ComponentName, service: IBinder) { // Following the example above for an AIDL interface, // this gets an instance of the IRemoteInterface, which we can use to call on the service iRemoteService = IRemoteService.Stub.asInterface(service) } // Called when the connection with the service disconnects unexpectedly override fun onServiceDisconnected(className: ComponentName) { Log.e(TAG, \"Service has unexpectedly disconnected\") iRemoteService = null } } java IRemoteService iRemoteService; private ServiceConnection mConnection = new ServiceConnection() { // Called when the connection with the service is established public void onServiceConnected(ComponentName className, IBinder service) { // Following the example above for an AIDL interface, // this gets an instance of the IRemoteInterface, which we can use to call on the service iRemoteService = IRemoteService.Stub.asInterface(service); } // Called when the connection with the service disconnects unexpectedly public void onServiceDisconnected(ComponentName className) { Log.e(TAG, \"Service has unexpectedly disconnected\"); iRemoteService = null; } }; 如需查看更多示例代码，请参见 ApiDemos 中的 RemoteService.java 类。 通过 IPC 传递对象 通过 IPC 接口把某个类从一个进程发送到另一个进程是可以实现的。 不过，您必须确保该类的代码对 IPC 通道的另一端可用，并且该类必须支持 Parcelable 接口。支持 Parcelable 接口很重要，因为 Android 系统可通过它将对象分解成可编组到各进程的原语。 如需创建支持 Parcelable 协议的类，您必须执行以下操作： 让您的类实现 Parcelable 接口。 实现 writeToParcel，它会获取对象的当前状态并将其写入 Parcel。 为您的类添加一个名为 CREATOR 的静态字段，这个字段是一个实现Parcelable.Creator 接口的对象。 最后，创建一个声明可打包类的.aidl文件（按照下文Rect.aidl文件所示步骤）。 如果您使用的是自定义编译进程，切勿在您的编译中添加 .aidl 文件。 此 .aidl 文件与 C 语言中的头文件类似，并未编译。 AIDL 在它生成的代码中使用这些方法和字段将您的对象编组和取消编组。 例如，以下这个 Rect.aidl 文件可创建一个可打包的 Rect 类： package android.graphics; // Declare Rect so AIDL can find it and knows that it implements // the parcelable protocol. parcelable Rect; 以下示例展示了 Rect 类如何实现 Parcelable 协议。 kotlin import android.os.Parcel import android.os.Parcelable class Rect() : Parcelable { var left: Int = 0 var top: Int = 0 var right: Int = 0 var bottom: Int = 0 companion object CREATOR : Parcelable.Creator { override fun createFromParcel(parcel: Parcel): Rect { return Rect(parcel) } override fun newArray(size: Int): Array { return Array(size) { Rect() } } } private constructor(inParcel: Parcel) : this() { readFromParcel(inParcel) } override fun writeToParcel(outParcel: Parcel, flags: Int) { outParcel.writeInt(left) outParcel.writeInt(top) outParcel.writeInt(right) outParcel.writeInt(bottom) } private fun readFromParcel(inParcel: Parcel) { left = inParcel.readInt() top = inParcel.readInt() right = inParcel.readInt() bottom = inParcel.readInt() } override fun describeContents(): Int { return 0 } } java import android.os.Parcel; import android.os.Parcelable; public final class Rect implements Parcelable { public int left; public int top; public int right; public int bottom; public static final Parcelable.Creator CREATOR = new Parcelable.Creator() { public Rect createFromParcel(Parcel in) { return new Rect(in); } public Rect[] newArray(int size) { return new Rect[size]; } }; public Rect() { } private Rect(Parcel in) { readFromParcel(in); } public void writeToParcel(Parcel out, int flags) { out.writeInt(left); out.writeInt(top); out.writeInt(right); out.writeInt(bottom); } public void readFromParcel(Parcel in) { left = in.readInt(); top = in.readInt(); right = in.readInt(); bottom = in.readInt(); } public int describeContents() { return 0; } } Rect 类中的编组相当简单。看一看 Parcel 上的其他方法，了解您可以向 Parcel 写入哪些其他类型的值。 警告：别忘记从其他进程接收数据的安全影响。 在本例中，Rect 从 Parcel 读取四个数字，但要由您来确保无论调用方目的为何这些数字都在相应的可接受值范围内。 如需了解有关如何防止应用受到恶意软件侵害、保证应用安全的更多信息，请参见安全与权限。 调用 IPC 方法 调用类必须执行以下步骤，才能调用使用 AIDL 定义的远程接口： 在项目 src/ 目录中加入 .aidl 文件。 声明一个 IBinder 接口实例（基于 AIDL 生成）。 实现 ServiceConnection。 调用 Context.bindService()，以传入您的 ServiceConnection 实现。 在您的 onServiceConnected() 实现中，您将收到一个 IBinder 实例（名为 service）。调用 *YourInterfaceName*.Stub.asInterface((IBinder)*service*)，以将返回的参数转换为 YourInterface 类型。 调用您在接口上定义的方法。您应该始终捕获 DeadObjectException 异常，它们是在连接中断时引发的；这将是远程方法引发的唯一异常。 如需断开连接，请使用您的接口实例调用 Context.unbindService()。 有关调用 IPC Service的几点说明： 对象是跨进程计数的引用。 您可以将匿名对象作为方法参数发送。 如需了解有关绑定到Service的详细信息，请阅读绑定Service文档。 以下这些示例代码摘自 ApiDemos 项目的远程Service示例代码，展示了如何调用 AIDL 创建的Service。 kotlin private const val BUMP_MSG = 1 class Binding : Activity() { /** The primary interface we will be calling on the service. */ private var mService: IRemoteService? = null /** Another interface we use on the service. */ internal var secondaryService: ISecondary? = null private lateinit var killButton: Button private lateinit var callbackText: TextView private lateinit var handler: InternalHandler private var isBound: Boolean = false /** * Class for interacting with the main interface of the service. */ private val mConnection = object : ServiceConnection { override fun onServiceConnected(className: ComponentName, service: IBinder) { // This is called when the connection with the service has been // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service) killButton.isEnabled = true callbackText.text = \"Attached.\" // We want to monitor the service for as long as we are // connected to it. try { mService?.registerCallback(mCallback) } catch (e: RemoteException) { // In this case the service has crashed before we could even // do anything with it; we can count on soon being // disconnected (and then reconnected if it can be restarted) // so there is no need to do anything here. } // As part of the sample, tell the user what happened. Toast.makeText( this@Binding, R.string.remote_service_connected, Toast.LENGTH_SHORT ).show() } override fun onServiceDisconnected(className: ComponentName) { // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null killButton.isEnabled = false callbackText.text = \"Disconnected.\" // As part of the sample, tell the user what happened. Toast.makeText( this@Binding, R.string.remote_service_disconnected, Toast.LENGTH_SHORT ).show() } } /** * Class for interacting with the secondary interface of the service. */ private val secondaryConnection = object : ServiceConnection { override fun onServiceConnected(className: ComponentName, service: IBinder) { // Connecting to a secondary interface is the same as any // other interface. secondaryService = ISecondary.Stub.asInterface(service) killButton.isEnabled = true } override fun onServiceDisconnected(className: ComponentName) { secondaryService = null killButton.isEnabled = false } } private val mBindListener = View.OnClickListener { // Establish a couple connections with the service, binding // by interface names. This allows other applications to be // installed that replace the remote service by implementing // the same interface. val intent = Intent(this@Binding, RemoteService::class.java) intent.action = IRemoteService::class.java.name bindService(intent, mConnection, Context.BIND_AUTO_CREATE) intent.action = ISecondary::class.java.name bindService(intent, secondaryConnection, Context.BIND_AUTO_CREATE) isBound = true callbackText.text = \"Binding.\" } private val unbindListener = View.OnClickListener { if (isBound) { // If we have received the service, and hence registered with // it, then now is the time to unregister. try { mService?.unregisterCallback(mCallback) } catch (e: RemoteException) { // There is nothing special we need to do if the service // has crashed. } // Detach our existing connection. unbindService(mConnection) unbindService(secondaryConnection) killButton.isEnabled = false isBound = false callbackText.text = \"Unbinding.\" } } private val killListener = View.OnClickListener { // To kill the process hosting our service, we need to know its // PID. Conveniently our service has a call that will return // to us that information. try { secondaryService?.pid?.also { pid -> // Note that, though this API allows us to request to // kill any process based on its PID, the kernel will // still impose standard restrictions on which PIDs you // are actually able to kill. Typically this means only // the process running your application and any additional // processes created by that app as shown here; packages // sharing a common UID will also be able to kill each // other's processes. Process.killProcess(pid) callbackText.text = \"Killed service process.\" } } catch (ex: RemoteException) { // Recover gracefully from the process hosting the // server dying. // Just for purposes of the sample, put up a notification. Toast.makeText(this@Binding, R.string.remote_call_failed, Toast.LENGTH_SHORT).show() } } // ---------------------------------------------------------------------- // Code showing how to deal with callbacks. // ---------------------------------------------------------------------- /** * This implementation is used to receive callbacks from the remote * service. */ private val mCallback = object : IRemoteServiceCallback.Stub() { /** * This is called by the remote service regularly to tell us about * new values. Note that IPC calls are dispatched through a thread * pool running in each process, so the code executing here will * NOT be running in our main thread like most other things -- so, * to update the UI, we need to use a Handler to hop over there. */ override fun valueChanged(value: Int) { handler.sendMessage(handler.obtainMessage(BUMP_MSG, value, 0)) } } /** * Standard initialization of this activity. Set up the UI, then wait * for the user to poke it before doing anything. */ override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.remote_service_binding) // Watch for button clicks. var button: Button = findViewById(R.id.bind) button.setOnClickListener(mBindListener) button = findViewById(R.id.unbind) button.setOnClickListener(unbindListener) killButton = findViewById(R.id.kill) killButton.setOnClickListener(killListener) killButton.isEnabled = false callbackText = findViewById(R.id.callback) callbackText.text = \"Not attached.\" handler = InternalHandler(callbackText) } private class InternalHandler( textView: TextView, private val weakTextView: WeakReference = WeakReference(textView) ) : Handler() { override fun handleMessage(msg: Message) { when (msg.what) { BUMP_MSG -> weakTextView.get()?.text = \"Received from service: ${msg.arg1}\" else -> super.handleMessage(msg) } } } } java public static class Binding extends Activity { /** The primary interface we will be calling on the service. */ IRemoteService mService = null; /** Another interface we use on the service. */ ISecondary secondaryService = null; Button killButton; TextView callbackText; private InternalHandler handler; private boolean isBound; /** * Standard initialization of this activity. Set up the UI, then wait * for the user to poke it before doing anything. */ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.remote_service_binding); // Watch for button clicks. Button button = (Button)findViewById(R.id.bind); button.setOnClickListener(mBindListener); button = (Button)findViewById(R.id.unbind); button.setOnClickListener(unbindListener); killButton = (Button)findViewById(R.id.kill); killButton.setOnClickListener(killListener); killButton.setEnabled(false); callbackText = (TextView)findViewById(R.id.callback); callbackText.setText(\"Not attached.\"); handler = new InternalHandler(callbackText); } /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { // This is called when the connection with the service has been // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service); killButton.setEnabled(true); callbackText.setText(\"Attached.\"); // We want to monitor the service for as long as we are // connected to it. try { mService.registerCallback(mCallback); } catch (RemoteException e) { // In this case the service has crashed before we could even // do anything with it; we can count on soon being // disconnected (and then reconnected if it can be restarted) // so there is no need to do anything here. } // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_connected, Toast.LENGTH_SHORT).show(); } public void onServiceDisconnected(ComponentName className) { // This is called when the connection with the service has been // unexpectedly disconnected -- that is, its process crashed. mService = null; killButton.setEnabled(false); callbackText.setText(\"Disconnected.\"); // As part of the sample, tell the user what happened. Toast.makeText(Binding.this, R.string.remote_service_disconnected, Toast.LENGTH_SHORT).show(); } }; /** * Class for interacting with the secondary interface of the service. */ private ServiceConnection secondaryConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { // Connecting to a secondary interface is the same as any // other interface. secondaryService = ISecondary.Stub.asInterface(service); killButton.setEnabled(true); } public void onServiceDisconnected(ComponentName className) { secondaryService = null; killButton.setEnabled(false); } }; private OnClickListener mBindListener = new OnClickListener() { public void onClick(View v) { // Establish a couple connections with the service, binding // by interface names. This allows other applications to be // installed that replace the remote service by implementing // the same interface. Intent intent = new Intent(Binding.this, RemoteService.class); intent.setAction(IRemoteService.class.getName()); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); intent.setAction(ISecondary.class.getName()); bindService(intent, secondaryConnection, Context.BIND_AUTO_CREATE); isBound = true; callbackText.setText(\"Binding.\"); } }; private OnClickListener unbindListener = new OnClickListener() { public void onClick(View v) { if (isBound) { // If we have received the service, and hence registered with // it, then now is the time to unregister. if (mService != null) { try { mService.unregisterCallback(mCallback); } catch (RemoteException e) { // There is nothing special we need to do if the service // has crashed. } } // Detach our existing connection. unbindService(mConnection); unbindService(secondaryConnection); killButton.setEnabled(false); isBound = false; callbackText.setText(\"Unbinding.\"); } } }; private OnClickListener killListener = new OnClickListener() { public void onClick(View v) { // To kill the process hosting our service, we need to know its // PID. Conveniently our service has a call that will return // to us that information. if (secondaryService != null) { try { int pid = secondaryService.getPid(); // Note that, though this API allows us to request to // kill any process based on its PID, the kernel will // still impose standard restrictions on which PIDs you // are actually able to kill. Typically this means only // the process running your application and any additional // processes created by that app as shown here; packages // sharing a common UID will also be able to kill each // other's processes. Process.killProcess(pid); callbackText.setText(\"Killed service process.\"); } catch (RemoteException ex) { // Recover gracefully from the process hosting the // server dying. // Just for purposes of the sample, put up a notification. Toast.makeText(Binding.this, R.string.remote_call_failed, Toast.LENGTH_SHORT).show(); } } } }; // ---------------------------------------------------------------------- // Code showing how to deal with callbacks. // ---------------------------------------------------------------------- /** * This implementation is used to receive callbacks from the remote * service. */ private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() { /** * This is called by the remote service regularly to tell us about * new values. Note that IPC calls are dispatched through a thread * pool running in each process, so the code executing here will * NOT be running in our main thread like most other things -- so, * to update the UI, we need to use a Handler to hop over there. */ public void valueChanged(int value) { handler.sendMessage(handler.obtainMessage(BUMP_MSG, value, 0)); } }; private static final int BUMP_MSG = 1; private static class InternalHandler extends Handler { private final WeakReference weakTextView; InternalHandler(TextView textView) { weakTextView = new WeakReference<>(textView); } @Override public void handleMessage(Message msg) { switch (msg.what) { case BUMP_MSG: TextView textView = weakTextView.get(); if (textView != null) { textView.setText(\"Received from service: \" + msg.arg1); } break; default: super.handleMessage(msg); } } } } "},"BackGroundTasks/BroadCast.html":{"url":"BackGroundTasks/BroadCast.html","title":"Broadcast","keywords":"","body":"BroadCast(广播) 原文(英文)地址 [TOC] 应用程序可以注册去接收特定的broadcast，当一个broadcast被发送，系统自动将该broadcast路由到已订阅接收该特定类型broadcast的应用程序。 一般来说，broadcast可以用作跨应用程序和正常用户流之外的消息传递系统。但是，您必须小心，不要滥用在后台响应broadcast和执行任务的机会，这可能导致系统运行变慢，如以下视频所述。 视频地址 关于系统broadcast 系统会在一些系统事件发生的时候发生broadcast，比如当系统在飞行模式和正常模式之间切换的时候。系统广播会发送给所有订阅了要接收对应事件的应用程序。 broadcast Message本身包装在一个Intent对象中，该对象的action属性标识发生的事件（例如android.intent.action.AIRPLAN_MODE）。Intent还可能包括捆绑到其extra字段中的附加信息。例如，飞行模式Intent包括一个布尔类型的extra值，用于指示飞行模式是否打开。 关于如何读取Intent以及如何从Intent中获取action字段值，请参阅Intent和Intent Filter. 关于完整的系统broadcast actions信息，请参阅Android SDK中的BROADCAST_ACTION.TXT文件。每一个broadcast action都有一个常量值与之对应，比如ACTION_AIRPLANE_MODE_CHANGED对应android.intent.action.AIRPLANE_MODE， BROADCAST_ACTION.TXT文档中有每一个broadcast action对应的常量值的信息。 系统broadcast的更改 随着Android平台的发展，它会定期改变系统broadcast的行为方式。如果您的应用程序针对Android 7.0（API级别24）或更高版本，或者安装在运行Android 7.0或更高版本的设备上，请记住以下更改。 Android 9 从Android 9（API级别28）开始，NETWORK_STATE_CHANGED_ACTION不再接收用户的位置或用户个人数据的信息。 此外，如果您的应用程序是安装Android 9或者更高版本的设备的上，从WI-FI发送的broadcast不再含有SSIDs、BSSIDs、连接信息、扫描结果等信息。想得到这些信息，应该调用getConnectionInfo())方法。 Android 8.0 从Android8.0（API 26）开始，系统对在manifest中声明的接受者添加了额外限制。 如果你的应用程序的目标设备版本为Android8.0或更高，您无法使用manifest为大多数隐式broadcast（broadcast不专门针对您的应用）声明receiver。当用户主动使用您的应用时，您仍然可以使用context注册的接收器（context-registered receiver）。 Android 7.0 Android 7.0（API级别24）及更高版本不发送以下系统广播： ACTION_NEW_PICTURE ACTION_NEW_VIDEO 此外，针对Android 7.0及更高版本的应用必须使用registerReceiver(BroadcastReceiver, IntentFilter))注册CONNECTIVITY_ACTION广播。在manifest中声明receiver不起作用。 接收broadcast 应用程序可以通过两种方式接收广播：在manifest中声明broadcast receiver（manifest-declared receivers）和使用context注册receiver（ context-registered receivers）。 在manifest中声明receiver 如果你在你的manifest中声明broadcast receiver，系统会在broadcast被发送后启动你的应用程序(如果发送broadcast的时候你的应用处于未启动状态)。 注意：如果您的应用程序的target是API级别26或更高，则您无法使用manifest来声明隐式broadcast（不特定针对你app的broadcast）的receiver，除了一些免于该限制（exempted from that restriction）的隐式broadcast，在大多数情况下，您可以使用scheduled jobs。 为了在manifest中声明broadcast receiver，请按照以下步骤实现： 1：在manifest中声明receiver>属性： intent-filter指定receiver订阅的broadcast action。 2：继承BroadcastReceiver并实现onReceive（Context，Intent）方法。以下示例中的BroadCastReceiver记录并显示broadcast的内容： kotlin private const val TAG = \"MyBroadcastReceiver\" class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { StringBuilder().apply { append(\"Action: ${intent.action}\\n\") append(\"URI: ${intent.toUri(Intent.URI_INTENT_SCHEME)}\\n\") toString().also { log -> Log.d(TAG, log) Toast.makeText(context, log, Toast.LENGTH_LONG).show() } } } } java public class MyBroadcastReceiver extends BroadcastReceiver { private static final String TAG = \"MyBroadcastReceiver\"; @Override public void onReceive(Context context, Intent intent) { StringBuilder sb = new StringBuilder(); sb.append(\"Action: \" + intent.getAction() + \"\\n\"); sb.append(\"URI: \" + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + \"\\n\"); String log = sb.toString(); Log.d(TAG, log); Toast.makeText(context, log, Toast.LENGTH_LONG).show(); } } 系统的package manager在安装应用程序时会注册register。然后，register成为应用程序的单独入口点（separate entry point ），这意味着如果应用程序当前未运行，系统可以启动应用程序并发送broadcast。 系统创建一个新的BroadcastReceiver组件对象来处理它接收的每个广播。此对象仅在调用onReceive（Context，Intent）期间有效。一旦您的代码从此方法返回，系统会认为该组件不再处于活动状态。 Context注册register 通过context注册receiver，大致应该按照以下步骤： 1：创建一个BroadcastReceiver实例 kotlin val br: BroadcastReceiver = MyBroadcastReceiver() java BroadcastReceiver br = new MyBroadcastReceiver(); 2：创建一个IntentFilter并通过调用registerReceiver(BroadcastReceiver, IntentFilter))注册receiver： kotlin val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply { addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED) } registerReceiver(br, filter) java IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED); this.registerReceiver(br, filter); 注意：如果要注册一个local broadcast，请调用LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter))。 只要注册的context有效，context注册的receiver就会接收broadcast。例如，如果您在Activity context中注册，则只要Activity未被销毁，您就会收到broadcast。如果您在application context中注册，则只要应用程序正在运行，您就会收到broadcast。 3：要停止接收广播，请调用unregisterReceiver(android.content.BroadcastReceiver))。当您不再需要Regis或context不再有效时，请务必取消注册的register。 请注意注册和取消注册register的位置，例如，如果使用Activity context在onCreate（Bundle）中注册register，则应在onDestroy（）中取消注册，以防止register泄漏到Activity context之外。如果在onResume（）中注册register，则应在onPause（）中注销它以防止多次注册（如果您不希望在Paused时接收广播，这可以减少不必要的系统开销）。不要在onSaveInstanceState（Bundle）中取消注册，因为如果用户在历史堆栈（history stack）中向后移动（moves back），则不会调用此方法。 对进程生命状态的影响 BroadcastReceiver的状态（无论是否正在运行）会影响其宿主进程的状态，从而影响该对应进程被系统杀死的可能性。例如，当进程执行receiver（即运行onReceive（）方法中的代码）时，它被认为是前台进程，除极端内存压力外，系统会维持其运行。 但是，一旦您的代码从onReceive（）返回，BroadcastReceiver就不再处于活动状态。Register的宿主进程会与系统中其他正在运行的应用进程一样重要。如果该进程仅承载manifest中声明的register（常见的比如用户从未或最近未与之交互过的应用程序），则在从onReceive（）返回时，系统将其进程视为低优先级进程并且可能杀死它以使资源可用于其他更重要的进程。 因此，您不应该在broadcast receiver中启动长时间运行在后台的线程。在onReceive（）返回结果之后，系统可以随时终止进程以回收内存，这样做会终止在该进程中运行的线程。要避免这种情况，您应该调用goAsync（）（如果您希望broadcast的后台线程拥有更多处理任务的时间）或使用JobScheduler在receiver中调度JobService，这样系统知道该进程正在继续执行有效工作。有关更多信息，请参阅进程和应用程序的生命周期。 以下代码段展示了一个BroadcastReceiver，它使用goAsync（）标记在onReceive（）完成后需要更多时间才能完成（如果onReceive（）中的任务耗时足够多，导致UI线程错过一个帧（> 16ms），使其更适合放在后台线程执行，这将特别有用）。 kotlin private const val TAG = \"MyBroadcastReceiver\" class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { val pendingResult: PendingResult = goAsync() val asyncTask = Task(pendingResult, intent) asyncTask.execute() } private class Task( private val pendingResult: PendingResult, private val intent: Intent ) : AsyncTask() { override fun doInBackground(vararg params: String?): String { val sb = StringBuilder() sb.append(\"Action: ${intent.action}\\n\") sb.append(\"URI: ${intent.toUri(Intent.URI_INTENT_SCHEME)}\\n\") return toString().also { log -> Log.d(TAG, log) } } override fun onPostExecute(result: String?) { super.onPostExecute(result) // Must call finish() so the BroadcastReceiver can be recycled. pendingResult.finish() } } } java public class MyBroadcastReceiver extends BroadcastReceiver { private static final String TAG = \"MyBroadcastReceiver\"; @Override public void onReceive(Context context, Intent intent) { final PendingResult pendingResult = goAsync(); Task asyncTask = new Task(pendingResult, intent); asyncTask.execute(); } private static class Task extends AsyncTask { private final PendingResult pendingResult; private final Intent intent; private Task(PendingResult pendingResult, Intent intent) { this.pendingResult = pendingResult; this.intent = intent; } @Override protected String doInBackground(String... strings) { StringBuilder sb = new StringBuilder(); sb.append(\"Action: \" + intent.getAction() + \"\\n\"); sb.append(\"URI: \" + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + \"\\n\"); String log = sb.toString(); Log.d(TAG, log); return log; } @Override protected void onPostExecute(String s) { super.onPostExecute(s); // Must call finish() so the BroadcastReceiver can be recycled. pendingResult.finish(); } } } 发送Broadcast Android为我们提供了3种发送broadcast的方法： sendOrderedBroadcast(Intent, String))方法一次向一个receiver发送广播。当每个receiver依次执行时，它可以将结果传播到下一个receiver，或者它可以中止广播，这样该广播就不会传递给其他receiver。可以使用intent-filter的android：priority属性来控制receiver的接收顺序，具有相同优先级的receiver将以任意顺序执行。 sendBroadcast(Intent))方法以未定义的顺序向所有receiver发送广播。这称为正常广播。通常情况下这种情况更有效，但意味着receiver无法从其他receiver中读取结果，receiver传播从广播接收的数据或者终止它。 LocalBroadcastManager.sendBroadcast)方法将广播发送到与发送方位于同一应用程序中的receiver。如果您不需要跨应用程序发送广播，请使用本地广播。这种方式的实现效率更高（无需进程间通信），您无需担心由于其他应用程序接收或发送您的广播引发的任何安全问题。 以下代码演示了如何通过创建一个Intent以及使用sendBroadcast(Intent))发送一个广播： kotlin Intent().also { intent -> intent.setAction(\"com.example.broadcast.MY_NOTIFICATION\") intent.putExtra(\"data\", \"Notice me senpai!\") sendBroadcast(intent) } java Intent intent = new Intent(); intent.setAction(\"com.example.broadcast.MY_NOTIFICATION\"); intent.putExtra(\"data\",\"Notice me senpai!\"); sendBroadcast(intent); broadcast发送的消息包含在Intent对象中，intent的action属性必须提供该app的java包名并唯一标识broadcast event。您可以使用putExtra（String，Bundle）将其他信息附加到intent。您还可以通过调用intent的setPackage(String))将广播限制为同一组织中的一组应用程序。 注意：尽管Intent可以被同时用于发送广播和启动Activity，但是这二者的action属性是完全无关的。广播接收器无法查看或捕获用于启动Activity的Intent。同样，您无法使用broadcast 的Intent找到或启动Activity。 使用权限（permissions）限制broadcast permissions允许您将广播限制在具有特定权限的应用程序集中。您可以对广播的发送者或接收者施加限制。 发送时施加权限 当你调用sendBroadcast(Intent, String))或者sendOrderedBroadcast(Intent, String, BroadcastReceiver, Handler, int, String, Bundle))时，你可以指定权限参数。只有那些已经在其manifest中指定权限tag的receiver（并且如果当前权限是危险权限，则需要手动授予权限）可以接收广播。例如，以下代码发送广播： kotlin sendBroadcast(Intent(\"com.example.NOTIFY\"), Manifest.permission.SEND_SMS) java sendBroadcast(new Intent(\"com.example.NOTIFY\"), Manifest.permission.SEND_SMS); 如果要接收该广播，则需要下面的权限： 您可以指定现有系统权限（如SEND_SMS）或使用元素自定义权限。有关一般权限和安全性的信息，请参阅System Permissions。 注意：安装应用程序时会注册自定义权限，所以必须在使用自定义的权限之前安装定义自定义权限的应用程序。 接收时施加权限 如果在注册广播接收器时指定了权限参数（使用registerReceiver(BroadcastReceiver, IntentFilter, String, Handler))或manifest中的标记），则只有在manifest中使用请求权限（如果是危险权限，随后需要被手动授权）的broadcast才能向该receiver发送广播。 例如，假设您的接收程序的manifest中的receiver具有以下声明： 或者接收程序中含有使用以下代码进行context注册的receiver： kotlin var filter = IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED) registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null ) java IntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED); registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null ); 这样，如果想向上面的receiver发送broadcast，则必须向下面这样请求权限： 安全注意事项及最佳做法 以下是发送和接收broadcast的一些安全注意事项和最佳做法： 如果您不需要向应用程序外部的组件发送广播，则使用支持库中提供的LocalBroadcastManager发送和接收本地广播。 LocalBroadcastManager效率更高（无需进程间通信），而且您可以不用考虑与其他应用程序接收或发送您的广播相关的任何安全问题。本地广播可以在您的应用中用作通用发布/订阅事件总线，而无需系统广播的任何开销。 如果很多应用在其manifest文件中注册接收相同的广播，则可能导致系统启动大量应用，从而对设备性能和用户体验产生重大影响。为避免这种情况，请优先使用context注册而不是manifest声明的方式，Android系统的有些广播会强制使用context注册的接收器。例如，CONNECTIVITY_ACTION广播仅传递给上下文注册的接收器。 不要使用隐式Intent广播敏感信息。因为任何注册接收广播的应用都可以读取该信息。有三种方法可以控制谁可以接收您的广播： 您可以在发送广播时指定权限。 在Android 4.0及更高版本中，您可以在发送广播时指定包含setPackage（String）的包。系统将广播限制为与包匹配的应用程序集。 您可以使用LocalBroadcastManager发送本地广播。 当您注册接收器时，任何应用都可以向您的应用接收器发送潜在的恶意广播。有三种方法可以限制应用收到的广播： 您可以在注册广播接收器时指定权限。 对于manifest中声明的接收器，您可以在manifest中将android：exported属性设置为“false”，即receiver不接收来自应用程序之外的来源的广播。 您可以将自己限制为仅接收使用LocalBroadcastManager发送的本地广播。 广播的action的命名空间是全局的。确保action名称和其他字符串都写在您拥有的命名空间中，否则您可能会无意中与其他应用程序发生冲突。 因为接收者的onReceive（Context，Intent）方法在主线程上运行，所以它应该执行并快速返回。如果您需要执行长时间运行的工作，请谨慎启动线程或启动后台Service，因为系统可以在onReceive（）返回后终止整个进程。有关更多信息，请参阅对进程生命状态的影响。如果要执行长时间运行的工作，我们建议： 在接收者的onReceive（）方法中调用goAsync（）并将BroadcastReceiver.PendingResult传递给后台线程。这使得从onReceive（）返回后broadcast依然可以保持活动状态。但是，即使采用这种方法，系统也希望您能够非常快速地完成广播中的任务（10秒以内）。它允许您将工作移动到另一个线程，以避免主线程发生阻塞。 使用JobScheduler调度任务。有关更多信息，请参阅Intelligent Job Scheduling。 不要在广播接收器中启动Activity，因为用户体验很不稳定，特别是如果有多个receiver的时候，请考虑使用notification。 "},"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（1）概述.html":{"url":"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（1）概述.html","title":"概述","keywords":"","body":"将操作发送到多个线程——概述 原文(英文)地址 当您将单个线程中长时间运行的数据密集型的重量级操作分解为在多个线程上运行的较轻量级的操作时，速度和效率通常会提高。在具有多个处理器（核心）的CPU的设备上，系统可以并行运行线程，而不是让每个子任务等待运行的机会。例如，当您在多个单独的线程上独立执行每个解码任务时，解码多个图像文件的速度会大大加快。 本指南介绍如何使用线程池对象在Android应用程序中设置和使用多个线程。您还将学习如何定义在线程上运行的代码以及如何让UI线程和在这些线程之一进行通信。 目录 指定要在线程中运行的代码 通过定义实现Runnable接口的类，了解如何编写代码以在单独的线程上运行。 为多个线程创建管理器 了解如何创建管理Thread对象池和Runnable对象队列的对象。该对象称为ThreadPoolExecutor。 在线程池中的线程上运行代码 了解如何在线程池中的线程上运行Runnable任务。 与UI线程通信 了解如何在线程池中的线程与UI线程之间进行通信。 更多资源 要了解更多Android多线程的内容，请参阅： Loaders Services Process and threads overview 实例app ThreadSample "},"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（2）指定线程中运行的代码.html":{"url":"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（2）指定线程中运行的代码.html","title":"指定线程中运行的代码","keywords":"","body":"将操作发送到多个线程——指定线程中运行的代码 原文(英文)地址 本文介绍如何实现Runnable类，该类在单独的线程上运行其Runnable.run())方法中的代码。您还可以将Runnable传递给另一个对象，然后将该对象附加到线程中并运行它。执行特定操作的一个或多个Runnable对象有时称为任务。 Thread和Runnable都是基类，它们本身只有有限的功能。但是，它们是很多强大的Android类的基类，例如HandlerThread，AsyncTask和IntentService。 Thread和Runnable也是ThreadPoolExecutor类的基类。该类自动管理线程和任务队列，甚至可以并行运行多个线程。 定义实现Runnable的类 定义一个类并实现Runnable接口很简单，比如： kotlin class PhotoDecodeRunnable : Runnable { ... override fun run() { /* * Code you want to run on the thread goes here */ ... } ... } java public class PhotoDecodeRunnable implements Runnable { ... @Override public void run() { /* * Code you want to run on the thread goes here */ ... } ... } 实现run()方法 在实现了Runnable接口的类中，Runnable.run（）方法包含要在子线程执行的代码。通常，Runnable中允许执行任何内容。但请记住，Runnable不会在UI线程上运行，因此它无法直接更新UI（如更新View）。要与UI线程通信，您必须使用与UI线程通信中描述的技术。 在run（）方法的开头，通过调用Process.setThreadPriority（）并传入使用THREAD_PRIORITY_BACKGROUND，设置线程可以使用后台优先级。这种方法减少了Runnable对象的线程和UI线程之间的资源竞争。 您还应该通过调用Thread.currentThread（）在Runnable中存储对Runnable对象对应的Thread的引用。 以下代码段显示了如何设置run（）方法： kotlin class PhotoDecodeRunnable : Runnable { ... /* * Defines the code to run for this task. */ override fun run() { // Moves the current Thread into the background android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND) ... /* * Stores the current Thread in the PhotoTask instance, * so that the instance * can interrupt the Thread. */ photoTask.setImageDecodeThread(Thread.currentThread()) ... } ... } java class PhotoDecodeRunnable implements Runnable { ... /* * Defines the code to run for this task. */ @Override public void run() { // Moves the current Thread into the background android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND); ... /* * Stores the current Thread in the PhotoTask instance, * so that the instance * can interrupt the Thread. */ photoTask.setImageDecodeThread(Thread.currentThread()); ... } ... } 更多内容 关于Android中多线程的更多内容，请参阅进程和线程——概述 示例app ThreadSample "},"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（4）在线程池中的线程中运行代码.html":{"url":"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（4）在线程池中的线程中运行代码.html","title":"在线程池中运行代码","keywords":"","body":"将操作发送到多个线程——在线程池中的线程中运行代码 原文(英文)地址 上一篇文章 为多线程创建管理者(manager).md)，介绍了如何定义管理线程池的类。本文主要介绍如何在线程池上运行任务。为了在线程池上运行任务，您应该将任务添加到线程池的工作队列中。当有线程可用时，ThreadPoolExecutor会从队列中获取一个任务并在线程上运行它。 本文还向您展示了如何停止正在运行的任务。如果任务启动，但随后发现其工作不是必需的，您可以取消运行任务的线程，而不是浪费处理器时间。例如，如果从网络下载图像并使用缓存，则可能需要在检测到缓存中已存在图像时停止任务。 在线程池中的线程上运行任务 要在特定线程池中的线程上启动任务，请将Runnable传递给ThreadPoolExecutor.execute())。此调用将任务添加到线程池的工作队列中，当有空闲线程可用时，管理器将获取等待时间最长的任务并在线程上运行它： kotlin object PhotoManager { fun handleState(photoTask: PhotoTask, state: Int) { when (state) { DOWNLOAD_COMPLETE -> // Decodes the image decodeThreadPool.execute(photoTask.getPhotoDecodeRunnable()) ... } ... } ... } java public class PhotoManager { public void handleState(PhotoTask photoTask, int state) { switch (state) { // The task finished downloading the image case DOWNLOAD_COMPLETE: // Decodes the image decodeThreadPool.execute( photoTask.getPhotoDecodeRunnable()); ... } ... } ... } 当ThreadPollExecutor在一个线程中启动Runnable类之后，它会自动调用Runnable类的run()方法。 中断正在执行的代码 要停止一个任务，你需要中断执行该任务的线程。要实现此操作，您需要在创建任务时将句柄存储到任务的线程。例如： kotlin class PhotoDecodeRunnable : Runnable { // Defines the code to run for this task override fun run() { /* * Stores the current Thread in the * object that contains PhotoDecodeRunnable */ photoTask.setImageDecodeThread(Thread.currentThread()) ... } ... } java class PhotoDecodeRunnable implements Runnable { // Defines the code to run for this task public void run() { /* * Stores the current Thread in the * object that contains PhotoDecodeRunnable */ photoTask.setImageDecodeThread(Thread.currentThread()); ... } ... } 要中断线程，请调用Thread.interrupt（）。请注意，Thread对象由系统控制，系统可以在应用程序的进程外修改它们。因此，您需要在中断之前获取该线程的锁以获取该线程的访问权限，方法是将访问置于synchronized块中。例如： kotlin object PhotoManager { fun cancelAll() { /* * Creates and populates an array of Runnables with the Runnables in the queue */ val runnableArray: Array = decodeWorkQueue.toTypedArray() /* * Iterates over the array of Runnables and interrupts each one's Thread. */ synchronized(this) { // Iterates over the array of tasks runnableArray.map { (it as? PhotoDecodeRunnable)?.mThread } .forEach { thread -> thread?.interrupt() } } } ... } java public class PhotoManager { public static void cancelAll() { /* * Creates an array of Runnables that's the same size as the * thread pool work queue */ Runnable[] runnableArray = new Runnable[decodeWorkQueue.size()]; // Populates the array with the Runnables in the queue mDecodeWorkQueue.toArray(runnableArray); // Stores the array length in order to iterate over the array int len = runnableArray.length; /* * Iterates over the array of Runnables and interrupts each one's Thread. */ synchronized (sInstance) { // Iterates over the array of tasks for (int runnableIndex = 0; runnableIndex 在大多数情况下，Thread.interrupt（）会立即停止线程。但是，它只会停止正在等待的线程，并且不会中断CPU或网络密集型任务。为避免减慢或锁定系统，您应该在尝试操作之前测试任何挂起的中断请求： kotlin /* * Before continuing, checks to see that the Thread hasn't * been interrupted */ if (Thread.interrupted()) return ... // Decodes a byte array into a Bitmap (CPU-intensive) BitmapFactory.decodeByteArray(imageBuffer, 0, imageBuffer.size, bitmapOptions) ... java /* * Before continuing, checks to see that the Thread hasn't * been interrupted */ if (Thread.interrupted()) { return; } ... // Decodes a byte array into a Bitmap (CPU-intensive) BitmapFactory.decodeByteArray( imageBuffer, 0, imageBuffer.length, bitmapOptions); ... 更多内容 更多内容请参阅进程和线程——概述 "},"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（5）与UI线程通信.html":{"url":"BackGroundTasks/SendingOperationsToMultipleThreads/将操作发送到多个线程——（5）与UI线程通信.html","title":"与UI线程进行通信","keywords":"","body":"将操作发送到多个线程——与UI线程通信 前一篇文章将操作发送到多个线程——在线程池中的线程中运行代码，向您展示如何在ThreadPoolExecutor管理的线程上启动任务。本文将向您展示如何将任务中的数据发送给在用户界面（UI）线程上运行的对象。这允许您的任务执行后台工作，然后将结果返回到UI元素（如bitmap）。 每个应用程序都有自己的特殊线程来运行UI对象（例如View对象），这个线程称为UI线程。只有在UI线程上运行的对象才能访问该线程上的其他对象。由于您在线程池中的线程中运行的任务未在UI线程上运行，因此它们无权访问UI中的对象。要将数据从后台线程发送到UI线程，请使用在UI线程上运行的Handler。 在UI线程定义一个Handler Handler是Android系统Framework层的一部分，其作用是管理线程。 Handler对象接收消息并运行代码来处理消息。通常，您为新线程创建一个Handler，但您也可以创建一个连接到现有线程的Handler。将Handler连接到UI线程时，处理消息的代码会在UI线程上运行。 在构造创建线程池的类的过程中实例化Handler对象，并将对象存储在全局变量中。通过使用Handler（Looper）构造函数将其实例化，将其连接到UI线程。此构造函数使用Looper对象，这是Android系统的线程管理框架的另一部分。当您基于特定的Looper实例实例化Handler时，Handler在与Looper相同的线程上运行。例如： kotlin object PhotoManager { ... private val handler: Handler = Handler(Looper.getMainLooper()) ... } java private PhotoManager() { ... // Defines a Handler object that's attached to the UI thread handler = new Handler(Looper.getMainLooper()) { ... 在Handler中，重写handleMessage()方法，Android系统会在接收到新message的时候调用handleMessage()方法，一个线程的所有Handler都会接收到相同的消息。比如： kotlin object PhotoManager { private val handler: Handler = object : Handler(Looper.getMainLooper()) { /* * handleMessage() defines the operations to perform when * the Handler receives a new Message to process. */ override fun handleMessage(inputMessage: Message) { // Gets the image task from the incoming Message object. val photoTask = inputMessage.obj as PhotoTask ... } } ... } java /* * handleMessage() defines the operations to perform when * the Handler receives a new Message to process. */ @Override public void handleMessage(Message inputMessage) { // Gets the image task from the incoming Message object. PhotoTask photoTask = (PhotoTask) inputMessage.obj; ... } ... } } 下一节将介绍如何通知Handler移动数据。 将数据从任务线程传送到UI线程 要把运行在后台线程的任务中的数据传送到UI线程上中，请首先将后台任务中数据的引用以及UI对象的引用存储下来。接下来，将要传送的数据和状态代码传递给实例化Handler的对象，在此对象中，将含有状态和要发送数据的Message通过Handler对象发送到其handleMessage（）中。因为Handler在UI线程上运行，所以它可以将数据传送到UI对象。 后台线程的对象中存储数据 例如，这是一个在后台线程上运行的Runnable，它解码Bitmap并将其存储在其父对象PhotoTask中， Runnable还存储状态代码DECODE_STATE_COMPLETED。 kotlin const val DECODE_STATE_COMPLETED: Int = ... // A class that decodes photo files into Bitmaps class PhotoDecodeRunnable( private val photoTask: PhotoTask, // Gets the downloaded byte array private var imageBuffer: ByteArray = photoTask.getByteBuffer() ) : Runnable { ... // Runs the code for this task override fun run() { ... // Tries to decode the image buffer BitmapFactory.decodeByteArray( imageBuffer, 0, imageBuffer.size, bitmapOptions )?.also { returnBitmap -> ... // Sets the ImageView Bitmap photoTask.image = returnBitmap } // Reports a status of \"completed\" photoTask.handleDecodeState(DECODE_STATE_COMPLETED) ... } ... } java // A class that decodes photo files into Bitmaps class PhotoDecodeRunnable implements Runnable { ... PhotoDecodeRunnable(PhotoTask downloadTask) { photoTask = downloadTask; } ... // Gets the downloaded byte array byte[] imageBuffer = photoTask.getByteBuffer(); ... // Runs the code for this task public void run() { ... // Tries to decode the image buffer returnBitmap = BitmapFactory.decodeByteArray( imageBuffer, 0, imageBuffer.length, bitmapOptions ); ... // Sets the ImageView Bitmap photoTask.setImage(returnBitmap); // Reports a status of \"completed\" photoTask.handleDecodeState(DECODE_STATE_COMPLETED); ... } ... } ... PhotoTask还包含一个显示Bitmap的ImageView的句柄。但即使Bitmap和ImageView的引用位于同一对象中，也无法将Bitmap分配给ImageView，因为您当前没有在UI线程上运行。 所以，下一步是将数据发送到PhotoTask对象。 将数据发送到对象层 PhotoTask是层次结构中的下一个更高级的对象。它维护对已解码数据的引用以及显示数据的View对象。它从PhotoDecodeRunnable接收状态代码并将其传递给维护线程池的对象并实例化Handler： kotlin // Gets a handle to the object that creates the thread pools class PhotoTask() { ... private val photoManager: PhotoManager = PhotoManager.getInstance() ... fun handleDecodeState(state: Int) { // Converts the decode state to the overall state. val outState: Int = when(state) { PhotoDecodeRunnable.DECODE_STATE_COMPLETED -> PhotoManager.TASK_COMPLETE ... } ... // Calls the generalized state method handleState(outState) } ... // Passes the state to PhotoManager private fun handleState(state: Int) { /* * Passes a handle to this task and the * current state to the class that created * the thread pools */ PhotoManager.handleState(this, state) } ... } java public class PhotoTask { ... // Gets a handle to the object that creates the thread pools photoManager = PhotoManager.getInstance(); ... public void handleDecodeState(int state) { int outState; // Converts the decode state to the overall state. switch(state) { case PhotoDecodeRunnable.DECODE_STATE_COMPLETED: outState = PhotoManager.TASK_COMPLETE; break; ... } ... // Calls the generalized state method handleState(outState); } ... // Passes the state to PhotoManager void handleState(int state) { /* * Passes a handle to this task and the * current state to the class that created * the thread pools */ photoManager.handleState(this, state); } ... } 将数据传送到UI PhotoManager对象从PhotoTask对象接收状态代码和PhotoTask对象的句柄。由于状态为TASK_COMPLETE，因此创建一个包含状态码和要传送数据的Message，并将其发送给Handler： kotlin object PhotoManager { ... // Handle status messages from tasks fun handleState(photoTask: PhotoTask, state: Int) { when(state) { ... TASK_COMPLETE -> { // The task finished downloading and decoding the image /* * Creates a message for the Handler * with the state and the task object */ handler.obtainMessage(state, photoTask)?.apply { sendToTarget() } } ... } ... } java public class PhotoManager { ... // Handle status messages from tasks public void handleState(PhotoTask photoTask, int state) { switch (state) { ... // The task finished downloading and decoding the image case TASK_COMPLETE: /* * Creates a message for the Handler * with the state and the task object */ Message completeMessage = handler.obtainMessage(state, photoTask); completeMessage.sendToTarget(); break; ... } ... } 最后，Handler.handleMessage（）检查每个传入消息的状态代码。如果状态代码为TASK_COMPLETE，则任务结束，Message中的PhotoTask对象包含Bitmap和ImageView，因为Handler.handleMessage（）在UI线程上运行，所以它可以安全地将Bitmap移动到ImageView： kotlin object PhotoManager { ... private val handler: Handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(inputMessage: Message) { // Gets the image task from the incoming Message object. val photoTask = inputMessage.obj as PhotoTask // Gets the ImageView for this task val localView: PhotoView = photoTask.getPhotoView() ... when (inputMessage.what) { ... TASK_COMPLETE -> localView.setImageBitmap(photoTask.image) ... else -> super.handleMessage(inputMessage) } ... } ... } ... ... } ... } java private PhotoManager() { ... handler = new Handler(Looper.getMainLooper()) { @Override public void handleMessage(Message inputMessage) { // Gets the task from the incoming Message object. PhotoTask photoTask = (PhotoTask) inputMessage.obj; // Gets the ImageView for this task PhotoView localView = photoTask.getPhotoView(); ... switch (inputMessage.what) { ... // The decoding is done case TASK_COMPLETE: /* * Moves the Bitmap from the task * to the View */ localView.setImageBitmap(photoTask.getImage()); break; ... default: /* * Pass along other messages from the UI */ super.handleMessage(inputMessage); } ... } ... } ... } ... } 更多信息 关于多线程的更多内容，请参阅进程和线程——概述。 "},"BestPractices/Performance/进程和线程——概述.html":{"url":"BestPractices/Performance/进程和线程——概述.html","title":"进程和线程——概述","keywords":"","body":"进程和线程——概述 原文(英文)地址 当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为主线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。 本文档介绍进程和线程在 Android 应用中的工作方式。 进程 默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在manifest文件中执行此操作。 各类组件元素的manifest文件条目——activity``、service、receiver 和 provider均支持 android:process属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。 此外，application 元素也支持 android:process 属性，以设置适用于所有组件的默认值。 如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。 决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，系统更有可能关闭托管屏幕上不再可见的 Activity 的进程。 因此，是否终止某个进程取决于该进程中所运行组件的状态。 有关进程生命周期及其与应用程序状态的关系的更多内容，请参阅进程和应用程序的生命周期 线程 应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面中的小部件，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。 系统不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。 因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。 例如，当用户触摸屏幕上的按钮时，应用的 UI 线程会将触摸事件分派给小部件，而小部件反过来又设置其按下状态，并将失效请求发布到事件队列中。 UI 线程从队列中取消该请求并通知小部件应该重绘自身。 在应用执行繁重的任务以响应用户交互时，除非正确实现应用，否则这种单线程模式可能会导致性能低下。 具体地讲，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。 一旦线程被阻塞，将无法分派任何事件，包括绘图事件。 从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。 此外，Android UI 工具包并非线程安全工具包。因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。 因此，Android 的单线程模式必须遵守两条规则： 不要阻塞 UI 线程 不要在 UI 线程之外访问 Android UI 工具包 工作线程 根据上述单线程模式，要保证应用 UI 的响应能力，关键是不能阻塞 UI 线程。 如果您要执行的操作不是即时的，则应确保在单独的线程（“后台”或“工作线程”线程）中执行它们。 但是，请注意，您无法从UI线程或“主”线程以外的任何线程更新UI。 为了解决这个问题，Android提供了几种从其他线程访问UI线程的方法。以下列出了可以提供帮助的方法： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) 示例代码： kotlin fun onClick(v: View) { Thread(Runnable { // a potentially time consuming task val bitmap = processBitMap(\"image.png\") imageView.post { imageView.setImageBitmap(bitmap) } }).start() } java public void onClick(View v) { new Thread(new Runnable() { public void run() { // a potentially time consuming task final Bitmap bitmap = processBitMap(\"image.png\"); imageView.post(new Runnable() { public void run() { imageView.setImageBitmap(bitmap); } }); } }).start(); } 例如，以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在 ImageView 中： public void onClick(View v) { new Thread(new Runnable() { public void run() { Bitmap b = loadImageFromNetwork(\"http://example.com/image.png\"); mImageView.setImageBitmap(b); } }).start(); } 此实现是线程安全的：后台操作是在单独的线程完成的，而ImageView始终是在UI线程操作的。 但是，随着操作复杂性的增加，这种代码变得复杂且难以维护。要处理与工作线程的更复杂的交互，您可以考虑在工作线程中使用Handler来处理从UI线程传递的消息。也许最好的解决方案是继承AsyncTask类，它简化了需要与UI交互的工作线程任务的执行。 使用 AsyncTask AsyncTask允许您在用户界面上执行异步工作。它在工作线程中执行阻塞操作，然后在UI线程上发布结果，而不需要您自己处理线程和/或处理程序。 要使用它，必须创建 AsyncTask 的子类并实现 doInBackground() 回调方法，该方法将在后台线程池中运行。 要更新 UI，应该实现 onPostExecute() 以传递 doInBackground() 返回的结果并在 UI 线程中运行，以便您安全地更新 UI。 之后，您可以通过从 UI 线程调用 execute() 来运行任务。 您应该阅读AsyncTask文档，以全面了解如何使用此类。 线程安全的方法 在某些情况下，您实现的方法可能会从多个线程调用，因此编写这些方法时必须确保其满足线程安全的要求。 这一点主要适用于可以远程调用的方法，如绑定Service中的方法。如果对 IBinder 中所实现方法的调用源自运行 IBinder的同一进程，则该方法在调用方的线程中执行。但是，如果调用源自其他进程，则该方法将在从线程池选择的某个线程中执行（而不是在进程的 UI 线程中执行），线程池由系统在与 IBinder 相同的进程中维护。 例如，即使Service的 onBind() 方法将从服务进程的 UI 线程调用，在 onBind() 返回的对象中实现的方法（例如，实现 RPC 方法的子类）仍会从线程池中的线程调用。 由于一个Service可以有多个客户端，因此可能会有多个池线程在同一时间使用同一 IBinder 方法。因此，IBinder 方法必须实现为线程安全方法。 同样，内容提供程序也可接收来自其他进程的数据请求。尽管 ContentResolver 和 ContentProvider 类隐藏了如何管理进程间通信的细节，但响应这些请求的 ContentProvider 方法（query()、insert()、delete()、update() 和 getType() 方法）将从内容提供程序所在进程的线程池中调用，而不是从进程的 UI 线程调用。 由于这些方法可能会同时从任意数量的线程调用，因此它们也必须实现为线程安全方法。 进程间通信 Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity 或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。 这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。 然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。 要执行 IPC，必须使用 bindService() 将应用绑定到服务上。如需了解详细信息，请参阅Service开发者指南。 "}}